{"ast":null,"code":"import { DateAxis } from \"./DateAxis\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $math from \"../../../core/util/Math\";\n/**\r\n * A version of a [[DateAxis]] which removes intervals that don't have any data\r\n * items in them.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info\r\n * @important\r\n */\nexport class GaplessDateAxis extends DateAxis {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"_m\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_dates\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_customDates\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _afterNew() {\n    this.valueFields.push(\"date\");\n    super._afterNew();\n  }\n  _getDates() {\n    if (this._customDates) {\n      return this._customDates;\n    }\n    return this._dates;\n  }\n  _updateDates(date, series) {\n    if (!series.get(\"ignoreMinMax\")) {\n      const dates = this._getDates();\n      const result = $array.getSortedIndex(dates, x => $order.compare(x, date));\n      if (!result.found) {\n        $array.insertIndex(dates, result.index, date);\n      }\n    }\n  }\n  _updateAllDates() {\n    if (!this._customDates) {\n      const dates = this._dates;\n      dates.length = 0;\n      $array.each(this.series, series => {\n        let field = \"valueX\";\n        if (series.get(\"yAxis\") == this) {\n          field = \"valueY\";\n        }\n        $array.each(series.dataItems, dataItem => {\n          let value = dataItem.get(field);\n          if ($type.isNumber(value)) {\n            if (dataItem.open) {\n              this._updateDates(dataItem.open[field], series);\n            }\n          }\n        });\n      });\n      const extraMax = this.get(\"extraMax\", 0);\n      const extraMin = this.get(\"extraMin\", 0);\n      let len = dates.length;\n      const baseInterval = this.getPrivate(\"baseInterval\");\n      const baseCount = baseInterval.count;\n      const timeUnit = baseInterval.timeUnit;\n      if (extraMax > 0) {\n        const extra = len * extraMax;\n        let time = dates[len - 1];\n        if ($type.isNumber(time)) {\n          for (let i = len - 1; i < len + extra; i++) {\n            time += $time.getDuration(timeUnit, baseCount * this._getM(timeUnit));\n            //time = $time.round(new Date(time), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n            time = $time.roun(time, timeUnit, baseCount, this._root);\n            dates.push(time);\n          }\n        }\n      }\n      if (extraMin > 0) {\n        const extra = len * extraMin;\n        let time = dates[0];\n        if ($type.isNumber(time)) {\n          for (let i = 0; i < extra; i++) {\n            time -= $time.getDuration(timeUnit, baseCount);\n            //time = $time.round(new Date(time), timeUnit, baseCount, firstDay, utc, undefined, timezone).getTime();\n            time = $time.roun(time, timeUnit, baseCount, this._root);\n            dates.unshift(time);\n          }\n        }\n      }\n    }\n  }\n  /**\r\n   * Convers value to a relative position on axis.\r\n   *\r\n   * @param   value  Value\r\n   * @return         Relative position\r\n   */\n  valueToPosition(value) {\n    const dates = this._getDates();\n    const startLocation = this.get(\"startLocation\", 0);\n    const endLocation = this.get(\"endLocation\", 1);\n    const len = dates.length - startLocation - (1 - endLocation);\n    const result = $array.getSortedIndex(dates, x => $order.compare(x, value));\n    let index = result.index;\n    if (result.found) {\n      return (index - startLocation) / len;\n    } else {\n      if (index > 0) {\n        index -= 1;\n      }\n      let itemValue = dates[index];\n      const nextDate = dates[index + 1];\n      if (nextDate) {\n        let nextItemValue = nextDate;\n        // use next item value if it's closer\n        if (Math.abs(nextItemValue - value) < Math.abs(itemValue - value)) {\n          itemValue = nextItemValue;\n          index++;\n        }\n      }\n      /*\r\n      let d = 0;\r\n      if (itemValue > value && value > this.getPrivate(\"min\", 0)) {\r\n          d = itemValue - value;\r\n      }\r\n      else {\r\n          d = value - itemValue;\r\n      }\r\n      */\n      let d = value - itemValue;\n      return (index - startLocation) / len + d / this.baseDuration() / len;\n    }\n  }\n  /**\r\n   * Converts numeric value from axis scale to index.\r\n   *\r\n   * @param  value  Value\r\n   * @return        Index\r\n   */\n  valueToIndex(value) {\n    const dates = this._getDates();\n    const result = $array.getSortedIndex(dates, x => $order.compare(x, value));\n    let index = result.index;\n    if (result.found) {\n      return index;\n    } else {\n      if (index > 0) {\n        index -= 1;\n      }\n      return index;\n    }\n  }\n  /**\r\n   * Converts a relative position to a corresponding numeric value from axis\r\n   * scale.\r\n   *\r\n   * @param   position  Relative position\r\n   * @return            Value\r\n   */\n  positionToValue(position) {\n    const startLocation = this.get(\"startLocation\", 0);\n    const endLocation = this.get(\"endLocation\", 1);\n    const dates = this._getDates();\n    let len = Math.round(dates.length - startLocation - (1 - endLocation));\n    let index = position * len;\n    let findex = Math.floor(index);\n    if (findex < 0) {\n      findex = 0;\n    }\n    if (findex > len - 1) {\n      findex = len - 1;\n    }\n    return dates[findex] + (index - findex + startLocation) * this.baseDuration();\n  }\n  _fixZoomFactor() {\n    this.setPrivateRaw(\"maxZoomFactor\", this._getDates().length - this.get(\"startLocation\", 0) - (1 - this.get(\"endLocation\", 1)));\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` dates.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start Date\r\n   * @param  end       End Date\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToDates(start, end, duration) {\n    const dates = this._getDates();\n    const len = dates.length;\n    let result = $array.getSortedIndex(dates, x => $order.compare(x, start.getTime()));\n    let startValue = dates[Math.min(result.index, len - 1)];\n    result = $array.getSortedIndex(dates, x => $order.compare(x, end.getTime()));\n    let endValue = dates[result.index];\n    if (result.index >= len) {\n      endValue = dates[len - 1] + this.baseDuration();\n    }\n    this.zoomToValues(startValue, endValue, duration);\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` values.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start value\r\n   * @param  end       End value\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToValues(start, end, duration) {\n    const min = this.getPrivate(\"min\", 0);\n    const max = this.getPrivate(\"max\", 0);\n    start = $math.fitToRange(start, min, max);\n    end = $math.fitToRange(end, min, max);\n    this.zoom(this.valueToPosition(start), this.valueToPosition(end), duration);\n  }\n  _prepareAxisItems() {\n    let startTime = this.getPrivate(\"selectionMin\", 0);\n    let endTime = this.getPrivate(\"selectionMax\", 0);\n    if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n      if (this._seriesValuesDirty) {\n        this._seriesValuesDirty = false;\n        this._updateAllDates();\n      }\n      const root = this._root;\n      const utc = root.utc;\n      const timezone = root.timezone;\n      const dates = this._getDates();\n      const renderer = this.get(\"renderer\");\n      const len = dates.length;\n      const baseDuration = this.baseDuration();\n      let startIndex = this.valueToIndex(startTime);\n      if (startIndex > 0) {\n        startIndex--;\n      }\n      let endIndex = this.valueToIndex(endTime);\n      if (endIndex < len - 1) {\n        endIndex++;\n      }\n      let maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n      let frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n      frequency = Math.max(1, frequency);\n      startIndex = Math.floor(startIndex / frequency) * frequency;\n      this._frequency = frequency;\n      $array.each(this.dataItems, dataItem => {\n        this._toggleDataItem(dataItem, false);\n      });\n      $array.each(this.minorDataItems, dataItem => {\n        this._toggleDataItem(dataItem, false);\n      });\n      let realDuration = endTime - startTime - ((endTime - startTime) / baseDuration - (endIndex - startIndex)) * baseDuration;\n      // if all items are on axis\n      let gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\n      const baseInterval = this.getPrivate(\"baseInterval\");\n      let intervalDuration = $time.getIntervalDuration(gridInterval);\n      if (intervalDuration < baseDuration) {\n        gridInterval = Object.assign({}, baseInterval);\n        intervalDuration = $time.getIntervalDuration(gridInterval);\n      }\n      this._intervalDuration = intervalDuration;\n      const timeUnit = gridInterval.timeUnit;\n      const formats = this.get(\"dateFormats\");\n      let firstTime = Date.now();\n      if (dates[0]) {\n        firstTime = dates[0];\n      }\n      //let value = $time.round(new Date(this.getPrivate(\"selectionMin\", 0)), timeUnit, gridInterval.count, firstDay, utc, firstDate, timezone).getTime();\n      let value = $time.roun(this.getPrivate(\"selectionMin\", 0), timeUnit, gridInterval.count, root, firstTime);\n      const minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\n      const minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\n      let minorGridInterval;\n      let minorDuration = 0;\n      let previousDataItem;\n      if (minorGridEnabled) {\n        minorGridInterval = this._getMinorInterval(gridInterval);\n        minorDuration = $time.getIntervalDuration(minorGridInterval);\n      }\n      let selectedItems = this._getIndexes(value, this.getPrivate(\"selectionMax\", value) + intervalDuration, gridInterval, this.getPrivate(\"min\", value));\n      if (selectedItems.length > 0) {\n        let i = 0;\n        this._m = 0;\n        let previousValue = value - intervalDuration * 10;\n        const nextGridUnit = $time.getNextUnit(timeUnit);\n        // MINOR GRID\n        if (minorGridInterval) {\n          let first = dates[selectedItems[0]];\n          this._addMinorGrid(first - intervalDuration, first, minorDuration, minorGridInterval);\n        }\n        let minDistance = renderer.axisLength() / renderer.gridCount() * 0.5;\n        $array.each(selectedItems, index => {\n          var _a;\n          let dataItem;\n          if (this.dataItems.length < i + 1) {\n            dataItem = new DataItem(this, undefined, {});\n            this._dataItems.push(dataItem);\n            this.processDataItem(dataItem);\n          } else {\n            dataItem = this.dataItems[i];\n          }\n          let value = dates[index];\n          let date = new Date(value);\n          let endValue = value;\n          if (i < selectedItems.length - 1) {\n            endValue = dates[selectedItems[i + 1]];\n          } else {\n            endValue += intervalDuration;\n          }\n          dataItem.setRaw(\"value\", value);\n          dataItem.setRaw(\"endValue\", endValue);\n          dataItem.setRaw(\"index\", i);\n          dataItem.setRaw(\"labelEndValue\", undefined);\n          let format = formats[timeUnit];\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if (timeUnit != \"year\") {\n              if ($time.checkChange(value, previousValue, nextGridUnit, utc, timezone)) {\n                format = this.get(\"periodChangeDateFormats\")[timeUnit];\n              }\n            }\n          }\n          this._createAssets(dataItem, []);\n          const label = dataItem.get(\"label\");\n          if (label) {\n            label.set(\"text\", root.dateFormatter.format(date, format));\n          }\n          this._toggleDataItem(dataItem, true);\n          let count = gridInterval.count;\n          // so that labels of week would always be at the beginning of the grid\n          if (timeUnit == \"week\") {\n            dataItem.setRaw(\"labelEndValue\", value);\n          }\n          if (minorGridEnabled) {\n            let timeUnit2 = gridInterval.timeUnit;\n            if (timeUnit2 == \"week\") {\n              timeUnit2 = \"day\";\n            }\n            if (count > 1 || gridInterval.timeUnit == \"week\") {\n              //let labelEndValue = $time.round(new Date(value), timeUnit2, 1, firstDay, utc, undefined, timezone).getTime() + $time.getDuration(timeUnit2, this._getM(timeUnit2));\n              let labelEndValue = $time.roun(value, timeUnit2, 1, root) + $time.getDuration(timeUnit2, this._getM(timeUnit2));\n              let index = this.valueToIndex(labelEndValue);\n              labelEndValue = dates[index];\n              if (labelEndValue == value) {\n                let next = dates[index + 1];\n                if (next) {\n                  labelEndValue = next;\n                } else {\n                  labelEndValue += minorDuration;\n                }\n              }\n              dataItem.setRaw(\"labelEndValue\", labelEndValue);\n            }\n            count = 1;\n          }\n          this._prepareDataItem(dataItem, count);\n          if (label && previousDataItem) {\n            if (renderer.getPrivate(\"letter\") == \"X\") {\n              let previousLabel = previousDataItem.get(\"label\");\n              if (previousLabel) {\n                let x = label.x();\n                let previousX = previousLabel.x();\n                if (x - previousX < minDistance) {\n                  let worse = this._pickWorse(previousDataItem, dataItem, gridInterval);\n                  if (worse) {\n                    (_a = worse.get(\"label\")) === null || _a === void 0 ? void 0 : _a.setPrivate(\"visible\", false);\n                  }\n                }\n              }\n            }\n            // todo y?\n          }\n          // MINOR GRID\n          if (minorGridInterval) {\n            this._addMinorGrid(value, endValue, minorDuration, minorGridInterval);\n          }\n          i++;\n          if (label && label.getPrivate(\"visible\")) {\n            previousDataItem = dataItem;\n          }\n          previousValue = value;\n        });\n      }\n      $array.each(this.series, series => {\n        if (series.inited) {\n          series._markDirtyAxes();\n        }\n      });\n    }\n    this._updateGhost();\n  }\n  _pickWorse(dataItemA, dataItemB, interval) {\n    const timeUnit = interval.timeUnit;\n    const valueA = dataItemA.get(\"value\", 0);\n    const valueB = dataItemB.get(\"value\", 0);\n    if (timeUnit == \"hour\") {\n      if (new Date(valueA).getDate() != new Date(valueB).getDate()) {\n        return dataItemA;\n      }\n    }\n    return dataItemB;\n  }\n  _addMinorGrid(startValue, endValue, minorDuration, gridInterval) {\n    const minorFormats = this.get(\"minorDateFormats\", this.get(\"dateFormats\"));\n    const mTimeUnit = gridInterval.timeUnit;\n    let value = startValue + $time.getDuration(mTimeUnit, this._getM(mTimeUnit));\n    //value = $time.round(new Date(value), mTimeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n    value = $time.roun(value, mTimeUnit, 1, this._root);\n    let maxValue = endValue - minorDuration * 0.5;\n    let minorSelectedItems = this._getIndexes(value, maxValue, gridInterval, value);\n    const dates = this._getDates();\n    $array.each(minorSelectedItems, index => {\n      let minorDataItem;\n      if (this.minorDataItems.length < this._m + 1) {\n        minorDataItem = new DataItem(this, undefined, {});\n        this.minorDataItems.push(minorDataItem);\n        this.processDataItem(minorDataItem);\n      } else {\n        minorDataItem = this.minorDataItems[this._m];\n      }\n      value = dates[index];\n      minorDataItem.setRaw(\"value\", value);\n      minorDataItem.setRaw(\"endValue\", value + minorDuration);\n      minorDataItem.setRaw(\"index\", index);\n      this._createAssets(minorDataItem, [\"minor\"], true);\n      const label = minorDataItem.get(\"label\");\n      if (label) {\n        if (this.get(\"renderer\").get(\"minorLabelsEnabled\")) {\n          let date = new Date(value);\n          let format = minorFormats[mTimeUnit];\n          label.set(\"text\", this._root.dateFormatter.format(date, format));\n        } else {\n          label.setPrivate(\"visible\", false);\n        }\n      }\n      this._toggleDataItem(minorDataItem, true);\n      this._prepareDataItem(minorDataItem, 1);\n      this._m++;\n    });\n  }\n  _getIndexes(value, maxValue, interval, firstValue) {\n    const items = [];\n    const timeUnit = interval.timeUnit;\n    const count = interval.count;\n    const mmm = this._getM(timeUnit);\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    const root = this._root;\n    const dates = this._getDates();\n    let c = count - 1;\n    let previousValue = -Infinity;\n    let duration = $time.getDuration(timeUnit, mmm);\n    let fullDuration = $time.getDuration(timeUnit, count * mmm);\n    let originalValue = value;\n    if (timeUnit == \"day\") {\n      value = firstValue;\n    }\n    while (value <= maxValue) {\n      //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\n      value = $time.roun(value, timeUnit, count, root);\n      let index = this.valueToIndex(value);\n      let realValue = dates[index];\n      if (timeUnit == \"day\" && baseInterval.timeUnit == \"day\") {\n        if (this._hasDate(value)) {\n          c++;\n        }\n        if (c == count) {\n          if (value >= originalValue - fullDuration * 2) {\n            $array.move(items, index);\n          }\n          c = 0;\n        }\n        value += duration;\n        //value = $time.round(new Date(value), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n        value = $time.roun(value, timeUnit, 1, root);\n      } else {\n        if (realValue < value) {\n          for (let i = index, len = dates.length; i < len; i++) {\n            realValue = dates[i];\n            if (realValue >= value) {\n              index = i;\n              break;\n            }\n          }\n        }\n        $array.move(items, index);\n        value += fullDuration;\n        //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\n        value = $time.roun(value, timeUnit, count, root);\n      }\n      if (value == previousValue) {\n        value += fullDuration + duration;\n        //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\n        value = $time.roun(value, timeUnit, count, root);\n      }\n      if (value == previousValue) {\n        break;\n      }\n      previousValue = value;\n    }\n    return items;\n  }\n  _hasDate(time) {\n    const result = $array.getSortedIndex(this._getDates(), date => {\n      return $order.compareNumber(date, time);\n    });\n    return result.found;\n  }\n  _nextTime(time, count, _baseInterval) {\n    let index = $math.fitToRange(this.valueToIndex(time) + count, 0, this._dates.length - 1);\n    return this._dates[index];\n  }\n}\nObject.defineProperty(GaplessDateAxis, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"GaplessDateAxis\"\n});\nObject.defineProperty(GaplessDateAxis, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: DateAxis.classNames.concat([GaplessDateAxis.className])\n});","map":{"version":3,"names":["DateAxis","DataItem","$array","$order","$time","$type","$math","GaplessDateAxis","constructor","Object","defineProperty","_afterNew","valueFields","push","_getDates","_customDates","_dates","_updateDates","date","series","get","dates","result","getSortedIndex","x","compare","found","insertIndex","index","_updateAllDates","length","each","field","dataItems","dataItem","value","isNumber","open","extraMax","extraMin","len","baseInterval","getPrivate","baseCount","count","timeUnit","extra","time","i","getDuration","_getM","roun","_root","unshift","valueToPosition","startLocation","endLocation","itemValue","nextDate","nextItemValue","Math","abs","d","baseDuration","valueToIndex","positionToValue","position","round","findex","floor","_fixZoomFactor","setPrivateRaw","zoomToDates","start","end","duration","getTime","startValue","min","endValue","zoomToValues","max","fitToRange","zoom","_prepareAxisItems","startTime","endTime","_seriesValuesDirty","root","utc","timezone","renderer","startIndex","endIndex","maxCount","axisLength","Number","MAX_SAFE_INTEGER","frequency","ceil","_frequency","_toggleDataItem","minorDataItems","realDuration","gridInterval","chooseInterval","intervalDuration","getIntervalDuration","assign","_intervalDuration","formats","firstTime","Date","now","minorLabelsEnabled","minorGridEnabled","minorGridInterval","minorDuration","previousDataItem","_getMinorInterval","selectedItems","_getIndexes","_m","previousValue","nextGridUnit","getNextUnit","first","_addMinorGrid","minDistance","gridCount","undefined","_dataItems","processDataItem","setRaw","format","checkChange","_createAssets","label","set","dateFormatter","timeUnit2","labelEndValue","next","_prepareDataItem","previousLabel","previousX","worse","_pickWorse","_a","setPrivate","inited","_markDirtyAxes","_updateGhost","dataItemA","dataItemB","interval","valueA","valueB","getDate","minorFormats","mTimeUnit","maxValue","minorSelectedItems","minorDataItem","firstValue","items","mmm","c","Infinity","fullDuration","originalValue","realValue","_hasDate","move","compareNumber","_nextTime","_baseInterval","classNames","concat","className"],"sources":["C:\\Users\\Moham\\Downloads\\Github projects\\Digital-Portfolio-main\\Frontend\\node_modules\\src\\.internal\\charts\\xy\\axes\\GaplessDateAxis.ts"],"sourcesContent":["import type { AxisRenderer } from \"./AxisRenderer\";\r\n\r\nimport { DateAxis, IDateAxisSettings, IDateAxisPrivate, IDateAxisDataItem, IDateAxisEvents } from \"./DateAxis\";\r\nimport { DataItem } from \"../../../core/render/Component\";\r\nimport type { XYSeries } from \"../../xy/series/XYSeries\";\r\n\r\nimport * as $array from \"../../../core/util/Array\"\r\nimport * as $order from \"../../../core/util/Order\";\r\nimport * as $time from \"../../../core/util/Time\";\r\nimport * as $type from \"../../../core/util/Type\";\r\nimport * as $math from \"../../../core/util/Math\";\r\nimport type { ITimeInterval } from \"../../../core/util/Time\";\r\n\r\nexport interface IGaplessDateAxisSettings<R extends AxisRenderer> extends IDateAxisSettings<R> {\r\n\r\n}\r\n\r\nexport interface IGaplessDateAxisDataItem extends IDateAxisDataItem {\r\n\r\n\t/**\r\n\t * An index of a data item.\r\n\t */\r\n\tindex?: number\r\n\r\n}\r\n\r\nexport interface IGaplessDateAxisPrivate extends IDateAxisPrivate {\r\n\r\n}\r\n\r\nexport interface IGaplessDateAxisEvents extends IDateAxisEvents {\r\n}\r\n\r\n/**\r\n * A version of a [[DateAxis]] which removes intervals that don't have any data\r\n * items in them.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info\r\n * @important\r\n */\r\nexport class GaplessDateAxis<R extends AxisRenderer> extends DateAxis<R> {\r\n\tpublic static className: string = \"GaplessDateAxis\";\r\n\tpublic static classNames: Array<string> = DateAxis.classNames.concat([GaplessDateAxis.className]);\r\n\r\n\tdeclare public _settings: IGaplessDateAxisSettings<R>;\r\n\tdeclare public _privateSettings: IGaplessDateAxisPrivate;\r\n\tdeclare public _dataItemSettings: IGaplessDateAxisDataItem;\r\n\tdeclare public _events: IGaplessDateAxisEvents;\r\n\r\n\tprotected _frequency: number = 1;\r\n\tprotected _m: number = 0;\r\n\r\n\tpublic _afterNew() {\r\n\t\tthis.valueFields.push(\"date\");\r\n\t\tsuper._afterNew();\r\n\t}\r\n\r\n\tpublic _dates: Array<number> = [];\r\n\tpublic _customDates?: Array<number>;\r\n\r\n\r\n\tpublic _getDates(): Array<number> {\r\n\t\tif (this._customDates) {\r\n\t\t\treturn this._customDates;\r\n\t\t}\r\n\t\treturn this._dates;\r\n\t}\r\n\r\n\tprotected _updateDates(date: number, series: XYSeries) {\r\n\t\tif (!series.get(\"ignoreMinMax\")) {\r\n\t\t\tconst dates = this._getDates();\r\n\t\t\tconst result = $array.getSortedIndex(dates, (x) => $order.compare(x, date));\r\n\t\t\tif (!result.found) {\r\n\t\t\t\t$array.insertIndex(dates, result.index, date);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic _updateAllDates() {\r\n\t\tif (!this._customDates) {\r\n\t\t\tconst dates = this._dates;\r\n\t\t\tdates.length = 0;\r\n\r\n\t\t\t$array.each(this.series, (series) => {\r\n\t\t\t\tlet field = \"valueX\";\r\n\t\t\t\tif (series.get(\"yAxis\") == this) {\r\n\t\t\t\t\tfield = \"valueY\"\r\n\t\t\t\t}\r\n\t\t\t\t$array.each(series.dataItems, (dataItem) => {\r\n\t\t\t\t\tlet value = dataItem.get(field as any);\r\n\t\t\t\t\tif ($type.isNumber(value)) {\r\n\t\t\t\t\t\tif (dataItem.open) {\r\n\t\t\t\t\t\t\tthis._updateDates(dataItem.open![field], series);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\r\n\t\t\tconst extraMax = this.get(\"extraMax\", 0);\r\n\t\t\tconst extraMin = this.get(\"extraMin\", 0);\r\n\r\n\t\t\tlet len = dates.length;\r\n\r\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\r\n\t\t\tconst baseCount = baseInterval.count;\r\n\t\t\tconst timeUnit = baseInterval.timeUnit;\r\n\r\n\t\t\tif (extraMax > 0) {\r\n\t\t\t\tconst extra = len * extraMax;\r\n\t\t\t\tlet time = dates[len - 1];\r\n\t\t\t\tif ($type.isNumber(time)) {\r\n\t\t\t\t\tfor (let i = len - 1; i < len + extra; i++) {\r\n\t\t\t\t\t\ttime += $time.getDuration(timeUnit, baseCount * this._getM(timeUnit));\r\n\t\t\t\t\t\t//time = $time.round(new Date(time), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\r\n\t\t\t\t\t\ttime = $time.roun(time, timeUnit, baseCount, this._root);\r\n\t\t\t\t\t\tdates.push(time);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (extraMin > 0) {\r\n\t\t\t\tconst extra = len * extraMin;\r\n\t\t\t\tlet time = dates[0];\r\n\t\t\t\tif ($type.isNumber(time)) {\r\n\t\t\t\t\tfor (let i = 0; i < extra; i++) {\r\n\t\t\t\t\t\ttime -= $time.getDuration(timeUnit, baseCount);\r\n\t\t\t\t\t\t//time = $time.round(new Date(time), timeUnit, baseCount, firstDay, utc, undefined, timezone).getTime();\r\n\t\t\t\t\t\ttime = $time.roun(time, timeUnit, baseCount, this._root);\r\n\t\t\t\t\t\tdates.unshift(time);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Convers value to a relative position on axis.\r\n\t *\r\n\t * @param   value  Value\r\n\t * @return         Relative position\r\n\t */\r\n\tpublic valueToPosition(value: number): number {\r\n\t\tconst dates = this._getDates();\r\n\t\tconst startLocation = this.get(\"startLocation\", 0);\r\n\t\tconst endLocation = this.get(\"endLocation\", 1);\r\n\t\tconst len = dates.length - startLocation - (1 - endLocation);\r\n\t\tconst result = $array.getSortedIndex(dates, (x) => $order.compare(x, value));\r\n\t\tlet index = result.index;\r\n\r\n\t\tif (result.found) {\r\n\t\t\treturn (index - startLocation) / len;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (index > 0) {\r\n\t\t\t\tindex -= 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet itemValue = dates[index];\r\n\t\t\tconst nextDate = dates[index + 1];\r\n\t\t\tif(nextDate){\r\n\t\t\t\tlet nextItemValue = nextDate;\r\n\t\t\t\t// use next item value if it's closer\r\n\t\t\t\tif (Math.abs(nextItemValue - value) < Math.abs(itemValue - value)) {\r\n\t\t\t\t\titemValue = nextItemValue;\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/*\r\n\t\t\tlet d = 0;\r\n\t\t\tif (itemValue > value && value > this.getPrivate(\"min\", 0)) {\r\n\t\t\t\td = itemValue - value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\td = value - itemValue;\r\n\t\t\t}\r\n\t\t\t*/\r\n\r\n\t\t\tlet d = value - itemValue;\r\n\r\n\t\t\treturn (index - startLocation) / len + d / this.baseDuration() / len;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts numeric value from axis scale to index.\r\n\t * \r\n\t * @param  value  Value\r\n\t * @return        Index\r\n\t */\r\n\tpublic valueToIndex(value: number): number {\r\n\t\tconst dates = this._getDates();\r\n\r\n\t\tconst result = $array.getSortedIndex(dates, (x) => $order.compare(x, value));\r\n\t\tlet index = result.index;\r\n\r\n\t\tif (result.found) {\r\n\t\t\treturn index;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (index > 0) {\r\n\t\t\t\tindex -= 1;\r\n\t\t\t}\r\n\t\t\treturn index;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a relative position to a corresponding numeric value from axis\r\n\t * scale.\r\n\t *\r\n\t * @param   position  Relative position\r\n\t * @return            Value\r\n\t */\r\n\tpublic positionToValue(position: number): number {\r\n\t\tconst startLocation = this.get(\"startLocation\", 0);\r\n\t\tconst endLocation = this.get(\"endLocation\", 1);\r\n\t\tconst dates = this._getDates();\r\n\t\tlet len = Math.round(dates.length - startLocation - (1 - endLocation));\r\n\t\tlet index = position * len;\r\n\t\tlet findex = Math.floor(index);\r\n\t\tif (findex < 0) {\r\n\t\t\tfindex = 0;\r\n\t\t}\r\n\r\n\t\tif (findex > len - 1) {\r\n\t\t\tfindex = len - 1\r\n\t\t}\r\n\r\n\t\treturn dates[findex] + (index - findex + startLocation) * this.baseDuration();\r\n\t}\r\n\r\n\tprotected _fixZoomFactor() {\r\n\t\tthis.setPrivateRaw(\"maxZoomFactor\", this._getDates().length - this.get(\"startLocation\", 0) - (1 - this.get(\"endLocation\", 1)));\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the axis to specific `start` and `end` dates.\r\n\t *\r\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n\t *\r\n\t * @param  start     Start Date\r\n\t * @param  end       End Date\r\n\t * @param  duration  Duration in milliseconds\r\n\t */\r\n\r\n\tpublic zoomToDates(start: Date, end: Date, duration?: number) {\r\n\t\tconst dates = this._getDates();\r\n\t\tconst len = dates.length;\r\n\t\tlet result = $array.getSortedIndex(dates, (x) => $order.compare(x, start.getTime()));\r\n\r\n\t\tlet startValue = dates[Math.min(result.index, len - 1)];\r\n\r\n\t\tresult = $array.getSortedIndex(dates, (x) => $order.compare(x, end.getTime()));\r\n\t\tlet endValue = dates[result.index];\r\n\r\n\t\tif (result.index >= len) {\r\n\t\t\tendValue = dates[len - 1] + this.baseDuration();\r\n\t\t}\r\n\r\n\t\tthis.zoomToValues(startValue, endValue, duration);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the axis to specific `start` and `end` values.\r\n\t *\r\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n\t *\r\n\t * @param  start     Start value\r\n\t * @param  end       End value\r\n\t * @param  duration  Duration in milliseconds\r\n\t */\r\n\tpublic zoomToValues(start: number, end: number, duration?: number) {\r\n\t\tconst min = this.getPrivate(\"min\", 0);\r\n\t\tconst max = this.getPrivate(\"max\", 0);\r\n\t\tstart = $math.fitToRange(start, min, max);\r\n\t\tend = $math.fitToRange(end, min, max);\r\n\t\tthis.zoom(this.valueToPosition(start), this.valueToPosition(end), duration);\r\n\t}\r\n\r\n\r\n\tprotected _prepareAxisItems() {\r\n\t\tlet startTime = this.getPrivate(\"selectionMin\", 0);\r\n\t\tlet endTime = this.getPrivate(\"selectionMax\", 0);\r\n\r\n\t\tif ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n\r\n\t\t\tif (this._seriesValuesDirty) {\r\n\t\t\t\tthis._seriesValuesDirty = false;\r\n\t\t\t\tthis._updateAllDates();\r\n\t\t\t}\r\n\r\n\t\t\tconst root = this._root;\r\n\t\t\tconst utc = root.utc;\r\n\t\t\tconst timezone = root.timezone;\r\n\t\t\tconst dates = this._getDates();\r\n\t\t\tconst renderer = this.get(\"renderer\");\r\n\t\t\tconst len = dates.length;\r\n\t\t\tconst baseDuration = this.baseDuration();\r\n\r\n\t\t\tlet startIndex = this.valueToIndex(startTime);\r\n\t\t\tif (startIndex > 0) {\r\n\t\t\t\tstartIndex--;\r\n\t\t\t}\r\n\r\n\t\t\tlet endIndex = this.valueToIndex(endTime);\r\n\t\t\tif (endIndex < len - 1) {\r\n\t\t\t\tendIndex++;\r\n\t\t\t}\r\n\t\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1 / Number.MAX_SAFE_INTEGER);\r\n\t\t\tlet frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\r\n\t\t\tfrequency = Math.max(1, frequency);\r\n\r\n\t\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\r\n\r\n\t\t\tthis._frequency = frequency;\r\n\r\n\t\t\t$array.each(this.dataItems, (dataItem) => {\r\n\t\t\t\tthis._toggleDataItem(dataItem, false);\r\n\t\t\t})\r\n\r\n\t\t\t$array.each(this.minorDataItems, (dataItem) => {\r\n\t\t\t\tthis._toggleDataItem(dataItem, false);\r\n\t\t\t})\r\n\r\n\t\t\tlet realDuration = (endTime - startTime) - ((endTime - startTime) / baseDuration - (endIndex - startIndex)) * baseDuration;\r\n\r\n\t\t\t// if all items are on axis\r\n\t\t\tlet gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\")!);\r\n\r\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\r\n\t\t\tlet intervalDuration = $time.getIntervalDuration(gridInterval);\r\n\r\n\t\t\tif (intervalDuration < baseDuration) {\r\n\t\t\t\tgridInterval = { ...baseInterval };\r\n\t\t\t\tintervalDuration = $time.getIntervalDuration(gridInterval);\r\n\t\t\t}\r\n\r\n\t\t\tthis._intervalDuration = intervalDuration;\r\n\r\n\t\t\tconst timeUnit = gridInterval.timeUnit;\r\n\t\t\tconst formats = this.get(\"dateFormats\")!;\r\n\r\n\t\t\tlet firstTime = Date.now();\r\n\r\n\t\t\tif (dates[0]) {\r\n\t\t\t\tfirstTime = dates[0];\r\n\t\t\t}\r\n\r\n\t\t\t//let value = $time.round(new Date(this.getPrivate(\"selectionMin\", 0)), timeUnit, gridInterval.count, firstDay, utc, firstDate, timezone).getTime();\r\n\t\t\tlet value = $time.roun(this.getPrivate(\"selectionMin\", 0), timeUnit, gridInterval.count, root, firstTime);\r\n\r\n\t\t\tconst minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\r\n\t\t\tconst minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\r\n\r\n\t\t\tlet minorGridInterval: ITimeInterval | undefined;\r\n\t\t\tlet minorDuration = 0;\r\n\t\t\tlet previousDataItem: DataItem<IGaplessDateAxisDataItem> | undefined;\r\n\r\n\t\t\tif (minorGridEnabled) {\r\n\t\t\t\tminorGridInterval = this._getMinorInterval(gridInterval);\r\n\t\t\t\tminorDuration = $time.getIntervalDuration(minorGridInterval);\r\n\t\t\t}\r\n\r\n\r\n\t\t\tlet selectedItems: Array<number> = this._getIndexes(value, this.getPrivate(\"selectionMax\", value) + intervalDuration, gridInterval, this.getPrivate(\"min\", value));\r\n\t\t\tif (selectedItems.length > 0) {\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\tthis._m = 0;\r\n\t\t\t\tlet previousValue = value - intervalDuration * 10;\r\n\t\t\t\tconst nextGridUnit = $time.getNextUnit(timeUnit);\r\n\r\n\t\t\t\t// MINOR GRID\r\n\t\t\t\tif (minorGridInterval) {\r\n\t\t\t\t\tlet first = dates[selectedItems[0]];\r\n\t\t\t\t\tthis._addMinorGrid(first - intervalDuration, first, minorDuration, minorGridInterval);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet minDistance = renderer.axisLength() / renderer.gridCount() * 0.5;\r\n\r\n\t\t\t\t$array.each(selectedItems, (index) => {\r\n\t\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\r\n\t\t\t\t\tif (this.dataItems.length < i + 1) {\r\n\t\t\t\t\t\tdataItem = new DataItem<this[\"_dataItemSettings\"]>(this, undefined, {});\r\n\t\t\t\t\t\tthis._dataItems.push(dataItem);\r\n\t\t\t\t\t\tthis.processDataItem(dataItem);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tdataItem = this.dataItems[i];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet value = dates[index];\r\n\t\t\t\t\tlet date = new Date(value);\r\n\r\n\t\t\t\t\tlet endValue = value;\r\n\t\t\t\t\tif (i < selectedItems.length - 1) {\r\n\t\t\t\t\t\tendValue = dates[selectedItems[i + 1]];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tendValue += intervalDuration;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdataItem.setRaw(\"value\", value);\r\n\t\t\t\t\tdataItem.setRaw(\"endValue\", endValue);\r\n\t\t\t\t\tdataItem.setRaw(\"index\", i);\r\n\t\t\t\t\tdataItem.setRaw(\"labelEndValue\", undefined);\r\n\r\n\t\t\t\t\tlet format = formats[timeUnit];\r\n\t\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\r\n\t\t\t\t\t\tif (timeUnit != \"year\") {\r\n\t\t\t\t\t\t\tif ($time.checkChange(value, previousValue, nextGridUnit, utc, timezone)) {\r\n\t\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![timeUnit];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._createAssets(dataItem, []);\r\n\r\n\t\t\t\t\tconst label = dataItem.get(\"label\");\r\n\t\t\t\t\tif (label) {\r\n\t\t\t\t\t\tlabel.set(\"text\", root.dateFormatter.format(date, format!));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._toggleDataItem(dataItem, true);\r\n\r\n\t\t\t\t\tlet count = gridInterval.count;\r\n\r\n\t\t\t\t\t// so that labels of week would always be at the beginning of the grid\r\n\t\t\t\t\tif (timeUnit == \"week\") {\r\n\t\t\t\t\t\tdataItem.setRaw(\"labelEndValue\", value);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (minorGridEnabled) {\r\n\t\t\t\t\t\tlet timeUnit2 = gridInterval.timeUnit;\r\n\t\t\t\t\t\tif (timeUnit2 == \"week\") {\r\n\t\t\t\t\t\t\ttimeUnit2 = \"day\";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (count > 1 || gridInterval.timeUnit == \"week\") {\r\n\t\t\t\t\t\t\t//let labelEndValue = $time.round(new Date(value), timeUnit2, 1, firstDay, utc, undefined, timezone).getTime() + $time.getDuration(timeUnit2, this._getM(timeUnit2));\r\n\t\t\t\t\t\t\tlet labelEndValue = $time.roun(value, timeUnit2, 1, root) + $time.getDuration(timeUnit2, this._getM(timeUnit2));\r\n\t\t\t\t\t\t\tlet index = this.valueToIndex(labelEndValue)\r\n\t\t\t\t\t\t\tlabelEndValue = dates[index];\r\n\t\t\t\t\t\t\tif (labelEndValue == value) {\r\n\t\t\t\t\t\t\t\tlet next = dates[index + 1];\r\n\t\t\t\t\t\t\t\tif (next) {\r\n\t\t\t\t\t\t\t\t\tlabelEndValue = next;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tlabelEndValue += minorDuration;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tdataItem.setRaw(\"labelEndValue\", labelEndValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcount = 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._prepareDataItem(dataItem, count);\r\n\r\n\t\t\t\t\tif (label && previousDataItem) {\r\n\t\t\t\t\t\tif (renderer.getPrivate(\"letter\") == \"X\") {\r\n\t\t\t\t\t\t\tlet previousLabel = previousDataItem.get(\"label\");\r\n\t\t\t\t\t\t\tif (previousLabel) {\r\n\t\t\t\t\t\t\t\tlet x = label.x();\r\n\t\t\t\t\t\t\t\tlet previousX = previousLabel.x();\r\n\r\n\t\t\t\t\t\t\t\tif (x - previousX < minDistance) {\r\n\t\t\t\t\t\t\t\t\tlet worse = this._pickWorse(previousDataItem, dataItem, gridInterval)\r\n\t\t\t\t\t\t\t\t\tif (worse) {\r\n\t\t\t\t\t\t\t\t\t\tworse.get(\"label\")?.setPrivate(\"visible\", false);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// todo y?\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// MINOR GRID\r\n\t\t\t\t\tif (minorGridInterval) {\r\n\t\t\t\t\t\tthis._addMinorGrid(value, endValue, minorDuration, minorGridInterval);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ti++;\r\n\r\n\t\t\t\t\tif (label && label.getPrivate(\"visible\")) {\r\n\t\t\t\t\t\tpreviousDataItem = dataItem;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpreviousValue = value;\r\n\t\t\t\t})\r\n\t\t\t}\r\n\r\n\t\t\t$array.each(this.series, (series) => {\r\n\t\t\t\tif (series.inited) {\r\n\t\t\t\t\tseries._markDirtyAxes();\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis._updateGhost();\r\n\t}\r\n\r\n\tprotected _pickWorse(dataItemA: DataItem<IGaplessDateAxisDataItem>, dataItemB: DataItem<IGaplessDateAxisDataItem>, interval: ITimeInterval): DataItem<IGaplessDateAxisDataItem> {\r\n\t\tconst timeUnit = interval.timeUnit;\r\n\r\n\t\tconst valueA = dataItemA.get(\"value\", 0);\r\n\t\tconst valueB = dataItemB.get(\"value\", 0);\r\n\r\n\t\tif (timeUnit == \"hour\") {\r\n\t\t\tif (new Date(valueA).getDate() != new Date(valueB).getDate()) {\r\n\t\t\t\treturn dataItemA;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn dataItemB;\r\n\t}\r\n\r\n\tprotected _addMinorGrid(startValue: number, endValue: number, minorDuration: number, gridInterval: ITimeInterval) {\r\n\t\tconst minorFormats = this.get(\"minorDateFormats\", this.get(\"dateFormats\"))!;\r\n\t\tconst mTimeUnit = gridInterval.timeUnit;\r\n\t\tlet value = startValue + $time.getDuration(mTimeUnit, this._getM(mTimeUnit));\r\n\t\t//value = $time.round(new Date(value), mTimeUnit, 1, firstDay, utc, undefined, timezone).getTime();\r\n\t\tvalue = $time.roun(value, mTimeUnit, 1, this._root);\r\n\r\n\t\tlet maxValue = endValue - minorDuration * 0.5;\r\n\r\n\t\tlet minorSelectedItems: Array<number> = this._getIndexes(value, maxValue, gridInterval, value);\r\n\t\tconst dates = this._getDates();\r\n\r\n\t\t$array.each(minorSelectedItems, (index) => {\r\n\t\t\tlet minorDataItem: DataItem<this[\"_dataItemSettings\"]>;\r\n\t\t\tif (this.minorDataItems.length < this._m + 1) {\r\n\t\t\t\tminorDataItem = new DataItem<this[\"_dataItemSettings\"]>(this, undefined, {});\r\n\t\t\t\tthis.minorDataItems.push(minorDataItem);\r\n\t\t\t\tthis.processDataItem(minorDataItem);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tminorDataItem = this.minorDataItems[this._m];\r\n\t\t\t}\r\n\r\n\t\t\tvalue = dates[index];\r\n\t\t\tminorDataItem.setRaw(\"value\", value);\r\n\t\t\tminorDataItem.setRaw(\"endValue\", value + minorDuration);\r\n\t\t\tminorDataItem.setRaw(\"index\", index);\r\n\r\n\t\t\tthis._createAssets(minorDataItem, [\"minor\"], true);\r\n\r\n\t\t\tconst label = minorDataItem.get(\"label\");\r\n\t\t\tif (label) {\r\n\t\t\t\tif (this.get(\"renderer\").get(\"minorLabelsEnabled\")) {\r\n\t\t\t\t\tlet date = new Date(value);\r\n\t\t\t\t\tlet format = minorFormats[mTimeUnit];\r\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlabel.setPrivate(\"visible\", false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis._toggleDataItem(minorDataItem, true);\r\n\t\t\tthis._prepareDataItem(minorDataItem, 1);\r\n\t\t\tthis._m++;\r\n\t\t})\r\n\t}\r\n\r\n\r\n\tprotected _getIndexes(value: number, maxValue: number, interval: ITimeInterval, firstValue: number): Array<number> {\r\n\t\tconst items: Array<number> = [];\r\n\t\tconst timeUnit = interval.timeUnit;\r\n\t\tconst count = interval.count;\r\n\t\tconst mmm = this._getM(timeUnit);\r\n\r\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\r\n\r\n\t\tconst root = this._root;\r\n\t\tconst dates = this._getDates();\r\n\r\n\t\tlet c = count - 1;\r\n\t\tlet previousValue = -Infinity;\r\n\r\n\t\tlet duration = $time.getDuration(timeUnit, mmm);\r\n\t\tlet fullDuration = $time.getDuration(timeUnit, count * mmm);\r\n\t\tlet originalValue = value;\r\n\r\n\t\tif (timeUnit == \"day\") {\r\n\t\t\tvalue = firstValue;\r\n\t\t}\r\n\r\n\t\twhile (value <= maxValue) {\r\n\t\t\t//value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\r\n\t\t\tvalue = $time.roun(value, timeUnit, count, root);\r\n\r\n\t\t\tlet index = this.valueToIndex(value);\r\n\t\t\tlet realValue = dates[index];\r\n\r\n\t\t\tif (timeUnit == \"day\" && baseInterval.timeUnit == \"day\") {\r\n\t\t\t\tif (this._hasDate(value)) {\r\n\t\t\t\t\tc++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c == count) {\r\n\t\t\t\t\tif (value >= originalValue - fullDuration * 2) {\r\n\t\t\t\t\t\t$array.move(items, index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc = 0;\r\n\t\t\t\t}\r\n\t\t\t\tvalue += duration;\r\n\t\t\t\t//value = $time.round(new Date(value), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\r\n\t\t\t\tvalue = $time.roun(value, timeUnit, 1, root);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (realValue < value) {\r\n\t\t\t\t\tfor (let i = index, len = dates.length; i < len; i++) {\r\n\t\t\t\t\t\trealValue = dates[i];\r\n\t\t\t\t\t\tif (realValue >= value) {\r\n\t\t\t\t\t\t\tindex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t$array.move(items, index);\r\n\r\n\t\t\t\tvalue += fullDuration;\r\n\t\t\t\t//value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\r\n\t\t\t\tvalue = $time.roun(value, timeUnit, count, root);\r\n\t\t\t}\r\n\r\n\t\t\tif (value == previousValue) {\r\n\t\t\t\tvalue += fullDuration + duration;\r\n\t\t\t\t//value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\r\n\t\t\t\tvalue = $time.roun(value, timeUnit, count, root);\r\n\t\t\t}\r\n\t\t\tif (value == previousValue) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tpreviousValue = value;\r\n\t\t}\r\n\r\n\t\treturn items;\r\n\t}\r\n\r\n\tprotected _hasDate(time: number) {\r\n\t\tconst result = $array.getSortedIndex(this._getDates(), (date) => {\r\n\t\t\treturn $order.compareNumber(date, time);\r\n\t\t});\r\n\r\n\t\treturn result.found;\r\n\t}\r\n\tprotected _nextTime(time: number, count: number, _baseInterval: ITimeInterval) {\r\n\t\tlet index = $math.fitToRange(this.valueToIndex(time) + count, 0, this._dates.length - 1);\r\n\t\treturn this._dates[index];\r\n\t}\r\n}"],"mappings":"AAEA,SAASA,QAAQ,QAAiF,YAAY;AAC9G,SAASC,QAAQ,QAAQ,gCAAgC;AAGzD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAChD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAChD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAuBhD;;;;;;;AAOA,OAAM,MAAOC,eAAwC,SAAQP,QAAW;EAAxEQ,YAAA;;IASCC,MAAA,CAAAC,cAAA;;;;aAA+B;;IAC/BD,MAAA,CAAAC,cAAA;;;;aAAuB;;IAOvBD,MAAA,CAAAC,cAAA;;;;aAA+B;;IAC/BD,MAAA,CAAAC,cAAA;;;;;;EAqlBD;EA3lBQC,SAASA,CAAA;IACf,IAAI,CAACC,WAAW,CAACC,IAAI,CAAC,MAAM,CAAC;IAC7B,KAAK,CAACF,SAAS,EAAE;EAClB;EAMOG,SAASA,CAAA;IACf,IAAI,IAAI,CAACC,YAAY,EAAE;MACtB,OAAO,IAAI,CAACA,YAAY;;IAEzB,OAAO,IAAI,CAACC,MAAM;EACnB;EAEUC,YAAYA,CAACC,IAAY,EAAEC,MAAgB;IACpD,IAAI,CAACA,MAAM,CAACC,GAAG,CAAC,cAAc,CAAC,EAAE;MAChC,MAAMC,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;MAC9B,MAAMQ,MAAM,GAAGpB,MAAM,CAACqB,cAAc,CAACF,KAAK,EAAGG,CAAC,IAAKrB,MAAM,CAACsB,OAAO,CAACD,CAAC,EAAEN,IAAI,CAAC,CAAC;MAC3E,IAAI,CAACI,MAAM,CAACI,KAAK,EAAE;QAClBxB,MAAM,CAACyB,WAAW,CAACN,KAAK,EAAEC,MAAM,CAACM,KAAK,EAAEV,IAAI,CAAC;;;EAGhD;EAEOW,eAAeA,CAAA;IACrB,IAAI,CAAC,IAAI,CAACd,YAAY,EAAE;MACvB,MAAMM,KAAK,GAAG,IAAI,CAACL,MAAM;MACzBK,KAAK,CAACS,MAAM,GAAG,CAAC;MAEhB5B,MAAM,CAAC6B,IAAI,CAAC,IAAI,CAACZ,MAAM,EAAGA,MAAM,IAAI;QACnC,IAAIa,KAAK,GAAG,QAAQ;QACpB,IAAIb,MAAM,CAACC,GAAG,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE;UAChCY,KAAK,GAAG,QAAQ;;QAEjB9B,MAAM,CAAC6B,IAAI,CAACZ,MAAM,CAACc,SAAS,EAAGC,QAAQ,IAAI;UAC1C,IAAIC,KAAK,GAAGD,QAAQ,CAACd,GAAG,CAACY,KAAY,CAAC;UACtC,IAAI3B,KAAK,CAAC+B,QAAQ,CAACD,KAAK,CAAC,EAAE;YAC1B,IAAID,QAAQ,CAACG,IAAI,EAAE;cAClB,IAAI,CAACpB,YAAY,CAACiB,QAAQ,CAACG,IAAK,CAACL,KAAK,CAAC,EAAEb,MAAM,CAAC;;;QAGnD,CAAC,CAAC;MACH,CAAC,CAAC;MAEF,MAAMmB,QAAQ,GAAG,IAAI,CAAClB,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC;MACxC,MAAMmB,QAAQ,GAAG,IAAI,CAACnB,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC;MAExC,IAAIoB,GAAG,GAAGnB,KAAK,CAACS,MAAM;MAEtB,MAAMW,YAAY,GAAG,IAAI,CAACC,UAAU,CAAC,cAAc,CAAC;MACpD,MAAMC,SAAS,GAAGF,YAAY,CAACG,KAAK;MACpC,MAAMC,QAAQ,GAAGJ,YAAY,CAACI,QAAQ;MAEtC,IAAIP,QAAQ,GAAG,CAAC,EAAE;QACjB,MAAMQ,KAAK,GAAGN,GAAG,GAAGF,QAAQ;QAC5B,IAAIS,IAAI,GAAG1B,KAAK,CAACmB,GAAG,GAAG,CAAC,CAAC;QACzB,IAAInC,KAAK,CAAC+B,QAAQ,CAACW,IAAI,CAAC,EAAE;UACzB,KAAK,IAAIC,CAAC,GAAGR,GAAG,GAAG,CAAC,EAAEQ,CAAC,GAAGR,GAAG,GAAGM,KAAK,EAAEE,CAAC,EAAE,EAAE;YAC3CD,IAAI,IAAI3C,KAAK,CAAC6C,WAAW,CAACJ,QAAQ,EAAEF,SAAS,GAAG,IAAI,CAACO,KAAK,CAACL,QAAQ,CAAC,CAAC;YACrE;YACAE,IAAI,GAAG3C,KAAK,CAAC+C,IAAI,CAACJ,IAAI,EAAEF,QAAQ,EAAEF,SAAS,EAAE,IAAI,CAACS,KAAK,CAAC;YACxD/B,KAAK,CAACR,IAAI,CAACkC,IAAI,CAAC;;;;MAKnB,IAAIR,QAAQ,GAAG,CAAC,EAAE;QACjB,MAAMO,KAAK,GAAGN,GAAG,GAAGD,QAAQ;QAC5B,IAAIQ,IAAI,GAAG1B,KAAK,CAAC,CAAC,CAAC;QACnB,IAAIhB,KAAK,CAAC+B,QAAQ,CAACW,IAAI,CAAC,EAAE;UACzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;YAC/BD,IAAI,IAAI3C,KAAK,CAAC6C,WAAW,CAACJ,QAAQ,EAAEF,SAAS,CAAC;YAC9C;YACAI,IAAI,GAAG3C,KAAK,CAAC+C,IAAI,CAACJ,IAAI,EAAEF,QAAQ,EAAEF,SAAS,EAAE,IAAI,CAACS,KAAK,CAAC;YACxD/B,KAAK,CAACgC,OAAO,CAACN,IAAI,CAAC;;;;;EAKxB;EAEA;;;;;;EAMOO,eAAeA,CAACnB,KAAa;IACnC,MAAMd,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;IAC9B,MAAMyC,aAAa,GAAG,IAAI,CAACnC,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;IAClD,MAAMoC,WAAW,GAAG,IAAI,CAACpC,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC;IAC9C,MAAMoB,GAAG,GAAGnB,KAAK,CAACS,MAAM,GAAGyB,aAAa,IAAI,CAAC,GAAGC,WAAW,CAAC;IAC5D,MAAMlC,MAAM,GAAGpB,MAAM,CAACqB,cAAc,CAACF,KAAK,EAAGG,CAAC,IAAKrB,MAAM,CAACsB,OAAO,CAACD,CAAC,EAAEW,KAAK,CAAC,CAAC;IAC5E,IAAIP,KAAK,GAAGN,MAAM,CAACM,KAAK;IAExB,IAAIN,MAAM,CAACI,KAAK,EAAE;MACjB,OAAO,CAACE,KAAK,GAAG2B,aAAa,IAAIf,GAAG;KACpC,MACI;MACJ,IAAIZ,KAAK,GAAG,CAAC,EAAE;QACdA,KAAK,IAAI,CAAC;;MAGX,IAAI6B,SAAS,GAAGpC,KAAK,CAACO,KAAK,CAAC;MAC5B,MAAM8B,QAAQ,GAAGrC,KAAK,CAACO,KAAK,GAAG,CAAC,CAAC;MACjC,IAAG8B,QAAQ,EAAC;QACX,IAAIC,aAAa,GAAGD,QAAQ;QAC5B;QACA,IAAIE,IAAI,CAACC,GAAG,CAACF,aAAa,GAAGxB,KAAK,CAAC,GAAGyB,IAAI,CAACC,GAAG,CAACJ,SAAS,GAAGtB,KAAK,CAAC,EAAE;UAClEsB,SAAS,GAAGE,aAAa;UACzB/B,KAAK,EAAE;;;MAIT;;;;;;;;;MAUA,IAAIkC,CAAC,GAAG3B,KAAK,GAAGsB,SAAS;MAEzB,OAAO,CAAC7B,KAAK,GAAG2B,aAAa,IAAIf,GAAG,GAAGsB,CAAC,GAAG,IAAI,CAACC,YAAY,EAAE,GAAGvB,GAAG;;EAEtE;EAEA;;;;;;EAMOwB,YAAYA,CAAC7B,KAAa;IAChC,MAAMd,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;IAE9B,MAAMQ,MAAM,GAAGpB,MAAM,CAACqB,cAAc,CAACF,KAAK,EAAGG,CAAC,IAAKrB,MAAM,CAACsB,OAAO,CAACD,CAAC,EAAEW,KAAK,CAAC,CAAC;IAC5E,IAAIP,KAAK,GAAGN,MAAM,CAACM,KAAK;IAExB,IAAIN,MAAM,CAACI,KAAK,EAAE;MACjB,OAAOE,KAAK;KACZ,MACI;MACJ,IAAIA,KAAK,GAAG,CAAC,EAAE;QACdA,KAAK,IAAI,CAAC;;MAEX,OAAOA,KAAK;;EAEd;EAEA;;;;;;;EAOOqC,eAAeA,CAACC,QAAgB;IACtC,MAAMX,aAAa,GAAG,IAAI,CAACnC,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;IAClD,MAAMoC,WAAW,GAAG,IAAI,CAACpC,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC;IAC9C,MAAMC,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;IAC9B,IAAI0B,GAAG,GAAGoB,IAAI,CAACO,KAAK,CAAC9C,KAAK,CAACS,MAAM,GAAGyB,aAAa,IAAI,CAAC,GAAGC,WAAW,CAAC,CAAC;IACtE,IAAI5B,KAAK,GAAGsC,QAAQ,GAAG1B,GAAG;IAC1B,IAAI4B,MAAM,GAAGR,IAAI,CAACS,KAAK,CAACzC,KAAK,CAAC;IAC9B,IAAIwC,MAAM,GAAG,CAAC,EAAE;MACfA,MAAM,GAAG,CAAC;;IAGX,IAAIA,MAAM,GAAG5B,GAAG,GAAG,CAAC,EAAE;MACrB4B,MAAM,GAAG5B,GAAG,GAAG,CAAC;;IAGjB,OAAOnB,KAAK,CAAC+C,MAAM,CAAC,GAAG,CAACxC,KAAK,GAAGwC,MAAM,GAAGb,aAAa,IAAI,IAAI,CAACQ,YAAY,EAAE;EAC9E;EAEUO,cAAcA,CAAA;IACvB,IAAI,CAACC,aAAa,CAAC,eAAe,EAAE,IAAI,CAACzD,SAAS,EAAE,CAACgB,MAAM,GAAG,IAAI,CAACV,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAACA,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC,CAAC;EAC/H;EAEA;;;;;;;;;EAUOoD,WAAWA,CAACC,KAAW,EAAEC,GAAS,EAAEC,QAAiB;IAC3D,MAAMtD,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;IAC9B,MAAM0B,GAAG,GAAGnB,KAAK,CAACS,MAAM;IACxB,IAAIR,MAAM,GAAGpB,MAAM,CAACqB,cAAc,CAACF,KAAK,EAAGG,CAAC,IAAKrB,MAAM,CAACsB,OAAO,CAACD,CAAC,EAAEiD,KAAK,CAACG,OAAO,EAAE,CAAC,CAAC;IAEpF,IAAIC,UAAU,GAAGxD,KAAK,CAACuC,IAAI,CAACkB,GAAG,CAACxD,MAAM,CAACM,KAAK,EAAEY,GAAG,GAAG,CAAC,CAAC,CAAC;IAEvDlB,MAAM,GAAGpB,MAAM,CAACqB,cAAc,CAACF,KAAK,EAAGG,CAAC,IAAKrB,MAAM,CAACsB,OAAO,CAACD,CAAC,EAAEkD,GAAG,CAACE,OAAO,EAAE,CAAC,CAAC;IAC9E,IAAIG,QAAQ,GAAG1D,KAAK,CAACC,MAAM,CAACM,KAAK,CAAC;IAElC,IAAIN,MAAM,CAACM,KAAK,IAAIY,GAAG,EAAE;MACxBuC,QAAQ,GAAG1D,KAAK,CAACmB,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAACuB,YAAY,EAAE;;IAGhD,IAAI,CAACiB,YAAY,CAACH,UAAU,EAAEE,QAAQ,EAAEJ,QAAQ,CAAC;EAClD;EAEA;;;;;;;;;EASOK,YAAYA,CAACP,KAAa,EAAEC,GAAW,EAAEC,QAAiB;IAChE,MAAMG,GAAG,GAAG,IAAI,CAACpC,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;IACrC,MAAMuC,GAAG,GAAG,IAAI,CAACvC,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;IACrC+B,KAAK,GAAGnE,KAAK,CAAC4E,UAAU,CAACT,KAAK,EAAEK,GAAG,EAAEG,GAAG,CAAC;IACzCP,GAAG,GAAGpE,KAAK,CAAC4E,UAAU,CAACR,GAAG,EAAEI,GAAG,EAAEG,GAAG,CAAC;IACrC,IAAI,CAACE,IAAI,CAAC,IAAI,CAAC7B,eAAe,CAACmB,KAAK,CAAC,EAAE,IAAI,CAACnB,eAAe,CAACoB,GAAG,CAAC,EAAEC,QAAQ,CAAC;EAC5E;EAGUS,iBAAiBA,CAAA;IAC1B,IAAIC,SAAS,GAAG,IAAI,CAAC3C,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;IAClD,IAAI4C,OAAO,GAAG,IAAI,CAAC5C,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;IAEhD,IAAIrC,KAAK,CAAC+B,QAAQ,CAACiD,SAAS,CAAC,IAAIhF,KAAK,CAAC+B,QAAQ,CAACkD,OAAO,CAAC,EAAE;MAEzD,IAAI,IAAI,CAACC,kBAAkB,EAAE;QAC5B,IAAI,CAACA,kBAAkB,GAAG,KAAK;QAC/B,IAAI,CAAC1D,eAAe,EAAE;;MAGvB,MAAM2D,IAAI,GAAG,IAAI,CAACpC,KAAK;MACvB,MAAMqC,GAAG,GAAGD,IAAI,CAACC,GAAG;MACpB,MAAMC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;MAC9B,MAAMrE,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;MAC9B,MAAM6E,QAAQ,GAAG,IAAI,CAACvE,GAAG,CAAC,UAAU,CAAC;MACrC,MAAMoB,GAAG,GAAGnB,KAAK,CAACS,MAAM;MACxB,MAAMiC,YAAY,GAAG,IAAI,CAACA,YAAY,EAAE;MAExC,IAAI6B,UAAU,GAAG,IAAI,CAAC5B,YAAY,CAACqB,SAAS,CAAC;MAC7C,IAAIO,UAAU,GAAG,CAAC,EAAE;QACnBA,UAAU,EAAE;;MAGb,IAAIC,QAAQ,GAAG,IAAI,CAAC7B,YAAY,CAACsB,OAAO,CAAC;MACzC,IAAIO,QAAQ,GAAGrD,GAAG,GAAG,CAAC,EAAE;QACvBqD,QAAQ,EAAE;;MAEX,IAAIC,QAAQ,GAAGH,QAAQ,CAACI,UAAU,EAAE,GAAGnC,IAAI,CAACqB,GAAG,CAACU,QAAQ,CAACvE,GAAG,CAAC,iBAAiB,CAAE,EAAE,CAAC,GAAG4E,MAAM,CAACC,gBAAgB,CAAC;MAC9G,IAAIC,SAAS,GAAGtC,IAAI,CAACkB,GAAG,CAACtC,GAAG,EAAEoB,IAAI,CAACuC,IAAI,CAAC,CAACN,QAAQ,GAAGD,UAAU,IAAIE,QAAQ,CAAC,CAAC;MAC5EI,SAAS,GAAGtC,IAAI,CAACqB,GAAG,CAAC,CAAC,EAAEiB,SAAS,CAAC;MAElCN,UAAU,GAAGhC,IAAI,CAACS,KAAK,CAACuB,UAAU,GAAGM,SAAS,CAAC,GAAGA,SAAS;MAE3D,IAAI,CAACE,UAAU,GAAGF,SAAS;MAE3BhG,MAAM,CAAC6B,IAAI,CAAC,IAAI,CAACE,SAAS,EAAGC,QAAQ,IAAI;QACxC,IAAI,CAACmE,eAAe,CAACnE,QAAQ,EAAE,KAAK,CAAC;MACtC,CAAC,CAAC;MAEFhC,MAAM,CAAC6B,IAAI,CAAC,IAAI,CAACuE,cAAc,EAAGpE,QAAQ,IAAI;QAC7C,IAAI,CAACmE,eAAe,CAACnE,QAAQ,EAAE,KAAK,CAAC;MACtC,CAAC,CAAC;MAEF,IAAIqE,YAAY,GAAIjB,OAAO,GAAGD,SAAS,GAAI,CAAC,CAACC,OAAO,GAAGD,SAAS,IAAItB,YAAY,IAAI8B,QAAQ,GAAGD,UAAU,CAAC,IAAI7B,YAAY;MAE1H;MACA,IAAIyC,YAAY,GAAGpG,KAAK,CAACqG,cAAc,CAAC,CAAC,EAAEF,YAAY,EAAET,QAAQ,EAAE,IAAI,CAAC1E,GAAG,CAAC,eAAe,CAAE,CAAC;MAE9F,MAAMqB,YAAY,GAAG,IAAI,CAACC,UAAU,CAAC,cAAc,CAAC;MACpD,IAAIgE,gBAAgB,GAAGtG,KAAK,CAACuG,mBAAmB,CAACH,YAAY,CAAC;MAE9D,IAAIE,gBAAgB,GAAG3C,YAAY,EAAE;QACpCyC,YAAY,GAAA/F,MAAA,CAAAmG,MAAA,KAAQnE,YAAY,CAAE;QAClCiE,gBAAgB,GAAGtG,KAAK,CAACuG,mBAAmB,CAACH,YAAY,CAAC;;MAG3D,IAAI,CAACK,iBAAiB,GAAGH,gBAAgB;MAEzC,MAAM7D,QAAQ,GAAG2D,YAAY,CAAC3D,QAAQ;MACtC,MAAMiE,OAAO,GAAG,IAAI,CAAC1F,GAAG,CAAC,aAAa,CAAE;MAExC,IAAI2F,SAAS,GAAGC,IAAI,CAACC,GAAG,EAAE;MAE1B,IAAI5F,KAAK,CAAC,CAAC,CAAC,EAAE;QACb0F,SAAS,GAAG1F,KAAK,CAAC,CAAC,CAAC;;MAGrB;MACA,IAAIc,KAAK,GAAG/B,KAAK,CAAC+C,IAAI,CAAC,IAAI,CAACT,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC,EAAEG,QAAQ,EAAE2D,YAAY,CAAC5D,KAAK,EAAE4C,IAAI,EAAEuB,SAAS,CAAC;MAEzG,MAAMG,kBAAkB,GAAGvB,QAAQ,CAACvE,GAAG,CAAC,oBAAoB,CAAC;MAC7D,MAAM+F,gBAAgB,GAAGxB,QAAQ,CAACvE,GAAG,CAAC,kBAAkB,EAAE8F,kBAAkB,CAAC;MAE7E,IAAIE,iBAA4C;MAChD,IAAIC,aAAa,GAAG,CAAC;MACrB,IAAIC,gBAAgE;MAEpE,IAAIH,gBAAgB,EAAE;QACrBC,iBAAiB,GAAG,IAAI,CAACG,iBAAiB,CAACf,YAAY,CAAC;QACxDa,aAAa,GAAGjH,KAAK,CAACuG,mBAAmB,CAACS,iBAAiB,CAAC;;MAI7D,IAAII,aAAa,GAAkB,IAAI,CAACC,WAAW,CAACtF,KAAK,EAAE,IAAI,CAACO,UAAU,CAAC,cAAc,EAAEP,KAAK,CAAC,GAAGuE,gBAAgB,EAAEF,YAAY,EAAE,IAAI,CAAC9D,UAAU,CAAC,KAAK,EAAEP,KAAK,CAAC,CAAC;MAClK,IAAIqF,aAAa,CAAC1F,MAAM,GAAG,CAAC,EAAE;QAC7B,IAAIkB,CAAC,GAAG,CAAC;QACT,IAAI,CAAC0E,EAAE,GAAG,CAAC;QACX,IAAIC,aAAa,GAAGxF,KAAK,GAAGuE,gBAAgB,GAAG,EAAE;QACjD,MAAMkB,YAAY,GAAGxH,KAAK,CAACyH,WAAW,CAAChF,QAAQ,CAAC;QAEhD;QACA,IAAIuE,iBAAiB,EAAE;UACtB,IAAIU,KAAK,GAAGzG,KAAK,CAACmG,aAAa,CAAC,CAAC,CAAC,CAAC;UACnC,IAAI,CAACO,aAAa,CAACD,KAAK,GAAGpB,gBAAgB,EAAEoB,KAAK,EAAET,aAAa,EAAED,iBAAiB,CAAC;;QAGtF,IAAIY,WAAW,GAAGrC,QAAQ,CAACI,UAAU,EAAE,GAAGJ,QAAQ,CAACsC,SAAS,EAAE,GAAG,GAAG;QAEpE/H,MAAM,CAAC6B,IAAI,CAACyF,aAAa,EAAG5F,KAAK,IAAI;;UACpC,IAAIM,QAA6C;UACjD,IAAI,IAAI,CAACD,SAAS,CAACH,MAAM,GAAGkB,CAAC,GAAG,CAAC,EAAE;YAClCd,QAAQ,GAAG,IAAIjC,QAAQ,CAA4B,IAAI,EAAEiI,SAAS,EAAE,EAAE,CAAC;YACvE,IAAI,CAACC,UAAU,CAACtH,IAAI,CAACqB,QAAQ,CAAC;YAC9B,IAAI,CAACkG,eAAe,CAAClG,QAAQ,CAAC;WAC9B,MACI;YACJA,QAAQ,GAAG,IAAI,CAACD,SAAS,CAACe,CAAC,CAAC;;UAG7B,IAAIb,KAAK,GAAGd,KAAK,CAACO,KAAK,CAAC;UACxB,IAAIV,IAAI,GAAG,IAAI8F,IAAI,CAAC7E,KAAK,CAAC;UAE1B,IAAI4C,QAAQ,GAAG5C,KAAK;UACpB,IAAIa,CAAC,GAAGwE,aAAa,CAAC1F,MAAM,GAAG,CAAC,EAAE;YACjCiD,QAAQ,GAAG1D,KAAK,CAACmG,aAAa,CAACxE,CAAC,GAAG,CAAC,CAAC,CAAC;WACtC,MACI;YACJ+B,QAAQ,IAAI2B,gBAAgB;;UAE7BxE,QAAQ,CAACmG,MAAM,CAAC,OAAO,EAAElG,KAAK,CAAC;UAC/BD,QAAQ,CAACmG,MAAM,CAAC,UAAU,EAAEtD,QAAQ,CAAC;UACrC7C,QAAQ,CAACmG,MAAM,CAAC,OAAO,EAAErF,CAAC,CAAC;UAC3Bd,QAAQ,CAACmG,MAAM,CAAC,eAAe,EAAEH,SAAS,CAAC;UAE3C,IAAII,MAAM,GAAGxB,OAAO,CAACjE,QAAQ,CAAC;UAC9B,IAAI+E,YAAY,IAAI,IAAI,CAACxG,GAAG,CAAC,gBAAgB,CAAC,IAAIf,KAAK,CAAC+B,QAAQ,CAACuF,aAAa,CAAC,EAAE;YAChF,IAAI9E,QAAQ,IAAI,MAAM,EAAE;cACvB,IAAIzC,KAAK,CAACmI,WAAW,CAACpG,KAAK,EAAEwF,aAAa,EAAEC,YAAY,EAAEnC,GAAG,EAAEC,QAAQ,CAAC,EAAE;gBACzE4C,MAAM,GAAG,IAAI,CAAClH,GAAG,CAAC,yBAAyB,CAAE,CAACyB,QAAQ,CAAC;;;;UAK1D,IAAI,CAAC2F,aAAa,CAACtG,QAAQ,EAAE,EAAE,CAAC;UAEhC,MAAMuG,KAAK,GAAGvG,QAAQ,CAACd,GAAG,CAAC,OAAO,CAAC;UACnC,IAAIqH,KAAK,EAAE;YACVA,KAAK,CAACC,GAAG,CAAC,MAAM,EAAElD,IAAI,CAACmD,aAAa,CAACL,MAAM,CAACpH,IAAI,EAAEoH,MAAO,CAAC,CAAC;;UAG5D,IAAI,CAACjC,eAAe,CAACnE,QAAQ,EAAE,IAAI,CAAC;UAEpC,IAAIU,KAAK,GAAG4D,YAAY,CAAC5D,KAAK;UAE9B;UACA,IAAIC,QAAQ,IAAI,MAAM,EAAE;YACvBX,QAAQ,CAACmG,MAAM,CAAC,eAAe,EAAElG,KAAK,CAAC;;UAGxC,IAAIgF,gBAAgB,EAAE;YACrB,IAAIyB,SAAS,GAAGpC,YAAY,CAAC3D,QAAQ;YACrC,IAAI+F,SAAS,IAAI,MAAM,EAAE;cACxBA,SAAS,GAAG,KAAK;;YAGlB,IAAIhG,KAAK,GAAG,CAAC,IAAI4D,YAAY,CAAC3D,QAAQ,IAAI,MAAM,EAAE;cACjD;cACA,IAAIgG,aAAa,GAAGzI,KAAK,CAAC+C,IAAI,CAAChB,KAAK,EAAEyG,SAAS,EAAE,CAAC,EAAEpD,IAAI,CAAC,GAAGpF,KAAK,CAAC6C,WAAW,CAAC2F,SAAS,EAAE,IAAI,CAAC1F,KAAK,CAAC0F,SAAS,CAAC,CAAC;cAC/G,IAAIhH,KAAK,GAAG,IAAI,CAACoC,YAAY,CAAC6E,aAAa,CAAC;cAC5CA,aAAa,GAAGxH,KAAK,CAACO,KAAK,CAAC;cAC5B,IAAIiH,aAAa,IAAI1G,KAAK,EAAE;gBAC3B,IAAI2G,IAAI,GAAGzH,KAAK,CAACO,KAAK,GAAG,CAAC,CAAC;gBAC3B,IAAIkH,IAAI,EAAE;kBACTD,aAAa,GAAGC,IAAI;iBACpB,MACI;kBACJD,aAAa,IAAIxB,aAAa;;;cAIhCnF,QAAQ,CAACmG,MAAM,CAAC,eAAe,EAAEQ,aAAa,CAAC;;YAEhDjG,KAAK,GAAG,CAAC;;UAGV,IAAI,CAACmG,gBAAgB,CAAC7G,QAAQ,EAAEU,KAAK,CAAC;UAEtC,IAAI6F,KAAK,IAAInB,gBAAgB,EAAE;YAC9B,IAAI3B,QAAQ,CAACjD,UAAU,CAAC,QAAQ,CAAC,IAAI,GAAG,EAAE;cACzC,IAAIsG,aAAa,GAAG1B,gBAAgB,CAAClG,GAAG,CAAC,OAAO,CAAC;cACjD,IAAI4H,aAAa,EAAE;gBAClB,IAAIxH,CAAC,GAAGiH,KAAK,CAACjH,CAAC,EAAE;gBACjB,IAAIyH,SAAS,GAAGD,aAAa,CAACxH,CAAC,EAAE;gBAEjC,IAAIA,CAAC,GAAGyH,SAAS,GAAGjB,WAAW,EAAE;kBAChC,IAAIkB,KAAK,GAAG,IAAI,CAACC,UAAU,CAAC7B,gBAAgB,EAAEpF,QAAQ,EAAEsE,YAAY,CAAC;kBACrE,IAAI0C,KAAK,EAAE;oBACV,CAAAE,EAAA,GAAAF,KAAK,CAAC9H,GAAG,CAAC,OAAO,CAAC,cAAAgI,EAAA,uBAAAA,EAAA,CAAEC,UAAU,CAAC,SAAS,EAAE,KAAK,CAAC;;;;;YAMpD;;UAID;UACA,IAAIjC,iBAAiB,EAAE;YACtB,IAAI,CAACW,aAAa,CAAC5F,KAAK,EAAE4C,QAAQ,EAAEsC,aAAa,EAAED,iBAAiB,CAAC;;UAGtEpE,CAAC,EAAE;UAEH,IAAIyF,KAAK,IAAIA,KAAK,CAAC/F,UAAU,CAAC,SAAS,CAAC,EAAE;YACzC4E,gBAAgB,GAAGpF,QAAQ;;UAE5ByF,aAAa,GAAGxF,KAAK;QACtB,CAAC,CAAC;;MAGHjC,MAAM,CAAC6B,IAAI,CAAC,IAAI,CAACZ,MAAM,EAAGA,MAAM,IAAI;QACnC,IAAIA,MAAM,CAACmI,MAAM,EAAE;UAClBnI,MAAM,CAACoI,cAAc,EAAE;;MAEzB,CAAC,CAAC;;IAGH,IAAI,CAACC,YAAY,EAAE;EACpB;EAEUL,UAAUA,CAACM,SAA6C,EAAEC,SAA6C,EAAEC,QAAuB;IACzI,MAAM9G,QAAQ,GAAG8G,QAAQ,CAAC9G,QAAQ;IAElC,MAAM+G,MAAM,GAAGH,SAAS,CAACrI,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;IACxC,MAAMyI,MAAM,GAAGH,SAAS,CAACtI,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;IAExC,IAAIyB,QAAQ,IAAI,MAAM,EAAE;MACvB,IAAI,IAAImE,IAAI,CAAC4C,MAAM,CAAC,CAACE,OAAO,EAAE,IAAI,IAAI9C,IAAI,CAAC6C,MAAM,CAAC,CAACC,OAAO,EAAE,EAAE;QAC7D,OAAOL,SAAS;;;IAIlB,OAAOC,SAAS;EACjB;EAEU3B,aAAaA,CAAClD,UAAkB,EAAEE,QAAgB,EAAEsC,aAAqB,EAAEb,YAA2B;IAC/G,MAAMuD,YAAY,GAAG,IAAI,CAAC3I,GAAG,CAAC,kBAAkB,EAAE,IAAI,CAACA,GAAG,CAAC,aAAa,CAAC,CAAE;IAC3E,MAAM4I,SAAS,GAAGxD,YAAY,CAAC3D,QAAQ;IACvC,IAAIV,KAAK,GAAG0C,UAAU,GAAGzE,KAAK,CAAC6C,WAAW,CAAC+G,SAAS,EAAE,IAAI,CAAC9G,KAAK,CAAC8G,SAAS,CAAC,CAAC;IAC5E;IACA7H,KAAK,GAAG/B,KAAK,CAAC+C,IAAI,CAAChB,KAAK,EAAE6H,SAAS,EAAE,CAAC,EAAE,IAAI,CAAC5G,KAAK,CAAC;IAEnD,IAAI6G,QAAQ,GAAGlF,QAAQ,GAAGsC,aAAa,GAAG,GAAG;IAE7C,IAAI6C,kBAAkB,GAAkB,IAAI,CAACzC,WAAW,CAACtF,KAAK,EAAE8H,QAAQ,EAAEzD,YAAY,EAAErE,KAAK,CAAC;IAC9F,MAAMd,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;IAE9BZ,MAAM,CAAC6B,IAAI,CAACmI,kBAAkB,EAAGtI,KAAK,IAAI;MACzC,IAAIuI,aAAkD;MACtD,IAAI,IAAI,CAAC7D,cAAc,CAACxE,MAAM,GAAG,IAAI,CAAC4F,EAAE,GAAG,CAAC,EAAE;QAC7CyC,aAAa,GAAG,IAAIlK,QAAQ,CAA4B,IAAI,EAAEiI,SAAS,EAAE,EAAE,CAAC;QAC5E,IAAI,CAAC5B,cAAc,CAACzF,IAAI,CAACsJ,aAAa,CAAC;QACvC,IAAI,CAAC/B,eAAe,CAAC+B,aAAa,CAAC;OACnC,MACI;QACJA,aAAa,GAAG,IAAI,CAAC7D,cAAc,CAAC,IAAI,CAACoB,EAAE,CAAC;;MAG7CvF,KAAK,GAAGd,KAAK,CAACO,KAAK,CAAC;MACpBuI,aAAa,CAAC9B,MAAM,CAAC,OAAO,EAAElG,KAAK,CAAC;MACpCgI,aAAa,CAAC9B,MAAM,CAAC,UAAU,EAAElG,KAAK,GAAGkF,aAAa,CAAC;MACvD8C,aAAa,CAAC9B,MAAM,CAAC,OAAO,EAAEzG,KAAK,CAAC;MAEpC,IAAI,CAAC4G,aAAa,CAAC2B,aAAa,EAAE,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC;MAElD,MAAM1B,KAAK,GAAG0B,aAAa,CAAC/I,GAAG,CAAC,OAAO,CAAC;MACxC,IAAIqH,KAAK,EAAE;QACV,IAAI,IAAI,CAACrH,GAAG,CAAC,UAAU,CAAC,CAACA,GAAG,CAAC,oBAAoB,CAAC,EAAE;UACnD,IAAIF,IAAI,GAAG,IAAI8F,IAAI,CAAC7E,KAAK,CAAC;UAC1B,IAAImG,MAAM,GAAGyB,YAAY,CAACC,SAAS,CAAC;UACpCvB,KAAK,CAACC,GAAG,CAAC,MAAM,EAAE,IAAI,CAACtF,KAAK,CAACuF,aAAa,CAACL,MAAM,CAACpH,IAAI,EAAEoH,MAAO,CAAC,CAAC;SACjE,MACI;UACJG,KAAK,CAACY,UAAU,CAAC,SAAS,EAAE,KAAK,CAAC;;;MAIpC,IAAI,CAAChD,eAAe,CAAC8D,aAAa,EAAE,IAAI,CAAC;MACzC,IAAI,CAACpB,gBAAgB,CAACoB,aAAa,EAAE,CAAC,CAAC;MACvC,IAAI,CAACzC,EAAE,EAAE;IACV,CAAC,CAAC;EACH;EAGUD,WAAWA,CAACtF,KAAa,EAAE8H,QAAgB,EAAEN,QAAuB,EAAES,UAAkB;IACjG,MAAMC,KAAK,GAAkB,EAAE;IAC/B,MAAMxH,QAAQ,GAAG8G,QAAQ,CAAC9G,QAAQ;IAClC,MAAMD,KAAK,GAAG+G,QAAQ,CAAC/G,KAAK;IAC5B,MAAM0H,GAAG,GAAG,IAAI,CAACpH,KAAK,CAACL,QAAQ,CAAC;IAEhC,MAAMJ,YAAY,GAAG,IAAI,CAACC,UAAU,CAAC,cAAc,CAAC;IAEpD,MAAM8C,IAAI,GAAG,IAAI,CAACpC,KAAK;IACvB,MAAM/B,KAAK,GAAG,IAAI,CAACP,SAAS,EAAE;IAE9B,IAAIyJ,CAAC,GAAG3H,KAAK,GAAG,CAAC;IACjB,IAAI+E,aAAa,GAAG,CAAC6C,QAAQ;IAE7B,IAAI7F,QAAQ,GAAGvE,KAAK,CAAC6C,WAAW,CAACJ,QAAQ,EAAEyH,GAAG,CAAC;IAC/C,IAAIG,YAAY,GAAGrK,KAAK,CAAC6C,WAAW,CAACJ,QAAQ,EAAED,KAAK,GAAG0H,GAAG,CAAC;IAC3D,IAAII,aAAa,GAAGvI,KAAK;IAEzB,IAAIU,QAAQ,IAAI,KAAK,EAAE;MACtBV,KAAK,GAAGiI,UAAU;;IAGnB,OAAOjI,KAAK,IAAI8H,QAAQ,EAAE;MACzB;MACA9H,KAAK,GAAG/B,KAAK,CAAC+C,IAAI,CAAChB,KAAK,EAAEU,QAAQ,EAAED,KAAK,EAAE4C,IAAI,CAAC;MAEhD,IAAI5D,KAAK,GAAG,IAAI,CAACoC,YAAY,CAAC7B,KAAK,CAAC;MACpC,IAAIwI,SAAS,GAAGtJ,KAAK,CAACO,KAAK,CAAC;MAE5B,IAAIiB,QAAQ,IAAI,KAAK,IAAIJ,YAAY,CAACI,QAAQ,IAAI,KAAK,EAAE;QACxD,IAAI,IAAI,CAAC+H,QAAQ,CAACzI,KAAK,CAAC,EAAE;UACzBoI,CAAC,EAAE;;QAGJ,IAAIA,CAAC,IAAI3H,KAAK,EAAE;UACf,IAAIT,KAAK,IAAIuI,aAAa,GAAGD,YAAY,GAAG,CAAC,EAAE;YAC9CvK,MAAM,CAAC2K,IAAI,CAACR,KAAK,EAAEzI,KAAK,CAAC;;UAE1B2I,CAAC,GAAG,CAAC;;QAENpI,KAAK,IAAIwC,QAAQ;QACjB;QACAxC,KAAK,GAAG/B,KAAK,CAAC+C,IAAI,CAAChB,KAAK,EAAEU,QAAQ,EAAE,CAAC,EAAE2C,IAAI,CAAC;OAC5C,MACI;QACJ,IAAImF,SAAS,GAAGxI,KAAK,EAAE;UACtB,KAAK,IAAIa,CAAC,GAAGpB,KAAK,EAAEY,GAAG,GAAGnB,KAAK,CAACS,MAAM,EAAEkB,CAAC,GAAGR,GAAG,EAAEQ,CAAC,EAAE,EAAE;YACrD2H,SAAS,GAAGtJ,KAAK,CAAC2B,CAAC,CAAC;YACpB,IAAI2H,SAAS,IAAIxI,KAAK,EAAE;cACvBP,KAAK,GAAGoB,CAAC;cACT;;;;QAKH9C,MAAM,CAAC2K,IAAI,CAACR,KAAK,EAAEzI,KAAK,CAAC;QAEzBO,KAAK,IAAIsI,YAAY;QACrB;QACAtI,KAAK,GAAG/B,KAAK,CAAC+C,IAAI,CAAChB,KAAK,EAAEU,QAAQ,EAAED,KAAK,EAAE4C,IAAI,CAAC;;MAGjD,IAAIrD,KAAK,IAAIwF,aAAa,EAAE;QAC3BxF,KAAK,IAAIsI,YAAY,GAAG9F,QAAQ;QAChC;QACAxC,KAAK,GAAG/B,KAAK,CAAC+C,IAAI,CAAChB,KAAK,EAAEU,QAAQ,EAAED,KAAK,EAAE4C,IAAI,CAAC;;MAEjD,IAAIrD,KAAK,IAAIwF,aAAa,EAAE;QAC3B;;MAGDA,aAAa,GAAGxF,KAAK;;IAGtB,OAAOkI,KAAK;EACb;EAEUO,QAAQA,CAAC7H,IAAY;IAC9B,MAAMzB,MAAM,GAAGpB,MAAM,CAACqB,cAAc,CAAC,IAAI,CAACT,SAAS,EAAE,EAAGI,IAAI,IAAI;MAC/D,OAAOf,MAAM,CAAC2K,aAAa,CAAC5J,IAAI,EAAE6B,IAAI,CAAC;IACxC,CAAC,CAAC;IAEF,OAAOzB,MAAM,CAACI,KAAK;EACpB;EACUqJ,SAASA,CAAChI,IAAY,EAAEH,KAAa,EAAEoI,aAA4B;IAC5E,IAAIpJ,KAAK,GAAGtB,KAAK,CAAC4E,UAAU,CAAC,IAAI,CAAClB,YAAY,CAACjB,IAAI,CAAC,GAAGH,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC;IACxF,OAAO,IAAI,CAACd,MAAM,CAACY,KAAK,CAAC;EAC1B;;AArmBAnB,MAAA,CAAAC,cAAA,CAAAH,eAAA;;;;SAAkC;;AAClCE,MAAA,CAAAC,cAAA,CAAAH,eAAA;;;;SAA0CP,QAAQ,CAACiL,UAAU,CAACC,MAAM,CAAC,CAAC3K,eAAe,CAAC4K,SAAS,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}