{"ast":null,"code":"import { DataItem } from \"../../../core/render/Component\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\n/**\r\n * Creates a date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\r\n * @important\r\n */\nexport class DateAxis extends ValueAxis {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_seriesDataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"_baseDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"_intervalMax\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_intervalMin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n    super._afterNew();\n    this._setBaseInterval(this.get(\"baseInterval\"));\n    this.on(\"baseInterval\", () => {\n      this._setBaseInterval(this.get(\"baseInterval\"));\n    });\n  }\n  _setBaseInterval(interval) {\n    this.setPrivateRaw(\"baseInterval\", interval);\n    this._baseDuration = $time.getIntervalDuration(interval);\n  }\n  _fixZoomFactor() {\n    const maxZoomFactor = this.get(\"maxZoomFactor\");\n    if (maxZoomFactor != null && maxZoomFactor != Infinity) {\n      this.setPrivateRaw(\"maxZoomFactor\", maxZoomFactor);\n    } else {\n      this.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n    }\n  }\n  _groupData() {\n    const min = this.getPrivate(\"min\");\n    const max = this.getPrivate(\"max\");\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      this._fixZoomFactor();\n      const groupInterval = this.getPrivate(\"groupInterval\");\n      if (groupInterval) {\n        this._setBaseInterval(groupInterval);\n      } else {\n        this._setBaseInterval(this.get(\"baseInterval\"));\n      }\n      if (this.isDirty(\"groupInterval\")) {\n        let groupInterval = this.get(\"groupInterval\");\n        if (groupInterval) {\n          this.setRaw(\"groupIntervals\", [groupInterval]);\n          this._handleRangeChange();\n        }\n      }\n      if (this.isDirty(\"groupData\")) {\n        if (!this._dataGrouped) {\n          if (this.get(\"groupData\")) {\n            $array.each(this.series, series => {\n              this._groupSeriesData(series);\n            });\n            this._handleRangeChange();\n          } else {\n            let baseInterval = this.get(\"baseInterval\");\n            let mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n            $array.each(this.series, series => {\n              series.setDataSet(mainDataSetId);\n              series.resetGrouping();\n            });\n            this._setBaseInterval(baseInterval);\n            this.setPrivateRaw(\"groupInterval\", undefined);\n            this.markDirtyExtremes();\n          }\n          this._dataGrouped = true;\n        }\n      }\n    }\n  }\n  _groupSeriesData(series) {\n    if (this.get(\"groupData\") && !series.get(\"groupDataDisabled\")) {\n      this._dataGrouped = true; // helps to avoid double grouping\n      this._seriesDataGrouped = true;\n      // make array of intervals which will be used;\n      let intervals = [];\n      let baseDuration = this.baseMainDuration();\n      let groupIntervals = this.get(\"groupIntervals\");\n      if (groupIntervals) {}\n      $array.each(groupIntervals, interval => {\n        let intervalDuration = $time.getIntervalDuration(interval);\n        if (intervalDuration > baseDuration) {\n          intervals.push(interval);\n        }\n      });\n      series._dataSets = {};\n      const key = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      let fields;\n      const baseAxis = series.get(\"baseAxis\");\n      if (series.get(\"xAxis\") === baseAxis) {\n        fields = series._valueYFields;\n      } else if (series.get(\"yAxis\") === baseAxis) {\n        fields = series._valueXFields;\n      }\n      let dataItems = series._mainDataItems;\n      let baseInterval = this.get(\"baseInterval\");\n      let mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n      series._dataSets[mainDataSetId] = dataItems;\n      const groupCallback = series.get(\"groupDataCallback\");\n      let groupOriginals = series.get(\"groupDataWithOriginals\", false);\n      if (groupCallback) {\n        groupOriginals = true;\n      }\n      $array.each(intervals, interval => {\n        let previousTime = -Infinity;\n        let dataSetId = interval.timeUnit + interval.count;\n        series._dataSets[dataSetId] = [];\n        let newDataItem;\n        let sum = {};\n        let count = {};\n        let groupFieldValues = {};\n        let workingFields = {};\n        $array.each(fields, field => {\n          sum[field] = 0;\n          count[field] = 0;\n          groupFieldValues[field] = series.get(field + \"Grouped\");\n          workingFields[field] = field + \"Working\";\n        });\n        let intervalDuration = $time.getDuration(interval.timeUnit);\n        let firstItem = dataItems[0];\n        let firstTime;\n        if (firstItem) {\n          firstTime = dataItems[0].get(key);\n        }\n        let prevNewDataItem;\n        $array.each(dataItems, dataItem => {\n          let time = dataItem.get(key);\n          //let roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, firstDay, utc, firstDate, timezone).getTime();\n          let roundedTime = $time.roun(time, interval.timeUnit, interval.count, this._root, firstTime);\n          let dataContext;\n          if (previousTime < roundedTime - intervalDuration / 24) {\n            dataContext = $object.copy(dataItem.dataContext);\n            newDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n            newDataItem.setRaw(key, roundedTime);\n            series._dataSets[dataSetId].push(newDataItem);\n            $array.each(fields, field => {\n              let value = dataItem.get(field);\n              if ($type.isNumber(value)) {\n                newDataItem.setRaw(field, value);\n                newDataItem.setRaw(workingFields[field], value);\n                count[field] = 1;\n                sum[field] = value;\n              } else {\n                sum[field] = 0;\n                count[field] = 0;\n              }\n            });\n            if (groupOriginals) {\n              newDataItem.set(\"originals\", [dataItem]);\n            }\n            if (groupCallback && prevNewDataItem) {\n              groupCallback(prevNewDataItem, interval);\n            }\n            prevNewDataItem = newDataItem;\n          } else {\n            $array.each(fields, field => {\n              let groupKey = groupFieldValues[field];\n              let value = dataItem.get(field);\n              if (value != null) {\n                let currentValue = newDataItem.get(field);\n                switch (groupKey) {\n                  case \"close\":\n                    newDataItem.setRaw(field, value);\n                    break;\n                  case \"sum\":\n                    newDataItem.setRaw(field, currentValue + value);\n                    break;\n                  case \"open\":\n                    break;\n                  case \"low\":\n                    if (value < currentValue) {\n                      newDataItem.setRaw(field, value);\n                    }\n                    break;\n                  case \"high\":\n                    if (value > currentValue) {\n                      newDataItem.setRaw(field, value);\n                    }\n                    break;\n                  case \"average\":\n                    count[field]++;\n                    sum[field] += value;\n                    let average = sum[field] / count[field];\n                    newDataItem.setRaw(field, average);\n                    break;\n                  case \"extreme\":\n                    if (Math.abs(value) > Math.abs(currentValue)) {\n                      newDataItem.setRaw(field, value);\n                    }\n                    break;\n                }\n                newDataItem.setRaw(workingFields[field], newDataItem.get(field));\n                let dataContext = $object.copy(dataItem.dataContext);\n                dataContext[key] = roundedTime;\n                newDataItem.dataContext = dataContext;\n              }\n            });\n            if (groupOriginals) {\n              newDataItem.get(\"originals\").push(dataItem);\n            }\n          }\n          previousTime = roundedTime;\n        });\n        if (groupCallback && prevNewDataItem) {\n          groupCallback(prevNewDataItem, interval);\n        }\n      });\n      if (series._dataSetId) {\n        series.setDataSet(series._dataSetId);\n      }\n      this.markDirtySize();\n      // solves problem if new series was added\n      if (this._seriesAdded) {\n        this._root.events.once(\"frameended\", () => {\n          this.markDirtySize();\n        });\n      }\n    }\n  }\n  _clearDirty() {\n    super._clearDirty();\n    this._groupingCalculated = false;\n    this._dataGrouped = false;\n  }\n  /**\r\n   * Returns a time interval axis would group data to for a specified duration.\r\n   *\r\n   * @since 5.2.1\r\n   */\n  getGroupInterval(duration) {\n    let baseInterval = this.get(\"baseInterval\");\n    let groupInterval = $time.chooseInterval(0, duration, this.get(\"groupCount\", Infinity), this.get(\"groupIntervals\"));\n    if ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n      groupInterval = Object.assign({}, baseInterval);\n    }\n    return groupInterval;\n  }\n  /**\r\n   * Return `max` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Max\r\n   */\n  getIntervalMax(interval) {\n    return this._intervalMax[interval.timeUnit + interval.count];\n  }\n  /**\r\n   * Return `min` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Min\r\n   */\n  getIntervalMin(interval) {\n    return this._intervalMin[interval.timeUnit + interval.count];\n  }\n  _handleRangeChange() {\n    super._handleRangeChange();\n    let selectionMin = Math.round(this.getPrivate(\"selectionMin\"));\n    let selectionMax = Math.round(this.getPrivate(\"selectionMax\"));\n    if ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n      if (this.get(\"endLocation\") == 0) {\n        selectionMax += 1;\n      }\n      if (this.get(\"groupData\") && !this._groupingCalculated) {\n        this._groupingCalculated = true;\n        let groupInterval = this.get(\"groupInterval\");\n        let current = this.getPrivate(\"groupInterval\");\n        let modifiedDifference = selectionMax - selectionMin + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n        if (current) {\n          let duration = $time.getIntervalDuration(current);\n          modifiedDifference = Math.ceil(modifiedDifference / duration) * duration;\n        }\n        if (!groupInterval) {\n          groupInterval = this.getGroupInterval(modifiedDifference);\n        }\n        if (groupInterval && (!current || current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count || this._seriesDataGrouped)) {\n          this._seriesDataGrouped = false;\n          this.setPrivateRaw(\"groupInterval\", groupInterval);\n          this._setBaseInterval(groupInterval);\n          let newId = groupInterval.timeUnit + groupInterval.count;\n          $array.each(this.series, series => {\n            if (series.get(\"baseAxis\") === this) {\n              series.setDataSet(newId);\n            }\n          });\n          this.markDirtyExtremes();\n          this._root.events.once(\"frameended\", () => {\n            this._root.events.once(\"frameended\", () => {\n              const type = \"groupintervalchanged\";\n              if (this.events.isEnabled(type)) {\n                this.events.dispatch(type, {\n                  type: type,\n                  target: this\n                });\n              }\n            });\n          });\n        }\n      }\n      $array.each(this.series, series => {\n        if (series.get(\"baseAxis\") === this) {\n          let fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n          const start = $array.getFirstSortedIndex(series.dataItems, dataItem => {\n            return $order.compare(dataItem.get(fieldName), selectionMin);\n          });\n          let startIndex = start.index;\n          if (startIndex > 0) {\n            startIndex -= 1;\n          }\n          selectionMax += this.baseDuration() * (1 - this.get(\"endLocation\", 1));\n          const end = $array.getSortedIndex(series.dataItems, dataItem => {\n            return $order.compare(dataItem.get(fieldName), selectionMax);\n          });\n          let endIndex = end.index;\n          let endIndex2 = endIndex;\n          if (endIndex2 > 1) {\n            endIndex2--;\n          }\n          const firstDataItem = series.dataItems[startIndex];\n          const lastDataItem = series.dataItems[endIndex2];\n          let lastDate;\n          let firstDate;\n          if (firstDataItem) {\n            firstDate = firstDataItem.get(fieldName);\n          }\n          if (lastDataItem) {\n            lastDate = lastDataItem.get(fieldName);\n          }\n          let outOfSelection = false;\n          if (lastDate != null && firstDate != null) {\n            if (lastDate < selectionMin || firstDate > selectionMax) {\n              outOfSelection = true;\n            }\n          }\n          series.setPrivate(\"outOfSelection\", outOfSelection);\n          series.setPrivate(\"startIndex\", startIndex);\n          series.setPrivate(\"adjustedStartIndex\", series._adjustStartIndex(startIndex));\n          series.setPrivate(\"endIndex\", endIndex);\n          this.root.events.once(\"frameended\", () => {\n            series._markDirtyPrivateKey(\"adjustedStartIndex\");\n          });\n        }\n      });\n    }\n  }\n  _adjustMinMax(min, max, gridCount, _strictMode) {\n    return {\n      min: min,\n      max: max,\n      step: (max - min) / gridCount\n    };\n  }\n  /**\r\n   * @ignore\r\n   */\n  intervalDuration() {\n    return this._intervalDuration;\n  }\n  _saveMinMax(min, max) {\n    let groupInterval = this.getPrivate(\"groupInterval\");\n    if (!groupInterval) {\n      groupInterval = this.get(\"baseInterval\");\n    }\n    let id = groupInterval.timeUnit + groupInterval.count;\n    this._intervalMin[id] = min;\n    this._intervalMax[id] = max;\n  }\n  _getM(timeUnit) {\n    if (timeUnit == \"month\" || timeUnit == \"year\" || timeUnit == \"day\") {\n      return 1.05;\n    }\n    return 1.01;\n  }\n  _getMinorInterval(interval) {\n    var _a;\n    let minorGridInterval;\n    let count = interval.count;\n    let timeUnit = interval.timeUnit;\n    if (count > 1) {\n      if (count == 10) {\n        count = 5;\n      } else if (count == 15) {\n        count = 5;\n      } else if (count == 12) {\n        count = 2;\n      } else if (count == 6) {\n        count = 1;\n      } else if (count == 30) {\n        count = 10;\n      } else if (count < 10) {\n        count = 1;\n      }\n      minorGridInterval = {\n        timeUnit: timeUnit,\n        count: count\n      };\n    }\n    if (timeUnit == \"week\") {\n      if (((_a = this.getPrivate(\"baseInterval\")) === null || _a === void 0 ? void 0 : _a.timeUnit) != \"week\") {\n        minorGridInterval = {\n          timeUnit: \"day\",\n          count: 1\n        };\n      } else {\n        minorGridInterval = {\n          timeUnit: \"week\",\n          count: 1\n        };\n      }\n    }\n    return minorGridInterval;\n  }\n  _prepareAxisItems() {\n    const min = this.getPrivate(\"min\");\n    const max = this.getPrivate(\"max\");\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      const root = this._root;\n      const selectionMin = Math.round(this.getPrivate(\"selectionMin\"));\n      const selectionMax = Math.round(this.getPrivate(\"selectionMax\"));\n      const renderer = this.get(\"renderer\");\n      const baseInterval = this.getPrivate(\"baseInterval\");\n      let value = selectionMin;\n      let i = 0;\n      const intervals = this.get(\"gridIntervals\");\n      let gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n      if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n        gridInterval = Object.assign({}, baseInterval);\n      }\n      const intervalDuration = $time.getIntervalDuration(gridInterval);\n      this._intervalDuration = intervalDuration;\n      const nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n      const utc = root.utc;\n      const timezone = root.timezone;\n      //value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, firstDay, utc, new Date(min), timezone).getTime();\n      value = $time.roun(selectionMin - intervalDuration, gridInterval.timeUnit, gridInterval.count, root, min);\n      let previousValue = value - intervalDuration;\n      let format;\n      const formats = this.get(\"dateFormats\");\n      this.setPrivateRaw(\"gridInterval\", gridInterval);\n      const minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\n      const minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\n      let minorGridInterval;\n      let minorDuration = 0;\n      if (minorGridEnabled) {\n        minorGridInterval = this._getMinorInterval(gridInterval);\n        minorDuration = $time.getIntervalDuration(minorGridInterval);\n      }\n      let m = 0;\n      while (value < selectionMax + intervalDuration) {\n        let dataItem;\n        if (this.dataItems.length < i + 1) {\n          dataItem = new DataItem(this, undefined, {});\n          this._dataItems.push(dataItem);\n          this.processDataItem(dataItem);\n        } else {\n          dataItem = this.dataItems[i];\n        }\n        this._createAssets(dataItem, []);\n        this._toggleDataItem(dataItem, true);\n        dataItem.setRaw(\"value\", value);\n        dataItem.setRaw(\"labelEndValue\", undefined);\n        let endValue = value + $time.getDuration(gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));\n        //endValue = $time.round(new Date(endValue), gridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n        endValue = $time.roun(endValue, gridInterval.timeUnit, 1, root);\n        dataItem.setRaw(\"endValue\", endValue);\n        let date = new Date(value);\n        format = formats[gridInterval.timeUnit];\n        if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n          if (gridInterval.timeUnit != \"year\") {\n            if ($time.checkChange(value, previousValue, nextGridUnit, utc, timezone)) {\n              format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n            }\n          }\n        }\n        const label = dataItem.get(\"label\");\n        if (label) {\n          label.set(\"text\", root.dateFormatter.format(date, format));\n        }\n        let count = gridInterval.count;\n        // so that labels of week would always be at the beginning of the grid\n        if (gridInterval.timeUnit == \"week\") {\n          dataItem.setRaw(\"labelEndValue\", value);\n        }\n        if (minorGridEnabled) {\n          count = 1;\n          let timeUnit = gridInterval.timeUnit;\n          if (timeUnit == \"week\") {\n            timeUnit = \"day\";\n          }\n          let labelEndValue = value + $time.getDuration(timeUnit, this._getM(timeUnit));\n          //labelEndValue = $time.round(new Date(labelEndValue), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n          labelEndValue = $time.roun(labelEndValue, timeUnit, 1, root);\n          dataItem.setRaw(\"labelEndValue\", labelEndValue);\n        }\n        this._prepareDataItem(dataItem, count);\n        previousValue = value;\n        value = endValue;\n        // min grid\n        if (minorGridInterval) {\n          const minorTimeUnit = minorGridInterval.timeUnit;\n          const minorCount = minorGridInterval.count;\n          const mmm = this._getM(minorTimeUnit);\n          //let minorValue = $time.round(new Date(previousValue + minorDuration * this._getM(minorGridInterval.timeUnit)), minorGridInterval.timeUnit, minorGridInterval.count, firstDay, utc, new Date(previousValue), timezone).getTime();\n          let minorValue = $time.roun(previousValue + minorDuration * mmm, minorTimeUnit, minorCount, root, previousValue);\n          let previousMinorValue;\n          let minorFormats = this.get(\"minorDateFormats\", this.get(\"dateFormats\"));\n          while (minorValue < value - 0.01 * minorDuration) {\n            let minorDataItem;\n            if (this.minorDataItems.length < m + 1) {\n              minorDataItem = new DataItem(this, undefined, {});\n              this.minorDataItems.push(minorDataItem);\n              this.processDataItem(minorDataItem);\n            } else {\n              minorDataItem = this.minorDataItems[m];\n            }\n            this._createAssets(minorDataItem, [\"minor\"], true);\n            this._toggleDataItem(minorDataItem, true);\n            minorDataItem.setRaw(\"value\", minorValue);\n            let minorEndValue = minorValue + $time.getDuration(minorTimeUnit, minorCount * mmm);\n            //minorEndValue = $time.round(new Date(minorEndValue), minorGridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n            minorEndValue = $time.roun(minorEndValue, minorTimeUnit, 1, root);\n            minorDataItem.setRaw(\"endValue\", minorEndValue);\n            let date = new Date(minorValue);\n            format = minorFormats[minorTimeUnit];\n            const minorLabel = minorDataItem.get(\"label\");\n            if (minorLabel) {\n              if (minorLabelsEnabled) {\n                minorLabel.set(\"text\", root.dateFormatter.format(date, format));\n              } else {\n                minorLabel.setPrivate(\"visible\", false);\n              }\n            }\n            this._prepareDataItem(minorDataItem, 1);\n            if (minorValue == previousMinorValue) {\n              break;\n            }\n            previousMinorValue = minorValue;\n            minorValue = minorEndValue;\n            m++;\n          }\n        }\n        if (value == previousValue) {\n          break;\n        }\n        i++;\n      }\n      for (let j = i; j < this.dataItems.length; j++) {\n        this._toggleDataItem(this.dataItems[j], false);\n      }\n      for (let j = m; j < this.minorDataItems.length; j++) {\n        this._toggleDataItem(this.minorDataItems[j], false);\n      }\n      $array.each(this.series, series => {\n        if (series.inited) {\n          series._markDirtyAxes();\n        }\n      });\n    }\n    this._updateGhost();\n  }\n  _updateFinals(start, end) {\n    this.setPrivateRaw(\"selectionMinFinal\", this.positionToValue(start));\n    this.setPrivateRaw(\"selectionMaxFinal\", this.positionToValue(end));\n  }\n  _getDelta() {\n    this._deltaMinMax = this.baseDuration() / 2;\n  }\n  _fixMin(min) {\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    const timeUnit = baseInterval.timeUnit;\n    //let startTime = $time.round(new Date(min), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n    let startTime = $time.roun(min, timeUnit, baseInterval.count, this._root);\n    let endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit));\n    //endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n    endTime = $time.roun(endTime, timeUnit, 1, this._root);\n    return startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n  }\n  _fixMax(max) {\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    const timeUnit = baseInterval.timeUnit;\n    //let startTime = $time.round(new Date(max), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n    let startTime = $time.roun(max, timeUnit, baseInterval.count, this._root);\n    let endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit));\n    //endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n    endTime = $time.roun(endTime, timeUnit, 1, this._root);\n    return startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n  }\n  _updateDates(_date, _series) {}\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n  baseDuration() {\n    return this._baseDuration;\n    //return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n  }\n  /**\r\n   * Returns a duration of user-defined `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n  baseMainDuration() {\n    return $time.getIntervalDuration(this.get(\"baseInterval\"));\n  }\n  /**\r\n   * @ignore\r\n   */\n  processSeriesDataItem(dataItem, fields) {\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    if (!dataItem.open) {\n      dataItem.open = {};\n    }\n    if (!dataItem.close) {\n      dataItem.close = {};\n    }\n    $array.each(fields, field => {\n      let value = dataItem.get(field);\n      if ($type.isNumber(value)) {\n        let startTime = dataItem.open[field];\n        let endTime = dataItem.close[field];\n        // this is done to save cpu, as rounding is quite expensive, especially with timezone set. \n        // if value is between prev start and end, it means it didn't change, all is fine.\n        if (value >= startTime && value <= endTime) {} else {\n          const timeUnit = baseInterval.timeUnit;\n          const count = baseInterval.count;\n          //startTime = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\n          startTime = $time.roun(value, timeUnit, count, this._root);\n          endTime = startTime + $time.getDuration(timeUnit, count * this._getM(timeUnit));\n          //endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n          endTime = $time.roun(endTime, timeUnit, 1, this._root);\n          dataItem.open[field] = startTime;\n          dataItem.close[field] = endTime;\n        }\n        this._updateDates(startTime, dataItem.component);\n      }\n    });\n  }\n  _handleSizeDirty() {\n    // void \n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionX(dataItem, field, cellLocation, axisLocation) {\n    let openValue;\n    let closeValue;\n    if (dataItem.open && dataItem.close) {\n      openValue = dataItem.open[field];\n      closeValue = dataItem.close[field];\n    } else {\n      openValue = dataItem.get(field);\n      closeValue = openValue;\n    }\n    let value = openValue + (closeValue - openValue) * cellLocation;\n    value = this._baseValue + (value - this._baseValue) * axisLocation;\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateX(dataItem, field, cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionY(dataItem, field, cellLocation, axisLocation) {\n    let openValue;\n    let closeValue;\n    if (dataItem.open && dataItem.close) {\n      openValue = dataItem.open[field];\n      closeValue = dataItem.close[field];\n    } else {\n      openValue = dataItem.get(field);\n      closeValue = openValue;\n    }\n    let value = openValue + (closeValue - openValue) * cellLocation;\n    value = this._baseValue + (value - this._baseValue) * axisLocation;\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateY(dataItem, field, cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  roundAxisPosition(position, location) {\n    let value = this.positionToValue(position);\n    value = value - (location - 0.5) * this.baseDuration();\n    let baseInterval = this.getPrivate(\"baseInterval\");\n    if (!$type.isNaN(value)) {\n      const firstDay = this._root.locale.firstDayOfWeek;\n      const timeUnit = baseInterval.timeUnit;\n      const utc = this._root.utc;\n      const timezone = this._root.timezone;\n      const count = baseInterval.count;\n      //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n      value = $time.roun(value, timeUnit, count, this._root, this.getPrivate(\"min\", 0));\n      let duration = $time.getDateIntervalDuration(baseInterval, new Date(value), firstDay, utc, timezone);\n      if (timezone) {\n        //value = $time.round(new Date(value + this.baseDuration() * 0.05), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n        value = $time.roun(value + this.baseDuration() * 0.05, timeUnit, count, this._root, this.getPrivate(\"min\", 0));\n        duration = $time.getDateIntervalDuration(baseInterval, new Date(value + duration * location), firstDay, utc, timezone);\n      }\n      return this.valueToPosition(value + duration * location);\n    }\n    return NaN;\n  }\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * NOTE: Unless `adjustPosition` (2nd parameter) is set to `false`, the method\r\n   * will adjust position by `tooltipIntervalOffset`.\r\n   *\r\n   * @param  position        Position\r\n   * @param  adjustPosition  Adjust position\r\n   * @return                 Tooltip text\r\n   */\n  getTooltipText(position, adjustPosition) {\n    //@todo number formatter + tag\n    if (this.getPrivate(\"min\") != null) {\n      let format = this.get(\"tooltipDateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n      let value = this.positionToValue(position);\n      if ($type.isNumber(value)) {\n        let date = new Date(value);\n        let baseInterval = this.getPrivate(\"baseInterval\");\n        let duration = $time.getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);\n        if (adjustPosition !== false) {\n          date = new Date(value + this.get(\"tooltipIntervalOffset\", -this.get(\"tooltipLocation\", 0.5)) * duration);\n        }\n        return this._root.dateFormatter.format(date, this.get(\"tooltipDateFormat\", format));\n      }\n    }\n    return \"\";\n  }\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  getSeriesItem(series, position, location, snap) {\n    let fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n    let value = this.positionToValue(position);\n    if (location == null) {\n      location = 0.5;\n    }\n    value = value - (location - 0.5) * this.baseDuration();\n    const result = $array.getSortedIndex(series.dataItems, dataItem => {\n      let diValue = 0;\n      if (dataItem.open) {\n        diValue = dataItem.open[fieldName];\n      }\n      return $order.compare(diValue, value);\n    });\n    if (snap || series.get(\"snapTooltip\")) {\n      let first = series.dataItems[result.index - 1];\n      let second = series.dataItems[result.index];\n      if (first && second) {\n        if (first.open && second.close) {\n          let open = first.open[fieldName];\n          let close = second.close[fieldName];\n          if (Math.abs(value - open) > Math.abs(value - close)) {\n            return second;\n          }\n        }\n      }\n      if (first) {\n        return first;\n      }\n      if (second) {\n        return second;\n      }\n    } else {\n      const dataItem = series.dataItems[result.index - 1];\n      if (dataItem) {\n        if (dataItem.open && dataItem.close) {\n          let open = dataItem.open[fieldName];\n          let close = dataItem.close[fieldName];\n          if (value >= open && value <= close) {\n            return dataItem;\n          }\n        }\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  shouldGap(dataItem, nextItem, autoGapCount, fieldName) {\n    const value1 = dataItem.get(fieldName);\n    const value2 = nextItem.get(fieldName);\n    if (value2 - value1 > this.baseDuration() * autoGapCount) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` dates.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start Date\r\n   * @param  end       End Date\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToDates(start, end, duration) {\n    this.zoomToValues(start.getTime(), end.getTime(), duration);\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` values.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start value\r\n   * @param  end       End value\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToValues(start, end, duration) {\n    const min = this.getPrivate(\"minFinal\", 0);\n    const max = this.getPrivate(\"maxFinal\", 0);\n    if (this.getPrivate(\"min\") != null && this.getPrivate(\"max\") != null) {\n      if (this.get(\"groupData\")) {\n        const futureGroupInterval = this.getGroupInterval(end - start);\n        const baseInterval = this.get(\"baseInterval\");\n        let baseMin = this.getIntervalMin(baseInterval);\n        let baseMax = this.getIntervalMax(baseInterval) - 1;\n        baseMax = $time.roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n        baseMax += this._getM(futureGroupInterval.timeUnit) * $time.getIntervalDuration(futureGroupInterval);\n        baseMax = $time.roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n        let futureMin = $time.roun(baseMin, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n        let futureMax = $time.roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n        let s = (start - futureMin) / (futureMax - futureMin);\n        let e = (end - futureMin) / (futureMax - futureMin);\n        this.zoom(s, e, duration);\n      } else {\n        this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n      }\n    }\n  }\n  /**\r\n   * Returns a `Date` object corresponding to specific position within plot\r\n   * area.\r\n   *\r\n   * @param   position  Pposition\r\n   * @return            Date\r\n   */\n  positionToDate(position) {\n    return new Date(this.positionToValue(position));\n  }\n  /**\r\n   * Returns a relative position within plot area that corresponds to specific\r\n   * date.\r\n   *\r\n   * @param   date  Date\r\n   * @return        Position\r\n   */\n  dateToPosition(date) {\n    return this.valueToPosition(date.getTime());\n  }\n  /**\r\n   * Returns relative position between two grid lines of the axis.\r\n   *\r\n   * @since 5.2.30\r\n   * @return Position\r\n   */\n  getCellWidthPosition() {\n    let max = this.getPrivate(\"selectionMax\", this.getPrivate(\"max\"));\n    let min = this.getPrivate(\"selectionMin\", this.getPrivate(\"min\"));\n    if ($type.isNumber(max) && $type.isNumber(min)) {\n      return this._intervalDuration / (max - min);\n    }\n    return 0.05;\n  }\n  nextPosition(count) {\n    if (count == null) {\n      count = 1;\n    }\n    let dtime = this.get(\"tooltipLocation\", 0.5) * this.baseDuration();\n    if (this.get(\"renderer\").getPrivate(\"letter\") == \"Y\") {\n      count *= -1;\n    }\n    let tooltipValue = this.positionToValue(this.getPrivate(\"tooltipPosition\", 0));\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    let time = this._nextTime(tooltipValue, count, baseInterval);\n    let selectionMin = this.getPrivate(\"selectionMin\", 0);\n    let selectionMax = this.getPrivate(\"selectionMax\", 0);\n    let min = $time.roun(selectionMin, baseInterval.timeUnit, baseInterval.count, this._root);\n    let max = $time.roun(selectionMax, baseInterval.timeUnit, baseInterval.count, this._root);\n    time += dtime;\n    time = $math.fitToRange(time, min + dtime, max - dtime);\n    return this.toGlobalPosition(this.valueToPosition(time));\n  }\n  _nextTime(time, count, baseInterval) {\n    return $time.roun(time + count * this.baseDuration(), baseInterval.timeUnit, baseInterval.count, this._root);\n  }\n}\nObject.defineProperty(DateAxis, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"DateAxis\"\n});\nObject.defineProperty(DateAxis, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: ValueAxis.classNames.concat([DateAxis.className])\n});","map":{"version":3,"names":["DataItem","ValueAxis","$type","$math","$order","$array","$object","$utils","$time","DateAxis","constructor","Object","defineProperty","_afterNew","_settings","themeTags","mergeTags","_setBaseInterval","get","on","interval","setPrivateRaw","_baseDuration","getIntervalDuration","_fixZoomFactor","maxZoomFactor","Infinity","Math","round","getPrivate","baseMainDuration","_groupData","min","max","isNumber","groupInterval","isDirty","setRaw","_handleRangeChange","_dataGrouped","each","series","_groupSeriesData","baseInterval","mainDataSetId","timeUnit","count","setDataSet","resetGrouping","undefined","markDirtyExtremes","_seriesDataGrouped","intervals","baseDuration","groupIntervals","intervalDuration","push","_dataSets","key","fields","baseAxis","_valueYFields","_valueXFields","dataItems","_mainDataItems","groupCallback","groupOriginals","previousTime","dataSetId","newDataItem","sum","groupFieldValues","workingFields","field","getDuration","firstItem","firstTime","prevNewDataItem","dataItem","time","roundedTime","roun","_root","dataContext","copy","_makeDataItem","value","set","groupKey","currentValue","average","abs","_dataSetId","markDirtySize","_seriesAdded","events","once","_clearDirty","_groupingCalculated","getGroupInterval","duration","chooseInterval","assign","getIntervalMax","_intervalMax","getIntervalMin","_intervalMin","selectionMin","selectionMax","current","modifiedDifference","ceil","newId","type","isEnabled","dispatch","target","fieldName","start","getFirstSortedIndex","compare","startIndex","index","end","getSortedIndex","endIndex","endIndex2","firstDataItem","lastDataItem","lastDate","firstDate","outOfSelection","setPrivate","_adjustStartIndex","root","_markDirtyPrivateKey","_adjustMinMax","gridCount","_strictMode","step","_intervalDuration","_saveMinMax","id","_getM","_getMinorInterval","minorGridInterval","_a","_prepareAxisItems","renderer","i","gridInterval","nextGridUnit","getNextUnit","utc","timezone","previousValue","format","formats","minorLabelsEnabled","minorGridEnabled","minorDuration","m","length","_dataItems","processDataItem","_createAssets","_toggleDataItem","endValue","date","Date","checkChange","label","dateFormatter","labelEndValue","_prepareDataItem","minorTimeUnit","minorCount","mmm","minorValue","previousMinorValue","minorFormats","minorDataItem","minorDataItems","minorEndValue","minorLabel","j","inited","_markDirtyAxes","_updateGhost","_updateFinals","positionToValue","_getDelta","_deltaMinMax","_fixMin","startTime","endTime","_fixMax","_updateDates","_date","_series","processSeriesDataItem","open","close","component","_handleSizeDirty","getDataItemPositionX","cellLocation","axisLocation","openValue","closeValue","_baseValue","valueToPosition","getDataItemCoordinateX","positionToCoordinate","getDataItemPositionY","getDataItemCoordinateY","roundAxisPosition","position","location","isNaN","firstDay","locale","firstDayOfWeek","getDateIntervalDuration","NaN","getTooltipText","adjustPosition","getSeriesItem","snap","result","diValue","first","second","shouldGap","nextItem","autoGapCount","value1","value2","zoomToDates","zoomToValues","getTime","futureGroupInterval","baseMin","baseMax","futureMin","futureMax","s","e","zoom","positionToDate","dateToPosition","getCellWidthPosition","nextPosition","dtime","tooltipValue","_nextTime","fitToRange","toGlobalPosition","classNames","concat","className"],"sources":["C:\\Users\\Moham\\Downloads\\Github projects\\Digital-Portfolio-main\\Frontend\\node_modules\\src\\.internal\\charts\\xy\\axes\\DateAxis.ts"],"sourcesContent":["import { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport type { XYSeries, IXYSeriesDataItem } from \"../series/XYSeries\";\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IMinMaxStep, IValueAxisEvents } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\nimport type { TimeUnit } from \"../../../core/util/Time\";\n\nexport interface IDateAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * IMPORTANT: `startLocation` is not supported by [[GaplessDateAxis]].\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * IMPORTANT: `endLocation` is not supported by [[GaplessDateAxis]].\n\t * \n\t * @default 1\n\t */\n\tendLocation?: number;\n\n\t/**\n\t * Should axis group data items togeter dynamically?\n\t *\n\t * @default false\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupData?: boolean;\n\n\t/**\n\t * Maximum number of data items in the view before data grouping kicks in.\n\t *\n\t * @default 500\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupCount?: number;\n\n\t/**\n\t * Force data item grouping to specific interval. This interval must be within groupIntervals array for this to work.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to group data items into.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * Date formats used for minor grid labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Minor_grid_formats} for more info\n\t * @since 5.6.0\n\t */\n\tminorDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t */\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\n\n\t/**\n\t * Time unit-specific formats to use for axis tooltip.\n\t * \n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t * @since 5.1.4\n\t */\n\ttooltipDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A value which indicates relative position within axis cell to get timestamp\n\t * for the tooltip from.\n\t *\n\t * Values are from `-1` to `1`.\n\t *\n\t * If not set, it will use `tooltipLocation` value, if `tooltipLocation`` is\n\t * not set, it will use -0.5.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t * @since 5.1.4\n\t */\n\ttooltipIntervalOffset?: number;\n}\n\nexport interface IDateAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDateAxisPrivate extends IValueAxisPrivate {\n\n\t/**\n\t * Current group interval.\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Current grid interval.\n\t */\n\tgridInterval: ITimeInterval;\n}\n\nexport interface IDateAxisEvents extends IValueAxisEvents {\n\n\t/**\n\t * Kicks in when data grouping is on, and current group interval changes, e.g. via zooming the chart.\n\t *\n\t * @since 5.2.43\n\t */\n\tgroupintervalchanged: {}\n\n}\n\n/**\n * Creates a date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\n * @important\n */\nexport class DateAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DateAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DateAxis.className]);\n\n\tdeclare public _settings: IDateAxisSettings<R>;\n\tdeclare public _privateSettings: IDateAxisPrivate;\n\tdeclare public _dataItemSettings: IDateAxisDataItem;\n\tdeclare public _events: IDateAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _seriesDataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\tprotected _baseDuration: number = 1;\n\n\tprotected _intervalMax: { [index: string]: number } = {};\n\tprotected _intervalMin: { [index: string]: number } = {};\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\tthis.on(\"baseInterval\", () => {\n\t\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\t})\n\t}\n\n\tprotected _setBaseInterval(interval: ITimeInterval) {\n\t\tthis.setPrivateRaw(\"baseInterval\", interval);\n\t\tthis._baseDuration = $time.getIntervalDuration(interval);\n\t}\n\n\tprotected _fixZoomFactor() {\n\t\tconst maxZoomFactor = this.get(\"maxZoomFactor\");\n\t\tif (maxZoomFactor != null && maxZoomFactor != Infinity) {\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", maxZoomFactor);\n\t\t}\n\t\telse {\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n\t\t}\n\t}\n\n\tprotected _groupData() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif (($type.isNumber(min) && $type.isNumber(max))) {\n\n\t\t\tthis._fixZoomFactor();\n\n\t\t\tconst groupInterval = this.getPrivate(\"groupInterval\")!;\n\t\t\tif (groupInterval) {\n\t\t\t\tthis._setBaseInterval(groupInterval);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\t\t}\n\n\n\t\t\tif (this.isDirty(\"groupInterval\")) {\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\")!;\n\t\t\t\tif (groupInterval) {\n\t\t\t\t\tthis.setRaw(\"groupIntervals\", [groupInterval]);\n\t\t\t\t\tthis._handleRangeChange();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isDirty(\"groupData\")) {\n\t\t\t\tif (!this._dataGrouped) {\n\t\t\t\t\tif (this.get(\"groupData\")) {\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tthis._groupSeriesData(series);\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis._handleRangeChange();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\t\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tseries.setDataSet(mainDataSetId);\n\t\t\t\t\t\t\tseries.resetGrouping();\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis._setBaseInterval(baseInterval);\n\t\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", undefined);\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t\tthis._dataGrouped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _groupSeriesData(series: XYSeries) {\n\t\tif (this.get(\"groupData\") && !series.get(\"groupDataDisabled\")) {\n\n\t\t\tthis._dataGrouped = true; // helps to avoid double grouping\n\n\t\t\tthis._seriesDataGrouped = true;\n\n\t\t\t// make array of intervals which will be used;\n\t\t\tlet intervals: ITimeInterval[] = [];\n\t\t\tlet baseDuration = this.baseMainDuration();\n\n\t\t\tlet groupIntervals = this.get(\"groupIntervals\")!;\n\t\t\tif (groupIntervals) { }\n\t\t\t$array.each(groupIntervals, (interval) => {\n\t\t\t\tlet intervalDuration = $time.getIntervalDuration(interval);\n\t\t\t\tif (intervalDuration > baseDuration) {\n\t\t\t\t\tintervals.push(interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tseries._dataSets = {};\n\n\t\t\tconst key = this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!;\n\t\t\tlet fields: Array<string>;\n\n\t\t\tconst baseAxis = series.get(\"baseAxis\");\n\n\t\t\tif (series.get(\"xAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueYFields;\n\t\t\t}\n\t\t\telse if (series.get(\"yAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueXFields;\n\t\t\t}\n\n\t\t\tlet dataItems = series._mainDataItems;\n\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\n\t\t\tseries._dataSets[mainDataSetId] = dataItems;\n\n\t\t\tconst groupCallback = series.get(\"groupDataCallback\");\n\t\t\tlet groupOriginals = series.get(\"groupDataWithOriginals\", false);\n\t\t\tif (groupCallback) {\n\t\t\t\tgroupOriginals = true;\n\t\t\t}\n\n\t\t\t$array.each(intervals, (interval) => {\n\n\t\t\t\tlet previousTime = -Infinity;\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\n\t\t\t\tseries._dataSets[dataSetId] = [];\n\n\t\t\t\tlet newDataItem: DataItem<IXYSeriesDataItem>;\n\n\t\t\t\tlet sum: { [index: string]: number } = {};\n\t\t\t\tlet count: { [index: string]: number } = {};\n\n\t\t\t\tlet groupFieldValues: { [index: string]: string } = {};\n\t\t\t\tlet workingFields: { [index: string]: string } = {};\n\n\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\tsum[field] = 0;\n\t\t\t\t\tcount[field] = 0;\n\t\t\t\t\tgroupFieldValues[field] = series.get((field + \"Grouped\") as any);\n\t\t\t\t\tworkingFields[field] = field + \"Working\";\n\t\t\t\t})\n\n\t\t\t\tlet intervalDuration = $time.getDuration(interval.timeUnit);\n\n\t\t\t\tlet firstItem = dataItems[0];\n\t\t\t\tlet firstTime: any;\n\t\t\t\tif (firstItem) {\n\t\t\t\t\tfirstTime = dataItems[0].get(key as any);\n\t\t\t\t}\n\n\t\t\t\tlet prevNewDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\t\t\t\t$array.each(dataItems, (dataItem) => {\n\t\t\t\t\tlet time = dataItem.get(key as any);\n\t\t\t\t\t//let roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, firstDay, utc, firstDate, timezone).getTime();\n\t\t\t\t\tlet roundedTime = $time.roun(time, interval.timeUnit, interval.count, this._root, firstTime);\n\t\t\t\t\tlet dataContext: any;\n\n\t\t\t\t\tif (previousTime < roundedTime - intervalDuration / 24) {\n\t\t\t\t\t\tdataContext = $object.copy(dataItem.dataContext);\n\n\t\t\t\t\t\tnewDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n\t\t\t\t\t\tnewDataItem.setRaw(key as any, roundedTime);\n\n\t\t\t\t\t\tseries._dataSets[dataSetId].push(newDataItem);\n\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\t\t\t\t\t\t\tif ($type.isNumber(value)) {\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, value);\n\t\t\t\t\t\t\t\tcount[field] = 1;\n\t\t\t\t\t\t\t\tsum[field] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tsum[field] = 0;\n\t\t\t\t\t\t\t\tcount[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (groupOriginals) {\n\t\t\t\t\t\t\tnewDataItem.set(\"originals\", [dataItem]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (groupCallback && prevNewDataItem) {\n\t\t\t\t\t\t\tgroupCallback(prevNewDataItem, interval);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprevNewDataItem = newDataItem;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet groupKey = groupFieldValues[field];\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\n\t\t\t\t\t\t\tif (value != null) {\n\n\t\t\t\t\t\t\t\tlet currentValue = newDataItem.get(field as any);\n\n\t\t\t\t\t\t\t\tswitch (groupKey) {\n\t\t\t\t\t\t\t\t\tcase \"close\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, currentValue + value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"open\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"low\":\n\t\t\t\t\t\t\t\t\t\tif (value < currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"high\":\n\t\t\t\t\t\t\t\t\t\tif (value > currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"average\":\n\t\t\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t\t\t\tlet average = sum[field] / count[field];\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, average);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"extreme\":\n\t\t\t\t\t\t\t\t\t\tif (Math.abs(value) > Math.abs(currentValue)) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, newDataItem.get(field as any));\n\t\t\t\t\t\t\t\tlet dataContext: any = $object.copy(dataItem.dataContext);\n\t\t\t\t\t\t\t\tdataContext[key as any] = roundedTime;\n\t\t\t\t\t\t\t\tnewDataItem.dataContext = dataContext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (groupOriginals) {\n\t\t\t\t\t\t\tnewDataItem.get(\"originals\")!.push(dataItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreviousTime = roundedTime;\n\t\t\t\t})\n\n\t\t\t\tif (groupCallback && prevNewDataItem) {\n\t\t\t\t\tgroupCallback(prevNewDataItem, interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (series._dataSetId) {\n\t\t\t\tseries.setDataSet(series._dataSetId);\n\t\t\t}\n\t\t\tthis.markDirtySize();\n\t\t\t// solves problem if new series was added\n\t\t\tif (this._seriesAdded) {\n\t\t\t\tthis._root.events.once(\"frameended\", () => {\n\t\t\t\t\tthis.markDirtySize();\n\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _clearDirty() {\n\t\tsuper._clearDirty();\n\t\tthis._groupingCalculated = false;\n\t\tthis._dataGrouped = false;\n\t}\n\n\t/**\n\t * Returns a time interval axis would group data to for a specified duration.\n\t *\n\t * @since 5.2.1\n\t */\n\tpublic getGroupInterval(duration: number): ITimeInterval {\n\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\tlet groupInterval = $time.chooseInterval(0, duration, this.get(\"groupCount\", Infinity), this.get(\"groupIntervals\")!);\n\t\tif ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n\t\t\tgroupInterval = { ...baseInterval };\n\t\t}\n\t\treturn groupInterval;\n\t}\n\n\t/**\n\t * Return `max` of a specified time interval.\n\t * \n\t * Will work only if the axis was grouped to this interval at least once.\n\t * \n\t * @since 5.2.1\n\t * @param   interval  Interval\n\t * @return            Max\n\t */\n\tpublic getIntervalMax(interval: ITimeInterval): number {\n\t\treturn this._intervalMax[interval.timeUnit + interval.count];\n\t}\n\n\t/**\n\t * Return `min` of a specified time interval.\n\t * \n\t * Will work only if the axis was grouped to this interval at least once.\n\t * \n\t * @since 5.2.1\n\t * @param   interval  Interval\n\t * @return            Min\n\t */\n\tpublic getIntervalMin(interval: ITimeInterval): number {\n\t\treturn this._intervalMin[interval.timeUnit + interval.count];\n\t}\n\n\tprotected _handleRangeChange() {\n\t\tsuper._handleRangeChange();\n\n\t\tlet selectionMin = Math.round(this.getPrivate(\"selectionMin\")! as number);\n\t\tlet selectionMax = Math.round(this.getPrivate(\"selectionMax\")! as number);\n\n\t\tif ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n\n\t\t\tif (this.get(\"endLocation\") == 0) {\n\t\t\t\tselectionMax += 1;\n\t\t\t}\n\n\t\t\tif (this.get(\"groupData\") && !this._groupingCalculated) {\n\t\t\t\tthis._groupingCalculated = true;\n\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\");\n\t\t\t\tlet current = this.getPrivate(\"groupInterval\");\n\n\t\t\t\tlet modifiedDifference = (selectionMax - selectionMin) + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n\n\t\t\t\tif (current) {\n\t\t\t\t\tlet duration = $time.getIntervalDuration(current);\n\t\t\t\t\tmodifiedDifference = Math.ceil(modifiedDifference / duration) * duration;\n\t\t\t\t}\n\n\t\t\t\tif (!groupInterval) {\n\t\t\t\t\tgroupInterval = this.getGroupInterval(modifiedDifference);\n\t\t\t\t}\n\n\t\t\t\tif (groupInterval && (!current || (current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count) || this._seriesDataGrouped)) {\n\t\t\t\t\tthis._seriesDataGrouped = false;\n\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", groupInterval);\n\t\t\t\t\tthis._setBaseInterval(groupInterval)\n\n\n\t\t\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\n\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\t\t\tseries.setDataSet(newId);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tthis.markDirtyExtremes();\n\n\t\t\t\t\tthis._root.events.once(\"frameended\", () => {\n\t\t\t\t\t\tthis._root.events.once(\"frameended\", () => {\n\t\t\t\t\t\t\tconst type = \"groupintervalchanged\";\n\t\t\t\t\t\t\tif (this.events.isEnabled(type)) {\n\t\t\t\t\t\t\t\tthis.events.dispatch(type, { type: type, target: this });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\n\t\t\t\t\tconst start = $array.getFirstSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMin);\n\t\t\t\t\t});\n\n\t\t\t\t\tlet startIndex = start.index;\n\n\t\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t\tstartIndex -= 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tselectionMax += this.baseDuration() * (1 - this.get(\"endLocation\", 1));\n\n\t\t\t\t\tconst end = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMax);\n\t\t\t\t\t});\n\n\t\t\t\t\tlet endIndex = end.index;\n\t\t\t\t\tlet endIndex2 = endIndex;\n\n\t\t\t\t\tif (endIndex2 > 1) {\n\t\t\t\t\t\tendIndex2--;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst firstDataItem = series.dataItems[startIndex];\n\t\t\t\t\tconst lastDataItem = series.dataItems[endIndex2];\n\n\t\t\t\t\tlet lastDate: number | undefined;\n\t\t\t\t\tlet firstDate: number | undefined;\n\t\t\t\t\tif (firstDataItem) {\n\t\t\t\t\t\tfirstDate = firstDataItem.get(fieldName);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lastDataItem) {\n\t\t\t\t\t\tlastDate = lastDataItem.get(fieldName);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet outOfSelection = false;\n\t\t\t\t\tif (lastDate != null && firstDate != null) {\n\t\t\t\t\t\tif (lastDate < selectionMin || firstDate > selectionMax) {\n\t\t\t\t\t\t\toutOfSelection = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tseries.setPrivate(\"outOfSelection\", outOfSelection);\n\t\t\t\t\tseries.setPrivate(\"startIndex\", startIndex);\n\t\t\t\t\tseries.setPrivate(\"adjustedStartIndex\", series._adjustStartIndex(startIndex));\n\t\t\t\t\tseries.setPrivate(\"endIndex\", endIndex);\n\t\t\t\t\tthis.root.events.once(\"frameended\", () => {\n\t\t\t\t\t\tseries._markDirtyPrivateKey(\"adjustedStartIndex\");\n\t\t\t\t\t})\n\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, _strictMode?: boolean): IMinMaxStep {\n\t\treturn { min: min, max: max, step: (max - min) / gridCount };\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic intervalDuration(): number {\n\t\treturn this._intervalDuration;\n\t}\n\n\tprotected _saveMinMax(min: number, max: number) {\n\t\tlet groupInterval = this.getPrivate(\"groupInterval\");\n\n\t\tif (!groupInterval) {\n\t\t\tgroupInterval = this.get(\"baseInterval\");\n\t\t}\n\n\t\tlet id = groupInterval.timeUnit + groupInterval.count;\n\t\tthis._intervalMin[id] = min;\n\t\tthis._intervalMax[id] = max;\n\t}\n\n\tprotected _getM(timeUnit: TimeUnit) {\n\t\tif (timeUnit == \"month\" || timeUnit == \"year\" || timeUnit == \"day\") {\n\t\t\treturn 1.05;\n\t\t}\n\t\treturn 1.01;\n\t}\n\n\tprotected _getMinorInterval(interval: ITimeInterval): ITimeInterval | undefined {\n\t\tlet minorGridInterval: ITimeInterval | undefined;\n\t\tlet count = interval.count;\n\t\tlet timeUnit = interval.timeUnit;\n\t\tif (count > 1) {\n\t\t\tif (count == 10) {\n\t\t\t\tcount = 5;\n\t\t\t}\n\t\t\telse if (count == 15) {\n\t\t\t\tcount = 5;\n\t\t\t}\n\t\t\telse if (count == 12) {\n\t\t\t\tcount = 2;\n\t\t\t}\n\t\t\telse if (count == 6) {\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\telse if (count == 30) {\n\t\t\t\tcount = 10;\n\t\t\t}\n\t\t\telse if (count < 10) {\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\tminorGridInterval = { timeUnit: timeUnit, count: count };\n\t\t}\n\t\tif (timeUnit == \"week\") {\n\t\t\tif (this.getPrivate(\"baseInterval\")?.timeUnit != \"week\") {\n\t\t\t\tminorGridInterval = { timeUnit: \"day\", count: 1 };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tminorGridInterval = { timeUnit: \"week\", count: 1 };\n\t\t\t}\n\t\t}\n\t\treturn minorGridInterval;\n\t}\n\n\tprotected _prepareAxisItems() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tconst root = this._root;\n\t\t\tconst selectionMin = Math.round(this.getPrivate(\"selectionMin\")! as number);\n\t\t\tconst selectionMax = Math.round(this.getPrivate(\"selectionMax\")! as number);\n\t\t\tconst renderer = this.get(\"renderer\");\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\t\tlet value = selectionMin;\n\t\t\tlet i = 0;\n\n\t\t\tconst intervals = this.get(\"gridIntervals\")!;\n\t\t\tlet gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n\t\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\t\tgridInterval = { ...baseInterval };\n\t\t\t}\n\n\t\t\tconst intervalDuration = $time.getIntervalDuration(gridInterval);\n\t\t\tthis._intervalDuration = intervalDuration;\n\n\t\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\t\t\tconst utc = root.utc;\n\t\t\tconst timezone = root.timezone;\n\n\t\t\t//value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, firstDay, utc, new Date(min), timezone).getTime();\n\t\t\tvalue = $time.roun(selectionMin - intervalDuration, gridInterval.timeUnit, gridInterval.count, root, min);\n\t\t\tlet previousValue = value - intervalDuration;\n\t\t\tlet format: string | Intl.DateTimeFormatOptions;\n\t\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\t\tthis.setPrivateRaw(\"gridInterval\", gridInterval);\n\n\t\t\tconst minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\n\t\t\tconst minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\n\n\t\t\tlet minorGridInterval: ITimeInterval | undefined;\n\t\t\tlet minorDuration = 0;\n\n\t\t\tif (minorGridEnabled) {\n\t\t\t\tminorGridInterval = this._getMinorInterval(gridInterval);\n\t\t\t\tminorDuration = $time.getIntervalDuration(minorGridInterval);\n\t\t\t}\n\n\t\t\tlet m = 0;\n\t\t\twhile (value < selectionMax + intervalDuration) {\n\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\tif (this.dataItems.length < i + 1) {\n\t\t\t\t\tdataItem = new DataItem(this, undefined, {});\n\t\t\t\t\tthis._dataItems.push(dataItem);\n\t\t\t\t\tthis.processDataItem(dataItem);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdataItem = this.dataItems[i];\n\t\t\t\t}\n\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tthis._toggleDataItem(dataItem, true);\n\n\t\t\t\tdataItem.setRaw(\"value\", value);\n\t\t\t\tdataItem.setRaw(\"labelEndValue\", undefined);\n\n\t\t\t\tlet endValue = value + $time.getDuration(gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));\n\t\t\t\t//endValue = $time.round(new Date(endValue), gridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\t\t\t\tendValue = $time.roun(endValue, gridInterval.timeUnit, 1, root);\n\n\t\t\t\tdataItem.setRaw(\"endValue\", endValue);\n\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tformat = formats[gridInterval.timeUnit];\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\t\t\t\t\tif (gridInterval.timeUnit != \"year\") {\n\t\t\t\t\t\tif ($time.checkChange(value, previousValue, nextGridUnit, utc, timezone)) {\n\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\n\t\t\t\tlet count = gridInterval.count;\n\t\t\t\t// so that labels of week would always be at the beginning of the grid\n\t\t\t\tif (gridInterval.timeUnit == \"week\") {\n\t\t\t\t\tdataItem.setRaw(\"labelEndValue\", value);\n\t\t\t\t}\n\n\t\t\t\tif (minorGridEnabled) {\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tlet timeUnit = gridInterval.timeUnit;\n\t\t\t\t\tif (timeUnit == \"week\") {\n\t\t\t\t\t\ttimeUnit = \"day\";\n\t\t\t\t\t}\n\n\t\t\t\t\tlet labelEndValue = value + $time.getDuration(timeUnit, this._getM(timeUnit));\n\t\t\t\t\t//labelEndValue = $time.round(new Date(labelEndValue), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\t\t\t\t\tlabelEndValue = $time.roun(labelEndValue, timeUnit, 1, root);\n\t\t\t\t\tdataItem.setRaw(\"labelEndValue\", labelEndValue);\n\t\t\t\t}\n\n\t\t\t\tthis._prepareDataItem(dataItem, count);\n\n\t\t\t\tpreviousValue = value;\n\t\t\t\tvalue = endValue;\n\n\t\t\t\t// min grid\n\t\t\t\tif (minorGridInterval) {\n\t\t\t\t\tconst minorTimeUnit = minorGridInterval.timeUnit;\n\t\t\t\t\tconst minorCount = minorGridInterval.count;\n\t\t\t\t\tconst mmm = this._getM(minorTimeUnit);\n\n\t\t\t\t\t//let minorValue = $time.round(new Date(previousValue + minorDuration * this._getM(minorGridInterval.timeUnit)), minorGridInterval.timeUnit, minorGridInterval.count, firstDay, utc, new Date(previousValue), timezone).getTime();\n\t\t\t\t\tlet minorValue = $time.roun(previousValue + minorDuration * mmm, minorTimeUnit, minorCount, root, previousValue);\n\n\t\t\t\t\tlet previousMinorValue: number | undefined;\n\t\t\t\t\tlet minorFormats = this.get(\"minorDateFormats\", this.get(\"dateFormats\"))!;\n\n\t\t\t\t\twhile (minorValue < value - 0.01 * minorDuration) {\n\t\t\t\t\t\tlet minorDataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\t\t\tif (this.minorDataItems.length < m + 1) {\n\t\t\t\t\t\t\tminorDataItem = new DataItem(this, undefined, {});\n\t\t\t\t\t\t\tthis.minorDataItems.push(minorDataItem);\n\t\t\t\t\t\t\tthis.processDataItem(minorDataItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tminorDataItem = this.minorDataItems[m];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._createAssets(minorDataItem, [\"minor\"], true);\n\n\t\t\t\t\t\tthis._toggleDataItem(minorDataItem, true);\n\n\t\t\t\t\t\tminorDataItem.setRaw(\"value\", minorValue);\n\n\t\t\t\t\t\tlet minorEndValue = minorValue + $time.getDuration(minorTimeUnit, minorCount * mmm);\n\t\t\t\t\t\t//minorEndValue = $time.round(new Date(minorEndValue), minorGridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\t\t\t\t\t\tminorEndValue = $time.roun(minorEndValue, minorTimeUnit, 1, root);\n\n\t\t\t\t\t\tminorDataItem.setRaw(\"endValue\", minorEndValue);\n\n\t\t\t\t\t\tlet date = new Date(minorValue);\n\n\t\t\t\t\t\tformat = minorFormats[minorTimeUnit];\n\n\t\t\t\t\t\tconst minorLabel = minorDataItem.get(\"label\");\n\n\t\t\t\t\t\tif (minorLabel) {\n\t\t\t\t\t\t\tif (minorLabelsEnabled) {\n\t\t\t\t\t\t\t\tminorLabel.set(\"text\", root.dateFormatter.format(date, format!));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tminorLabel.setPrivate(\"visible\", false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._prepareDataItem(minorDataItem, 1);\n\n\t\t\t\t\t\tif (minorValue == previousMinorValue) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpreviousMinorValue = minorValue;\n\t\t\t\t\t\tminorValue = minorEndValue;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (value == previousValue) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tfor (let j = i; j < this.dataItems.length; j++) {\n\t\t\t\tthis._toggleDataItem(this.dataItems[j], false);\n\t\t\t}\n\n\t\t\tfor (let j = m; j < this.minorDataItems.length; j++) {\n\t\t\t\tthis._toggleDataItem(this.minorDataItems[j], false);\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.inited) {\n\t\t\t\t\tseries._markDirtyAxes();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\tprotected _updateFinals(start: number, end: number) {\n\t\tthis.setPrivateRaw(\"selectionMinFinal\", this.positionToValue(start));\n\t\tthis.setPrivateRaw(\"selectionMaxFinal\", this.positionToValue(end));\n\t}\n\n\tprotected _getDelta() {\n\t\tthis._deltaMinMax = this.baseDuration() / 2;\n\t}\n\n\tprotected _fixMin(min: number) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\t\tconst timeUnit = baseInterval.timeUnit;\n\t\t//let startTime = $time.round(new Date(min), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n\t\tlet startTime = $time.roun(min, timeUnit, baseInterval.count, this._root);\n\n\t\tlet endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit))\n\t\t//endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\t\tendTime = $time.roun(endTime, timeUnit, 1, this._root);\n\t\treturn startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n\t}\n\n\tprotected _fixMax(max: number) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\t\tconst timeUnit = baseInterval.timeUnit;\n\t\t//let startTime = $time.round(new Date(max), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n\t\tlet startTime = $time.roun(max, timeUnit, baseInterval.count, this._root);\n\t\tlet endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit))\n\t\t//endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\t\tendTime = $time.roun(endTime, timeUnit, 1, this._root);\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n\t}\n\n\tprotected _updateDates(_date: number, _series: XYSeries) {\n\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t * \n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn this._baseDuration;\n\t\t//return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\t/**\n\t * Returns a duration of user-defined `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseMainDuration(): number {\n\t\treturn $time.getIntervalDuration(this.get(\"baseInterval\"));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic processSeriesDataItem(dataItem: DataItem<IXYSeriesDataItem>, fields: Array<string>) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tif (!dataItem.open) {\n\t\t\tdataItem.open = {};\n\t\t}\n\t\tif (!dataItem.close) {\n\t\t\tdataItem.close = {};\n\t\t}\n\n\t\t$array.each(fields, (field) => {\n\t\t\tlet value = dataItem.get(field as any);\n\t\t\tif ($type.isNumber(value)) {\n\t\t\t\tlet startTime = dataItem.open![field];\n\t\t\t\tlet endTime = dataItem.close![field];\n\t\t\t\t// this is done to save cpu, as rounding is quite expensive, especially with timezone set. \n\t\t\t\t// if value is between prev start and end, it means it didn't change, all is fine.\n\t\t\t\tif (value >= startTime && value <= endTime) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst timeUnit = baseInterval.timeUnit;\n\t\t\t\t\tconst count = baseInterval.count;\n\t\t\t\t\t//startTime = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\n\t\t\t\t\tstartTime = $time.roun(value, timeUnit, count, this._root);\n\t\t\t\t\tendTime = startTime + $time.getDuration(timeUnit, count * this._getM(timeUnit));\n\t\t\t\t\t//endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\t\t\t\t\tendTime = $time.roun(endTime, timeUnit, 1, this._root);\n\n\t\t\t\t\tdataItem.open![field] = startTime;\n\t\t\t\t\tdataItem.close![field] = endTime;\n\t\t\t\t}\n\n\t\t\t\tthis._updateDates(startTime, dataItem.component as XYSeries);\n\t\t\t}\n\t\t})\n\t}\n\n\tprotected _handleSizeDirty() {\n\t\t// void \n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\tlet value = this.positionToValue(position);\n\t\tvalue = value - (location - 0.5) * this.baseDuration();\n\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tif (!$type.isNaN(value)) {\n\t\t\tconst firstDay = this._root.locale.firstDayOfWeek;\n\t\t\tconst timeUnit = baseInterval.timeUnit;\n\t\t\tconst utc = this._root.utc;\n\t\t\tconst timezone = this._root.timezone;\n\t\t\tconst count = baseInterval.count;\n\n\t\t\t//value = $time.round(new Date(value), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n\t\t\tvalue = $time.roun(value, timeUnit, count, this._root, this.getPrivate(\"min\", 0));\n\n\t\t\tlet duration = $time.getDateIntervalDuration(baseInterval, new Date(value), firstDay, utc, timezone);\n\t\t\tif (timezone) {\n\t\t\t\t//value = $time.round(new Date(value + this.baseDuration() * 0.05), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n\t\t\t\tvalue = $time.roun(value + this.baseDuration() * 0.05, timeUnit, count, this._root, this.getPrivate(\"min\", 0));\n\t\t\t\tduration = $time.getDateIntervalDuration(baseInterval, new Date(value + duration * location), firstDay, utc, timezone);\n\t\t\t}\n\n\t\t\treturn this.valueToPosition(value + duration * location);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * NOTE: Unless `adjustPosition` (2nd parameter) is set to `false`, the method\n\t * will adjust position by `tooltipIntervalOffset`.\n\t *\n\t * @param  position        Position\n\t * @param  adjustPosition  Adjust position\n\t * @return                 Tooltip text\n\t */\n\tpublic getTooltipText(position: number, adjustPosition?: boolean): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tif (this.getPrivate(\"min\") != null) {\n\t\t\tlet format = this.get(\"tooltipDateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\t\tlet value = this.positionToValue(position);\n\t\t\tif ($type.isNumber(value)) {\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\t\t\tlet duration = $time.getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);\n\n\t\t\t\tif (adjustPosition !== false) {\n\t\t\t\t\tdate = new Date(value + this.get(\"tooltipIntervalOffset\", -this.get(\"tooltipLocation\", 0.5)) * duration)\n\t\t\t\t}\n\n\t\t\t\treturn this._root.dateFormatter.format(date, this.get(\"tooltipDateFormat\", format));\n\t\t\t}\n\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number, location?: number, snap?: boolean): DataItem<IXYSeriesDataItem> | undefined {\n\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\tlet value = this.positionToValue(position);\n\n\t\tif (location == null) {\n\t\t\tlocation = 0.5;\n\t\t}\n\n\t\tvalue = value - (location - 0.5) * this.baseDuration();\n\n\t\tconst result = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\tlet diValue = 0;\n\t\t\tif (dataItem.open) {\n\t\t\t\tdiValue = dataItem.open[fieldName];\n\t\t\t}\n\n\t\t\treturn $order.compare(diValue, value);\n\t\t});\n\n\t\tif (snap || series.get(\"snapTooltip\")) {\n\t\t\tlet first = series.dataItems[result.index - 1];\n\t\t\tlet second = series.dataItems[result.index];\n\n\t\t\tif (first && second) {\n\t\t\t\tif (first.open && second.close) {\n\t\t\t\t\tlet open = first.open[fieldName];\n\t\t\t\t\tlet close = second.close[fieldName];\n\n\t\t\t\t\tif (Math.abs(value - open) > Math.abs(value - close)) {\n\t\t\t\t\t\treturn second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (first) {\n\t\t\t\treturn first;\n\t\t\t}\n\n\t\t\tif (second) {\n\t\t\t\treturn second;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tconst dataItem = series.dataItems[result.index - 1];\n\n\t\t\tif (dataItem) {\n\t\t\t\tif (dataItem.open && dataItem.close) {\n\t\t\t\t\tlet open = dataItem.open[fieldName];\n\t\t\t\t\tlet close = dataItem.close[fieldName];\n\n\t\t\t\t\tif (value >= open && value <= close) {\n\t\t\t\t\t\treturn dataItem;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic shouldGap(dataItem: DataItem<IXYSeriesDataItem>, nextItem: DataItem<IXYSeriesDataItem>, autoGapCount: number, fieldName: string): boolean {\n\t\tconst value1 = dataItem.get(fieldName as any);\n\t\tconst value2 = nextItem.get(fieldName as any);\n\n\t\tif (value2 - value1 > this.baseDuration() * autoGapCount) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` dates.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start Date\n\t * @param  end       End Date\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToDates(start: Date, end: Date, duration?: number) {\n\t\tthis.zoomToValues(start.getTime(), end.getTime(), duration);\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` values.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start value\n\t * @param  end       End value\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToValues(start: number, end: number, duration?: number) {\n\t\tconst min = this.getPrivate(\"minFinal\", 0);\n\t\tconst max = this.getPrivate(\"maxFinal\", 0);\n\t\tif (this.getPrivate(\"min\") != null && this.getPrivate(\"max\") != null) {\n\t\t\tif (this.get(\"groupData\")) {\n\t\t\t\tconst futureGroupInterval = this.getGroupInterval(end - start);\n\t\t\t\tconst baseInterval = this.get(\"baseInterval\");\n\n\t\t\t\tlet baseMin = this.getIntervalMin(baseInterval);\n\t\t\t\tlet baseMax = this.getIntervalMax(baseInterval) - 1;\n\t\t\t\tbaseMax = $time.roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n\t\t\t\tbaseMax += this._getM(futureGroupInterval.timeUnit) * $time.getIntervalDuration(futureGroupInterval);\n\t\t\t\tbaseMax = $time.roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n\n\t\t\t\tlet futureMin = $time.roun(baseMin, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n\t\t\t\tlet futureMax = $time.roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);\n\n\t\t\t\tlet s = (start - futureMin) / (futureMax - futureMin);\n\t\t\t\tlet e = (end - futureMin) / (futureMax - futureMin);\n\n\t\t\t\tthis.zoom(s, e, duration);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Returns a `Date` object corresponding to specific position within plot\n\t * area.\n\t *\n\t * @param   position  Pposition\n\t * @return            Date\n\t */\n\tpublic positionToDate(position: number): Date {\n\t\treturn new Date(this.positionToValue(position));\n\t}\n\n\t/**\n\t * Returns a relative position within plot area that corresponds to specific\n\t * date.\n\t *\n\t * @param   date  Date\n\t * @return        Position\n\t */\n\tpublic dateToPosition(date: Date): number {\n\t\treturn this.valueToPosition(date.getTime());\n\t}\n\n\t/**\n\t * Returns relative position between two grid lines of the axis.\n\t *\n\t * @since 5.2.30\n\t * @return Position\n\t */\n\tpublic getCellWidthPosition(): number {\n\t\tlet max = this.getPrivate(\"selectionMax\", this.getPrivate(\"max\"));\n\t\tlet min = this.getPrivate(\"selectionMin\", this.getPrivate(\"min\"));\n\n\t\tif ($type.isNumber(max) && $type.isNumber(min)) {\n\t\t\treturn this._intervalDuration / (max - min);\n\t\t}\n\t\treturn 0.05;\n\t}\n\n\tpublic nextPosition(count?: number) {\n\t\tif (count == null) {\n\t\t\tcount = 1;\n\t\t}\n\n\t\tlet dtime = this.get(\"tooltipLocation\", 0.5) * this.baseDuration();\n\t\tif (this.get(\"renderer\").getPrivate(\"letter\") == \"Y\") {\n\t\t\tcount *= -1;\n\t\t}\n\n\t\tlet tooltipValue = this.positionToValue(this.getPrivate(\"tooltipPosition\", 0));\n\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\t\tlet time = this._nextTime(tooltipValue, count, baseInterval);\n\n\t\tlet selectionMin = this.getPrivate(\"selectionMin\", 0);\n\t\tlet selectionMax = this.getPrivate(\"selectionMax\", 0);\n\n\t\tlet min = $time.roun(selectionMin, baseInterval.timeUnit, baseInterval.count, this._root);\n\t\tlet max = $time.roun(selectionMax, baseInterval.timeUnit, baseInterval.count, this._root);\n\n\t\ttime += dtime;\n\t\ttime = $math.fitToRange(time, min + dtime, max - dtime);\n\n\t\treturn this.toGlobalPosition(this.valueToPosition(time));\n\t}\n\n\tprotected _nextTime(time: number, count: number, baseInterval: ITimeInterval) {\n\t\treturn $time.roun(time + count * this.baseDuration(), baseInterval.timeUnit, baseInterval.count, this._root);\n\t}\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,gCAAgC;AAGzD,SAASC,SAAS,QAAkG,aAAa;AACjI,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAChD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAChD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,OAAO,MAAM,2BAA2B;AACpD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAkKhD;;;;;;AAMA,OAAM,MAAOC,QAAiC,SAAQR,SAAY;EAAlES,YAAA;;IASCC,MAAA,CAAAC,cAAA;;;;aAAkC;;IAClCD,MAAA,CAAAC,cAAA;;;;aAAwC;;IACxCD,MAAA,CAAAC,cAAA;;;;aAAyC;;IACzCD,MAAA,CAAAC,cAAA;;;;aAAsC;;IACtCD,MAAA,CAAAC,cAAA;;;;aAAkC;;IAElCD,MAAA,CAAAC,cAAA;;;;aAAsD;;IACtDD,MAAA,CAAAC,cAAA;;;;aAAsD;;EA+lCvD;EA7lCQC,SAASA,CAAA;IACf,IAAI,CAACC,SAAS,CAACC,SAAS,GAAGR,MAAM,CAACS,SAAS,CAAC,IAAI,CAACF,SAAS,CAACC,SAAS,EAAE,CAAC,MAAM,CAAC,CAAC;IAC/E,KAAK,CAACF,SAAS,EAAE;IACjB,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAACC,GAAG,CAAC,cAAc,CAAC,CAAC;IAC/C,IAAI,CAACC,EAAE,CAAC,cAAc,EAAE,MAAK;MAC5B,IAAI,CAACF,gBAAgB,CAAC,IAAI,CAACC,GAAG,CAAC,cAAc,CAAC,CAAC;IAChD,CAAC,CAAC;EACH;EAEUD,gBAAgBA,CAACG,QAAuB;IACjD,IAAI,CAACC,aAAa,CAAC,cAAc,EAAED,QAAQ,CAAC;IAC5C,IAAI,CAACE,aAAa,GAAGd,KAAK,CAACe,mBAAmB,CAACH,QAAQ,CAAC;EACzD;EAEUI,cAAcA,CAAA;IACvB,MAAMC,aAAa,GAAG,IAAI,CAACP,GAAG,CAAC,eAAe,CAAC;IAC/C,IAAIO,aAAa,IAAI,IAAI,IAAIA,aAAa,IAAIC,QAAQ,EAAE;MACvD,IAAI,CAACL,aAAa,CAAC,eAAe,EAAEI,aAAa,CAAC;KAClD,MACI;MACJ,IAAI,CAACJ,aAAa,CAAC,eAAe,EAAEM,IAAI,CAACC,KAAK,CAAC,CAAC,IAAI,CAACC,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,IAAI,CAACA,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,IAAI,CAACC,gBAAgB,EAAE,CAAC,CAAC;;EAEpI;EAEUC,UAAUA,CAAA;IACnB,MAAMC,GAAG,GAAG,IAAI,CAACH,UAAU,CAAC,KAAK,CAAC;IAClC,MAAMI,GAAG,GAAG,IAAI,CAACJ,UAAU,CAAC,KAAK,CAAC;IAElC,IAAK3B,KAAK,CAACgC,QAAQ,CAACF,GAAG,CAAC,IAAI9B,KAAK,CAACgC,QAAQ,CAACD,GAAG,CAAC,EAAG;MAEjD,IAAI,CAACT,cAAc,EAAE;MAErB,MAAMW,aAAa,GAAG,IAAI,CAACN,UAAU,CAAC,eAAe,CAAE;MACvD,IAAIM,aAAa,EAAE;QAClB,IAAI,CAAClB,gBAAgB,CAACkB,aAAa,CAAC;OACpC,MACI;QACJ,IAAI,CAAClB,gBAAgB,CAAC,IAAI,CAACC,GAAG,CAAC,cAAc,CAAC,CAAC;;MAIhD,IAAI,IAAI,CAACkB,OAAO,CAAC,eAAe,CAAC,EAAE;QAClC,IAAID,aAAa,GAAG,IAAI,CAACjB,GAAG,CAAC,eAAe,CAAE;QAC9C,IAAIiB,aAAa,EAAE;UAClB,IAAI,CAACE,MAAM,CAAC,gBAAgB,EAAE,CAACF,aAAa,CAAC,CAAC;UAC9C,IAAI,CAACG,kBAAkB,EAAE;;;MAI3B,IAAI,IAAI,CAACF,OAAO,CAAC,WAAW,CAAC,EAAE;QAC9B,IAAI,CAAC,IAAI,CAACG,YAAY,EAAE;UACvB,IAAI,IAAI,CAACrB,GAAG,CAAC,WAAW,CAAC,EAAE;YAC1Bb,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAGA,MAAM,IAAI;cACnC,IAAI,CAACC,gBAAgB,CAACD,MAAM,CAAC;YAC9B,CAAC,CAAC;YAEF,IAAI,CAACH,kBAAkB,EAAE;WACzB,MACI;YACJ,IAAIK,YAAY,GAAG,IAAI,CAACzB,GAAG,CAAC,cAAc,CAAC;YAC3C,IAAI0B,aAAa,GAAWD,YAAY,CAACE,QAAQ,GAAGF,YAAY,CAACG,KAAK;YACtEzC,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAGA,MAAM,IAAI;cACnCA,MAAM,CAACM,UAAU,CAACH,aAAa,CAAC;cAChCH,MAAM,CAACO,aAAa,EAAE;YACvB,CAAC,CAAC;YAEF,IAAI,CAAC/B,gBAAgB,CAAC0B,YAAY,CAAC;YACnC,IAAI,CAACtB,aAAa,CAAC,eAAe,EAAE4B,SAAS,CAAC;YAC9C,IAAI,CAACC,iBAAiB,EAAE;;UAEzB,IAAI,CAACX,YAAY,GAAG,IAAI;;;;EAI5B;EAGOG,gBAAgBA,CAACD,MAAgB;IACvC,IAAI,IAAI,CAACvB,GAAG,CAAC,WAAW,CAAC,IAAI,CAACuB,MAAM,CAACvB,GAAG,CAAC,mBAAmB,CAAC,EAAE;MAE9D,IAAI,CAACqB,YAAY,GAAG,IAAI,CAAC,CAAC;MAE1B,IAAI,CAACY,kBAAkB,GAAG,IAAI;MAE9B;MACA,IAAIC,SAAS,GAAoB,EAAE;MACnC,IAAIC,YAAY,GAAG,IAAI,CAACvB,gBAAgB,EAAE;MAE1C,IAAIwB,cAAc,GAAG,IAAI,CAACpC,GAAG,CAAC,gBAAgB,CAAE;MAChD,IAAIoC,cAAc,EAAE;MACpBjD,MAAM,CAACmC,IAAI,CAACc,cAAc,EAAGlC,QAAQ,IAAI;QACxC,IAAImC,gBAAgB,GAAG/C,KAAK,CAACe,mBAAmB,CAACH,QAAQ,CAAC;QAC1D,IAAImC,gBAAgB,GAAGF,YAAY,EAAE;UACpCD,SAAS,CAACI,IAAI,CAACpC,QAAQ,CAAC;;MAE1B,CAAC,CAAC;MAEFqB,MAAM,CAACgB,SAAS,GAAG,EAAE;MAErB,MAAMC,GAAG,GAAG,IAAI,CAAC7B,UAAU,CAAC,MAAM,CAAE,GAAG,IAAI,CAACX,GAAG,CAAC,UAAU,CAAC,CAACW,UAAU,CAAC,QAAQ,CAAE;MACjF,IAAI8B,MAAqB;MAEzB,MAAMC,QAAQ,GAAGnB,MAAM,CAACvB,GAAG,CAAC,UAAU,CAAC;MAEvC,IAAIuB,MAAM,CAACvB,GAAG,CAAC,OAAO,CAAC,KAAK0C,QAAQ,EAAE;QACrCD,MAAM,GAAGlB,MAAM,CAACoB,aAAa;OAC7B,MACI,IAAIpB,MAAM,CAACvB,GAAG,CAAC,OAAO,CAAC,KAAK0C,QAAQ,EAAE;QAC1CD,MAAM,GAAGlB,MAAM,CAACqB,aAAa;;MAG9B,IAAIC,SAAS,GAAGtB,MAAM,CAACuB,cAAc;MACrC,IAAIrB,YAAY,GAAG,IAAI,CAACzB,GAAG,CAAC,cAAc,CAAC;MAC3C,IAAI0B,aAAa,GAAWD,YAAY,CAACE,QAAQ,GAAGF,YAAY,CAACG,KAAK;MAEtEL,MAAM,CAACgB,SAAS,CAACb,aAAa,CAAC,GAAGmB,SAAS;MAE3C,MAAME,aAAa,GAAGxB,MAAM,CAACvB,GAAG,CAAC,mBAAmB,CAAC;MACrD,IAAIgD,cAAc,GAAGzB,MAAM,CAACvB,GAAG,CAAC,wBAAwB,EAAE,KAAK,CAAC;MAChE,IAAI+C,aAAa,EAAE;QAClBC,cAAc,GAAG,IAAI;;MAGtB7D,MAAM,CAACmC,IAAI,CAACY,SAAS,EAAGhC,QAAQ,IAAI;QAEnC,IAAI+C,YAAY,GAAG,CAACzC,QAAQ;QAC5B,IAAI0C,SAAS,GAAGhD,QAAQ,CAACyB,QAAQ,GAAGzB,QAAQ,CAAC0B,KAAK;QAClDL,MAAM,CAACgB,SAAS,CAACW,SAAS,CAAC,GAAG,EAAE;QAEhC,IAAIC,WAAwC;QAE5C,IAAIC,GAAG,GAAgC,EAAE;QACzC,IAAIxB,KAAK,GAAgC,EAAE;QAE3C,IAAIyB,gBAAgB,GAAgC,EAAE;QACtD,IAAIC,aAAa,GAAgC,EAAE;QAEnDnE,MAAM,CAACmC,IAAI,CAACmB,MAAM,EAAGc,KAAK,IAAI;UAC7BH,GAAG,CAACG,KAAK,CAAC,GAAG,CAAC;UACd3B,KAAK,CAAC2B,KAAK,CAAC,GAAG,CAAC;UAChBF,gBAAgB,CAACE,KAAK,CAAC,GAAGhC,MAAM,CAACvB,GAAG,CAAEuD,KAAK,GAAG,SAAS,CAAS;UAChED,aAAa,CAACC,KAAK,CAAC,GAAGA,KAAK,GAAG,SAAS;QACzC,CAAC,CAAC;QAEF,IAAIlB,gBAAgB,GAAG/C,KAAK,CAACkE,WAAW,CAACtD,QAAQ,CAACyB,QAAQ,CAAC;QAE3D,IAAI8B,SAAS,GAAGZ,SAAS,CAAC,CAAC,CAAC;QAC5B,IAAIa,SAAc;QAClB,IAAID,SAAS,EAAE;UACdC,SAAS,GAAGb,SAAS,CAAC,CAAC,CAAC,CAAC7C,GAAG,CAACwC,GAAU,CAAC;;QAGzC,IAAImB,eAAwD;QAC5DxE,MAAM,CAACmC,IAAI,CAACuB,SAAS,EAAGe,QAAQ,IAAI;UACnC,IAAIC,IAAI,GAAGD,QAAQ,CAAC5D,GAAG,CAACwC,GAAU,CAAC;UACnC;UACA,IAAIsB,WAAW,GAAGxE,KAAK,CAACyE,IAAI,CAACF,IAAI,EAAE3D,QAAQ,CAACyB,QAAQ,EAAEzB,QAAQ,CAAC0B,KAAK,EAAE,IAAI,CAACoC,KAAK,EAAEN,SAAS,CAAC;UAC5F,IAAIO,WAAgB;UAEpB,IAAIhB,YAAY,GAAGa,WAAW,GAAGzB,gBAAgB,GAAG,EAAE,EAAE;YACvD4B,WAAW,GAAG7E,OAAO,CAAC8E,IAAI,CAACN,QAAQ,CAACK,WAAW,CAAC;YAEhDd,WAAW,GAAG,IAAIrE,QAAQ,CAACyC,MAAM,EAAE0C,WAAW,EAAE1C,MAAM,CAAC4C,aAAa,CAACF,WAAW,CAAC,CAAC;YAClFd,WAAW,CAAChC,MAAM,CAACqB,GAAU,EAAEsB,WAAW,CAAC;YAE3CvC,MAAM,CAACgB,SAAS,CAACW,SAAS,CAAC,CAACZ,IAAI,CAACa,WAAW,CAAC;YAE7ChE,MAAM,CAACmC,IAAI,CAACmB,MAAM,EAAGc,KAAK,IAAI;cAC7B,IAAIa,KAAK,GAAGR,QAAQ,CAAC5D,GAAG,CAACuD,KAAY,CAAC;cACtC,IAAIvE,KAAK,CAACgC,QAAQ,CAACoD,KAAK,CAAC,EAAE;gBAC1BjB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEa,KAAK,CAAC;gBACvCjB,WAAW,CAAChC,MAAM,CAACmC,aAAa,CAACC,KAAK,CAAQ,EAAEa,KAAK,CAAC;gBACtDxC,KAAK,CAAC2B,KAAK,CAAC,GAAG,CAAC;gBAChBH,GAAG,CAACG,KAAK,CAAC,GAAGa,KAAK;eAClB,MACI;gBACJhB,GAAG,CAACG,KAAK,CAAC,GAAG,CAAC;gBACd3B,KAAK,CAAC2B,KAAK,CAAC,GAAG,CAAC;;YAElB,CAAC,CAAC;YAEF,IAAIP,cAAc,EAAE;cACnBG,WAAW,CAACkB,GAAG,CAAC,WAAW,EAAE,CAACT,QAAQ,CAAC,CAAC;;YAGzC,IAAIb,aAAa,IAAIY,eAAe,EAAE;cACrCZ,aAAa,CAACY,eAAe,EAAEzD,QAAQ,CAAC;;YAGzCyD,eAAe,GAAGR,WAAW;WAC7B,MACI;YACJhE,MAAM,CAACmC,IAAI,CAACmB,MAAM,EAAGc,KAAK,IAAI;cAC7B,IAAIe,QAAQ,GAAGjB,gBAAgB,CAACE,KAAK,CAAC;cACtC,IAAIa,KAAK,GAAGR,QAAQ,CAAC5D,GAAG,CAACuD,KAAY,CAAC;cAEtC,IAAIa,KAAK,IAAI,IAAI,EAAE;gBAElB,IAAIG,YAAY,GAAGpB,WAAW,CAACnD,GAAG,CAACuD,KAAY,CAAC;gBAEhD,QAAQe,QAAQ;kBACf,KAAK,OAAO;oBACXnB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEa,KAAK,CAAC;oBACvC;kBAED,KAAK,KAAK;oBACTjB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEgB,YAAY,GAAGH,KAAK,CAAC;oBACtD;kBAED,KAAK,MAAM;oBACV;kBAED,KAAK,KAAK;oBACT,IAAIA,KAAK,GAAGG,YAAY,EAAE;sBACzBpB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEa,KAAK,CAAC;;oBAExC;kBAED,KAAK,MAAM;oBACV,IAAIA,KAAK,GAAGG,YAAY,EAAE;sBACzBpB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEa,KAAK,CAAC;;oBAExC;kBAED,KAAK,SAAS;oBACbxC,KAAK,CAAC2B,KAAK,CAAC,EAAE;oBACdH,GAAG,CAACG,KAAK,CAAC,IAAIa,KAAK;oBACnB,IAAII,OAAO,GAAGpB,GAAG,CAACG,KAAK,CAAC,GAAG3B,KAAK,CAAC2B,KAAK,CAAC;oBACvCJ,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEiB,OAAO,CAAC;oBACzC;kBAED,KAAK,SAAS;oBACb,IAAI/D,IAAI,CAACgE,GAAG,CAACL,KAAK,CAAC,GAAG3D,IAAI,CAACgE,GAAG,CAACF,YAAY,CAAC,EAAE;sBAC7CpB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEa,KAAK,CAAC;;oBAExC;gBAAM;gBAGRjB,WAAW,CAAChC,MAAM,CAACmC,aAAa,CAACC,KAAK,CAAQ,EAAEJ,WAAW,CAACnD,GAAG,CAACuD,KAAY,CAAC,CAAC;gBAC9E,IAAIU,WAAW,GAAQ7E,OAAO,CAAC8E,IAAI,CAACN,QAAQ,CAACK,WAAW,CAAC;gBACzDA,WAAW,CAACzB,GAAU,CAAC,GAAGsB,WAAW;gBACrCX,WAAW,CAACc,WAAW,GAAGA,WAAW;;YAEvC,CAAC,CAAC;YAEF,IAAIjB,cAAc,EAAE;cACnBG,WAAW,CAACnD,GAAG,CAAC,WAAW,CAAE,CAACsC,IAAI,CAACsB,QAAQ,CAAC;;;UAG9CX,YAAY,GAAGa,WAAW;QAC3B,CAAC,CAAC;QAEF,IAAIf,aAAa,IAAIY,eAAe,EAAE;UACrCZ,aAAa,CAACY,eAAe,EAAEzD,QAAQ,CAAC;;MAE1C,CAAC,CAAC;MAEF,IAAIqB,MAAM,CAACmD,UAAU,EAAE;QACtBnD,MAAM,CAACM,UAAU,CAACN,MAAM,CAACmD,UAAU,CAAC;;MAErC,IAAI,CAACC,aAAa,EAAE;MACpB;MACA,IAAI,IAAI,CAACC,YAAY,EAAE;QACtB,IAAI,CAACZ,KAAK,CAACa,MAAM,CAACC,IAAI,CAAC,YAAY,EAAE,MAAK;UACzC,IAAI,CAACH,aAAa,EAAE;QAErB,CAAC,CAAC;;;EAGL;EAEOI,WAAWA,CAAA;IACjB,KAAK,CAACA,WAAW,EAAE;IACnB,IAAI,CAACC,mBAAmB,GAAG,KAAK;IAChC,IAAI,CAAC3D,YAAY,GAAG,KAAK;EAC1B;EAEA;;;;;EAKO4D,gBAAgBA,CAACC,QAAgB;IACvC,IAAIzD,YAAY,GAAG,IAAI,CAACzB,GAAG,CAAC,cAAc,CAAC;IAC3C,IAAIiB,aAAa,GAAG3B,KAAK,CAAC6F,cAAc,CAAC,CAAC,EAAED,QAAQ,EAAE,IAAI,CAAClF,GAAG,CAAC,YAAY,EAAEQ,QAAQ,CAAC,EAAE,IAAI,CAACR,GAAG,CAAC,gBAAgB,CAAE,CAAC;IACpH,IAAIV,KAAK,CAACe,mBAAmB,CAACY,aAAa,CAAC,GAAG3B,KAAK,CAACe,mBAAmB,CAACoB,YAAY,CAAC,EAAE;MACvFR,aAAa,GAAAxB,MAAA,CAAA2F,MAAA,KAAQ3D,YAAY,CAAE;;IAEpC,OAAOR,aAAa;EACrB;EAEA;;;;;;;;;EASOoE,cAAcA,CAACnF,QAAuB;IAC5C,OAAO,IAAI,CAACoF,YAAY,CAACpF,QAAQ,CAACyB,QAAQ,GAAGzB,QAAQ,CAAC0B,KAAK,CAAC;EAC7D;EAEA;;;;;;;;;EASO2D,cAAcA,CAACrF,QAAuB;IAC5C,OAAO,IAAI,CAACsF,YAAY,CAACtF,QAAQ,CAACyB,QAAQ,GAAGzB,QAAQ,CAAC0B,KAAK,CAAC;EAC7D;EAEUR,kBAAkBA,CAAA;IAC3B,KAAK,CAACA,kBAAkB,EAAE;IAE1B,IAAIqE,YAAY,GAAGhF,IAAI,CAACC,KAAK,CAAC,IAAI,CAACC,UAAU,CAAC,cAAc,CAAY,CAAC;IACzE,IAAI+E,YAAY,GAAGjF,IAAI,CAACC,KAAK,CAAC,IAAI,CAACC,UAAU,CAAC,cAAc,CAAY,CAAC;IAEzE,IAAI3B,KAAK,CAACgC,QAAQ,CAACyE,YAAY,CAAC,IAAIzG,KAAK,CAACgC,QAAQ,CAAC0E,YAAY,CAAC,EAAE;MAEjE,IAAI,IAAI,CAAC1F,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE;QACjC0F,YAAY,IAAI,CAAC;;MAGlB,IAAI,IAAI,CAAC1F,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAACgF,mBAAmB,EAAE;QACvD,IAAI,CAACA,mBAAmB,GAAG,IAAI;QAE/B,IAAI/D,aAAa,GAAG,IAAI,CAACjB,GAAG,CAAC,eAAe,CAAC;QAC7C,IAAI2F,OAAO,GAAG,IAAI,CAAChF,UAAU,CAAC,eAAe,CAAC;QAE9C,IAAIiF,kBAAkB,GAAIF,YAAY,GAAGD,YAAY,IAAK,IAAI,CAACzF,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACA,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC,IAAI,IAAI,CAACmC,YAAY,EAAE,CAAC;QAEhJ,IAAIwD,OAAO,EAAE;UACZ,IAAIT,QAAQ,GAAG5F,KAAK,CAACe,mBAAmB,CAACsF,OAAO,CAAC;UACjDC,kBAAkB,GAAGnF,IAAI,CAACoF,IAAI,CAACD,kBAAkB,GAAGV,QAAQ,CAAC,GAAGA,QAAQ;;QAGzE,IAAI,CAACjE,aAAa,EAAE;UACnBA,aAAa,GAAG,IAAI,CAACgE,gBAAgB,CAACW,kBAAkB,CAAC;;QAG1D,IAAI3E,aAAa,KAAK,CAAC0E,OAAO,IAAKA,OAAO,CAAChE,QAAQ,KAAKV,aAAa,CAACU,QAAQ,IAAIgE,OAAO,CAAC/D,KAAK,KAAKX,aAAa,CAACW,KAAM,IAAI,IAAI,CAACK,kBAAkB,CAAC,EAAE;UACrJ,IAAI,CAACA,kBAAkB,GAAG,KAAK;UAC/B,IAAI,CAAC9B,aAAa,CAAC,eAAe,EAAEc,aAAa,CAAC;UAClD,IAAI,CAAClB,gBAAgB,CAACkB,aAAa,CAAC;UAGpC,IAAI6E,KAAK,GAAG7E,aAAa,CAACU,QAAQ,GAAGV,aAAa,CAACW,KAAK;UACxDzC,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAGA,MAAM,IAAI;YACnC,IAAIA,MAAM,CAACvB,GAAG,CAAC,UAAU,CAAC,KAAK,IAAI,EAAE;cACpCuB,MAAM,CAACM,UAAU,CAACiE,KAAK,CAAC;;UAE1B,CAAC,CAAC;UAEF,IAAI,CAAC9D,iBAAiB,EAAE;UAExB,IAAI,CAACgC,KAAK,CAACa,MAAM,CAACC,IAAI,CAAC,YAAY,EAAE,MAAK;YACzC,IAAI,CAACd,KAAK,CAACa,MAAM,CAACC,IAAI,CAAC,YAAY,EAAE,MAAK;cACzC,MAAMiB,IAAI,GAAG,sBAAsB;cACnC,IAAI,IAAI,CAAClB,MAAM,CAACmB,SAAS,CAACD,IAAI,CAAC,EAAE;gBAChC,IAAI,CAAClB,MAAM,CAACoB,QAAQ,CAACF,IAAI,EAAE;kBAAEA,IAAI,EAAEA,IAAI;kBAAEG,MAAM,EAAE;gBAAI,CAAE,CAAC;;YAE1D,CAAC,CAAC;UACH,CAAC,CAAC;;;MAIJ/G,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAGA,MAAM,IAAI;QACnC,IAAIA,MAAM,CAACvB,GAAG,CAAC,UAAU,CAAC,KAAK,IAAI,EAAE;UACpC,IAAImG,SAAS,GAAS,IAAI,CAACxF,UAAU,CAAC,MAAM,CAAE,GAAG,IAAI,CAACX,GAAG,CAAC,UAAU,CAAC,CAACW,UAAU,CAAC,QAAQ,CAAG;UAE5F,MAAMyF,KAAK,GAAGjH,MAAM,CAACkH,mBAAmB,CAAC9E,MAAM,CAACsB,SAAS,EAAGe,QAAQ,IAAI;YACvE,OAAO1E,MAAM,CAACoH,OAAO,CAAC1C,QAAQ,CAAC5D,GAAG,CAACmG,SAAS,CAAC,EAAEV,YAAY,CAAC;UAC7D,CAAC,CAAC;UAEF,IAAIc,UAAU,GAAGH,KAAK,CAACI,KAAK;UAE5B,IAAID,UAAU,GAAG,CAAC,EAAE;YACnBA,UAAU,IAAI,CAAC;;UAGhBb,YAAY,IAAI,IAAI,CAACvD,YAAY,EAAE,IAAI,CAAC,GAAG,IAAI,CAACnC,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;UAEtE,MAAMyG,GAAG,GAAGtH,MAAM,CAACuH,cAAc,CAACnF,MAAM,CAACsB,SAAS,EAAGe,QAAQ,IAAI;YAChE,OAAO1E,MAAM,CAACoH,OAAO,CAAC1C,QAAQ,CAAC5D,GAAG,CAACmG,SAAS,CAAC,EAAET,YAAY,CAAC;UAC7D,CAAC,CAAC;UAEF,IAAIiB,QAAQ,GAAGF,GAAG,CAACD,KAAK;UACxB,IAAII,SAAS,GAAGD,QAAQ;UAExB,IAAIC,SAAS,GAAG,CAAC,EAAE;YAClBA,SAAS,EAAE;;UAGZ,MAAMC,aAAa,GAAGtF,MAAM,CAACsB,SAAS,CAAC0D,UAAU,CAAC;UAClD,MAAMO,YAAY,GAAGvF,MAAM,CAACsB,SAAS,CAAC+D,SAAS,CAAC;UAEhD,IAAIG,QAA4B;UAChC,IAAIC,SAA6B;UACjC,IAAIH,aAAa,EAAE;YAClBG,SAAS,GAAGH,aAAa,CAAC7G,GAAG,CAACmG,SAAS,CAAC;;UAGzC,IAAIW,YAAY,EAAE;YACjBC,QAAQ,GAAGD,YAAY,CAAC9G,GAAG,CAACmG,SAAS,CAAC;;UAGvC,IAAIc,cAAc,GAAG,KAAK;UAC1B,IAAIF,QAAQ,IAAI,IAAI,IAAIC,SAAS,IAAI,IAAI,EAAE;YAC1C,IAAID,QAAQ,GAAGtB,YAAY,IAAIuB,SAAS,GAAGtB,YAAY,EAAE;cACxDuB,cAAc,GAAG,IAAI;;;UAIvB1F,MAAM,CAAC2F,UAAU,CAAC,gBAAgB,EAAED,cAAc,CAAC;UACnD1F,MAAM,CAAC2F,UAAU,CAAC,YAAY,EAAEX,UAAU,CAAC;UAC3ChF,MAAM,CAAC2F,UAAU,CAAC,oBAAoB,EAAE3F,MAAM,CAAC4F,iBAAiB,CAACZ,UAAU,CAAC,CAAC;UAC7EhF,MAAM,CAAC2F,UAAU,CAAC,UAAU,EAAEP,QAAQ,CAAC;UACvC,IAAI,CAACS,IAAI,CAACvC,MAAM,CAACC,IAAI,CAAC,YAAY,EAAE,MAAK;YACxCvD,MAAM,CAAC8F,oBAAoB,CAAC,oBAAoB,CAAC;UAClD,CAAC,CAAC;;MAGJ,CAAC,CAAC;;EAEJ;EAEUC,aAAaA,CAACxG,GAAW,EAAEC,GAAW,EAAEwG,SAAiB,EAAEC,WAAqB;IACzF,OAAO;MAAE1G,GAAG,EAAEA,GAAG;MAAEC,GAAG,EAAEA,GAAG;MAAE0G,IAAI,EAAE,CAAC1G,GAAG,GAAGD,GAAG,IAAIyG;IAAS,CAAE;EAC7D;EAEA;;;EAGOlF,gBAAgBA,CAAA;IACtB,OAAO,IAAI,CAACqF,iBAAiB;EAC9B;EAEUC,WAAWA,CAAC7G,GAAW,EAAEC,GAAW;IAC7C,IAAIE,aAAa,GAAG,IAAI,CAACN,UAAU,CAAC,eAAe,CAAC;IAEpD,IAAI,CAACM,aAAa,EAAE;MACnBA,aAAa,GAAG,IAAI,CAACjB,GAAG,CAAC,cAAc,CAAC;;IAGzC,IAAI4H,EAAE,GAAG3G,aAAa,CAACU,QAAQ,GAAGV,aAAa,CAACW,KAAK;IACrD,IAAI,CAAC4D,YAAY,CAACoC,EAAE,CAAC,GAAG9G,GAAG;IAC3B,IAAI,CAACwE,YAAY,CAACsC,EAAE,CAAC,GAAG7G,GAAG;EAC5B;EAEU8G,KAAKA,CAAClG,QAAkB;IACjC,IAAIA,QAAQ,IAAI,OAAO,IAAIA,QAAQ,IAAI,MAAM,IAAIA,QAAQ,IAAI,KAAK,EAAE;MACnE,OAAO,IAAI;;IAEZ,OAAO,IAAI;EACZ;EAEUmG,iBAAiBA,CAAC5H,QAAuB;;IAClD,IAAI6H,iBAA4C;IAChD,IAAInG,KAAK,GAAG1B,QAAQ,CAAC0B,KAAK;IAC1B,IAAID,QAAQ,GAAGzB,QAAQ,CAACyB,QAAQ;IAChC,IAAIC,KAAK,GAAG,CAAC,EAAE;MACd,IAAIA,KAAK,IAAI,EAAE,EAAE;QAChBA,KAAK,GAAG,CAAC;OACT,MACI,IAAIA,KAAK,IAAI,EAAE,EAAE;QACrBA,KAAK,GAAG,CAAC;OACT,MACI,IAAIA,KAAK,IAAI,EAAE,EAAE;QACrBA,KAAK,GAAG,CAAC;OACT,MACI,IAAIA,KAAK,IAAI,CAAC,EAAE;QACpBA,KAAK,GAAG,CAAC;OACT,MACI,IAAIA,KAAK,IAAI,EAAE,EAAE;QACrBA,KAAK,GAAG,EAAE;OACV,MACI,IAAIA,KAAK,GAAG,EAAE,EAAE;QACpBA,KAAK,GAAG,CAAC;;MAEVmG,iBAAiB,GAAG;QAAEpG,QAAQ,EAAEA,QAAQ;QAAEC,KAAK,EAAEA;MAAK,CAAE;;IAEzD,IAAID,QAAQ,IAAI,MAAM,EAAE;MACvB,IAAI,EAAAqG,EAAA,OAAI,CAACrH,UAAU,CAAC,cAAc,CAAC,cAAAqH,EAAA,uBAAAA,EAAA,CAAErG,QAAQ,KAAI,MAAM,EAAE;QACxDoG,iBAAiB,GAAG;UAAEpG,QAAQ,EAAE,KAAK;UAAEC,KAAK,EAAE;QAAC,CAAE;OACjD,MACI;QACJmG,iBAAiB,GAAG;UAAEpG,QAAQ,EAAE,MAAM;UAAEC,KAAK,EAAE;QAAC,CAAE;;;IAGpD,OAAOmG,iBAAiB;EACzB;EAEUE,iBAAiBA,CAAA;IAC1B,MAAMnH,GAAG,GAAG,IAAI,CAACH,UAAU,CAAC,KAAK,CAAC;IAClC,MAAMI,GAAG,GAAG,IAAI,CAACJ,UAAU,CAAC,KAAK,CAAC;IAElC,IAAI3B,KAAK,CAACgC,QAAQ,CAACF,GAAG,CAAC,IAAI9B,KAAK,CAACgC,QAAQ,CAACD,GAAG,CAAC,EAAE;MAC/C,MAAMqG,IAAI,GAAG,IAAI,CAACpD,KAAK;MACvB,MAAMyB,YAAY,GAAGhF,IAAI,CAACC,KAAK,CAAC,IAAI,CAACC,UAAU,CAAC,cAAc,CAAY,CAAC;MAC3E,MAAM+E,YAAY,GAAGjF,IAAI,CAACC,KAAK,CAAC,IAAI,CAACC,UAAU,CAAC,cAAc,CAAY,CAAC;MAC3E,MAAMuH,QAAQ,GAAG,IAAI,CAAClI,GAAG,CAAC,UAAU,CAAC;MACrC,MAAMyB,YAAY,GAAG,IAAI,CAACd,UAAU,CAAC,cAAc,CAAC;MAEpD,IAAIyD,KAAK,GAAGqB,YAAY;MACxB,IAAI0C,CAAC,GAAG,CAAC;MAET,MAAMjG,SAAS,GAAG,IAAI,CAAClC,GAAG,CAAC,eAAe,CAAE;MAC5C,IAAIoI,YAAY,GAAG9I,KAAK,CAAC6F,cAAc,CAAC,CAAC,EAAEO,YAAY,GAAGD,YAAY,EAAEyC,QAAQ,CAACX,SAAS,EAAE,EAAErF,SAAS,CAAC;MAExG,IAAI5C,KAAK,CAACe,mBAAmB,CAAC+H,YAAY,CAAC,GAAG,IAAI,CAACjG,YAAY,EAAE,EAAE;QAClEiG,YAAY,GAAA3I,MAAA,CAAA2F,MAAA,KAAQ3D,YAAY,CAAE;;MAGnC,MAAMY,gBAAgB,GAAG/C,KAAK,CAACe,mBAAmB,CAAC+H,YAAY,CAAC;MAChE,IAAI,CAACV,iBAAiB,GAAGrF,gBAAgB;MAEzC,MAAMgG,YAAY,GAAG/I,KAAK,CAACgJ,WAAW,CAACF,YAAY,CAACzG,QAAQ,CAAC;MAC7D,MAAM4G,GAAG,GAAGnB,IAAI,CAACmB,GAAG;MACpB,MAAMC,QAAQ,GAAGpB,IAAI,CAACoB,QAAQ;MAE9B;MACApE,KAAK,GAAG9E,KAAK,CAACyE,IAAI,CAAC0B,YAAY,GAAGpD,gBAAgB,EAAE+F,YAAY,CAACzG,QAAQ,EAAEyG,YAAY,CAACxG,KAAK,EAAEwF,IAAI,EAAEtG,GAAG,CAAC;MACzG,IAAI2H,aAAa,GAAGrE,KAAK,GAAG/B,gBAAgB;MAC5C,IAAIqG,MAA2C;MAC/C,MAAMC,OAAO,GAAG,IAAI,CAAC3I,GAAG,CAAC,aAAa,CAAE;MAExC,IAAI,CAACG,aAAa,CAAC,cAAc,EAAEiI,YAAY,CAAC;MAEhD,MAAMQ,kBAAkB,GAAGV,QAAQ,CAAClI,GAAG,CAAC,oBAAoB,CAAC;MAC7D,MAAM6I,gBAAgB,GAAGX,QAAQ,CAAClI,GAAG,CAAC,kBAAkB,EAAE4I,kBAAkB,CAAC;MAE7E,IAAIb,iBAA4C;MAChD,IAAIe,aAAa,GAAG,CAAC;MAErB,IAAID,gBAAgB,EAAE;QACrBd,iBAAiB,GAAG,IAAI,CAACD,iBAAiB,CAACM,YAAY,CAAC;QACxDU,aAAa,GAAGxJ,KAAK,CAACe,mBAAmB,CAAC0H,iBAAiB,CAAC;;MAG7D,IAAIgB,CAAC,GAAG,CAAC;MACT,OAAO3E,KAAK,GAAGsB,YAAY,GAAGrD,gBAAgB,EAAE;QAC/C,IAAIuB,QAA6C;QACjD,IAAI,IAAI,CAACf,SAAS,CAACmG,MAAM,GAAGb,CAAC,GAAG,CAAC,EAAE;UAClCvE,QAAQ,GAAG,IAAI9E,QAAQ,CAAC,IAAI,EAAEiD,SAAS,EAAE,EAAE,CAAC;UAC5C,IAAI,CAACkH,UAAU,CAAC3G,IAAI,CAACsB,QAAQ,CAAC;UAC9B,IAAI,CAACsF,eAAe,CAACtF,QAAQ,CAAC;SAC9B,MACI;UACJA,QAAQ,GAAG,IAAI,CAACf,SAAS,CAACsF,CAAC,CAAC;;QAG7B,IAAI,CAACgB,aAAa,CAACvF,QAAQ,EAAE,EAAE,CAAC;QAEhC,IAAI,CAACwF,eAAe,CAACxF,QAAQ,EAAE,IAAI,CAAC;QAEpCA,QAAQ,CAACzC,MAAM,CAAC,OAAO,EAAEiD,KAAK,CAAC;QAC/BR,QAAQ,CAACzC,MAAM,CAAC,eAAe,EAAEY,SAAS,CAAC;QAE3C,IAAIsH,QAAQ,GAAGjF,KAAK,GAAG9E,KAAK,CAACkE,WAAW,CAAC4E,YAAY,CAACzG,QAAQ,EAAEyG,YAAY,CAACxG,KAAK,GAAG,IAAI,CAACiG,KAAK,CAACO,YAAY,CAACzG,QAAQ,CAAC,CAAC;QACvH;QACA0H,QAAQ,GAAG/J,KAAK,CAACyE,IAAI,CAACsF,QAAQ,EAAEjB,YAAY,CAACzG,QAAQ,EAAE,CAAC,EAAEyF,IAAI,CAAC;QAE/DxD,QAAQ,CAACzC,MAAM,CAAC,UAAU,EAAEkI,QAAQ,CAAC;QAErC,IAAIC,IAAI,GAAG,IAAIC,IAAI,CAACnF,KAAK,CAAC;QAE1BsE,MAAM,GAAGC,OAAO,CAACP,YAAY,CAACzG,QAAQ,CAAC;QACvC,IAAI0G,YAAY,IAAI,IAAI,CAACrI,GAAG,CAAC,gBAAgB,CAAC,IAAIhB,KAAK,CAACgC,QAAQ,CAACyH,aAAa,CAAC,EAAE;UAChF,IAAIL,YAAY,CAACzG,QAAQ,IAAI,MAAM,EAAE;YACpC,IAAIrC,KAAK,CAACkK,WAAW,CAACpF,KAAK,EAAEqE,aAAa,EAAEJ,YAAY,EAAEE,GAAG,EAAEC,QAAQ,CAAC,EAAE;cACzEE,MAAM,GAAG,IAAI,CAAC1I,GAAG,CAAC,yBAAyB,CAAE,CAACoI,YAAY,CAACzG,QAAQ,CAAC;;;;QAKvE,MAAM8H,KAAK,GAAG7F,QAAQ,CAAC5D,GAAG,CAAC,OAAO,CAAC;QACnC,IAAIyJ,KAAK,EAAE;UACVA,KAAK,CAACpF,GAAG,CAAC,MAAM,EAAE+C,IAAI,CAACsC,aAAa,CAAChB,MAAM,CAACY,IAAI,EAAEZ,MAAO,CAAC,CAAC;;QAG5D,IAAI9G,KAAK,GAAGwG,YAAY,CAACxG,KAAK;QAC9B;QACA,IAAIwG,YAAY,CAACzG,QAAQ,IAAI,MAAM,EAAE;UACpCiC,QAAQ,CAACzC,MAAM,CAAC,eAAe,EAAEiD,KAAK,CAAC;;QAGxC,IAAIyE,gBAAgB,EAAE;UACrBjH,KAAK,GAAG,CAAC;UACT,IAAID,QAAQ,GAAGyG,YAAY,CAACzG,QAAQ;UACpC,IAAIA,QAAQ,IAAI,MAAM,EAAE;YACvBA,QAAQ,GAAG,KAAK;;UAGjB,IAAIgI,aAAa,GAAGvF,KAAK,GAAG9E,KAAK,CAACkE,WAAW,CAAC7B,QAAQ,EAAE,IAAI,CAACkG,KAAK,CAAClG,QAAQ,CAAC,CAAC;UAC7E;UACAgI,aAAa,GAAGrK,KAAK,CAACyE,IAAI,CAAC4F,aAAa,EAAEhI,QAAQ,EAAE,CAAC,EAAEyF,IAAI,CAAC;UAC5DxD,QAAQ,CAACzC,MAAM,CAAC,eAAe,EAAEwI,aAAa,CAAC;;QAGhD,IAAI,CAACC,gBAAgB,CAAChG,QAAQ,EAAEhC,KAAK,CAAC;QAEtC6G,aAAa,GAAGrE,KAAK;QACrBA,KAAK,GAAGiF,QAAQ;QAEhB;QACA,IAAItB,iBAAiB,EAAE;UACtB,MAAM8B,aAAa,GAAG9B,iBAAiB,CAACpG,QAAQ;UAChD,MAAMmI,UAAU,GAAG/B,iBAAiB,CAACnG,KAAK;UAC1C,MAAMmI,GAAG,GAAG,IAAI,CAAClC,KAAK,CAACgC,aAAa,CAAC;UAErC;UACA,IAAIG,UAAU,GAAG1K,KAAK,CAACyE,IAAI,CAAC0E,aAAa,GAAGK,aAAa,GAAGiB,GAAG,EAAEF,aAAa,EAAEC,UAAU,EAAE1C,IAAI,EAAEqB,aAAa,CAAC;UAEhH,IAAIwB,kBAAsC;UAC1C,IAAIC,YAAY,GAAG,IAAI,CAAClK,GAAG,CAAC,kBAAkB,EAAE,IAAI,CAACA,GAAG,CAAC,aAAa,CAAC,CAAE;UAEzE,OAAOgK,UAAU,GAAG5F,KAAK,GAAG,IAAI,GAAG0E,aAAa,EAAE;YACjD,IAAIqB,aAAkD;YACtD,IAAI,IAAI,CAACC,cAAc,CAACpB,MAAM,GAAGD,CAAC,GAAG,CAAC,EAAE;cACvCoB,aAAa,GAAG,IAAIrL,QAAQ,CAAC,IAAI,EAAEiD,SAAS,EAAE,EAAE,CAAC;cACjD,IAAI,CAACqI,cAAc,CAAC9H,IAAI,CAAC6H,aAAa,CAAC;cACvC,IAAI,CAACjB,eAAe,CAACiB,aAAa,CAAC;aACnC,MACI;cACJA,aAAa,GAAG,IAAI,CAACC,cAAc,CAACrB,CAAC,CAAC;;YAGvC,IAAI,CAACI,aAAa,CAACgB,aAAa,EAAE,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC;YAElD,IAAI,CAACf,eAAe,CAACe,aAAa,EAAE,IAAI,CAAC;YAEzCA,aAAa,CAAChJ,MAAM,CAAC,OAAO,EAAE6I,UAAU,CAAC;YAEzC,IAAIK,aAAa,GAAGL,UAAU,GAAG1K,KAAK,CAACkE,WAAW,CAACqG,aAAa,EAAEC,UAAU,GAAGC,GAAG,CAAC;YACnF;YACAM,aAAa,GAAG/K,KAAK,CAACyE,IAAI,CAACsG,aAAa,EAAER,aAAa,EAAE,CAAC,EAAEzC,IAAI,CAAC;YAEjE+C,aAAa,CAAChJ,MAAM,CAAC,UAAU,EAAEkJ,aAAa,CAAC;YAE/C,IAAIf,IAAI,GAAG,IAAIC,IAAI,CAACS,UAAU,CAAC;YAE/BtB,MAAM,GAAGwB,YAAY,CAACL,aAAa,CAAC;YAEpC,MAAMS,UAAU,GAAGH,aAAa,CAACnK,GAAG,CAAC,OAAO,CAAC;YAE7C,IAAIsK,UAAU,EAAE;cACf,IAAI1B,kBAAkB,EAAE;gBACvB0B,UAAU,CAACjG,GAAG,CAAC,MAAM,EAAE+C,IAAI,CAACsC,aAAa,CAAChB,MAAM,CAACY,IAAI,EAAEZ,MAAO,CAAC,CAAC;eAChE,MACI;gBACJ4B,UAAU,CAACpD,UAAU,CAAC,SAAS,EAAE,KAAK,CAAC;;;YAIzC,IAAI,CAAC0C,gBAAgB,CAACO,aAAa,EAAE,CAAC,CAAC;YAEvC,IAAIH,UAAU,IAAIC,kBAAkB,EAAE;cACrC;;YAGDA,kBAAkB,GAAGD,UAAU;YAC/BA,UAAU,GAAGK,aAAa;YAC1BtB,CAAC,EAAE;;;QAIL,IAAI3E,KAAK,IAAIqE,aAAa,EAAE;UAC3B;;QAGDN,CAAC,EAAE;;MAGJ,KAAK,IAAIoC,CAAC,GAAGpC,CAAC,EAAEoC,CAAC,GAAG,IAAI,CAAC1H,SAAS,CAACmG,MAAM,EAAEuB,CAAC,EAAE,EAAE;QAC/C,IAAI,CAACnB,eAAe,CAAC,IAAI,CAACvG,SAAS,CAAC0H,CAAC,CAAC,EAAE,KAAK,CAAC;;MAG/C,KAAK,IAAIA,CAAC,GAAGxB,CAAC,EAAEwB,CAAC,GAAG,IAAI,CAACH,cAAc,CAACpB,MAAM,EAAEuB,CAAC,EAAE,EAAE;QACpD,IAAI,CAACnB,eAAe,CAAC,IAAI,CAACgB,cAAc,CAACG,CAAC,CAAC,EAAE,KAAK,CAAC;;MAGpDpL,MAAM,CAACmC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAGA,MAAM,IAAI;QACnC,IAAIA,MAAM,CAACiJ,MAAM,EAAE;UAClBjJ,MAAM,CAACkJ,cAAc,EAAE;;MAEzB,CAAC,CAAC;;IAGH,IAAI,CAACC,YAAY,EAAE;EACpB;EAEUC,aAAaA,CAACvE,KAAa,EAAEK,GAAW;IACjD,IAAI,CAACtG,aAAa,CAAC,mBAAmB,EAAE,IAAI,CAACyK,eAAe,CAACxE,KAAK,CAAC,CAAC;IACpE,IAAI,CAACjG,aAAa,CAAC,mBAAmB,EAAE,IAAI,CAACyK,eAAe,CAACnE,GAAG,CAAC,CAAC;EACnE;EAEUoE,SAASA,CAAA;IAClB,IAAI,CAACC,YAAY,GAAG,IAAI,CAAC3I,YAAY,EAAE,GAAG,CAAC;EAC5C;EAEU4I,OAAOA,CAACjK,GAAW;IAC5B,MAAMW,YAAY,GAAG,IAAI,CAACd,UAAU,CAAC,cAAc,CAAC;IACpD,MAAMgB,QAAQ,GAAGF,YAAY,CAACE,QAAQ;IACtC;IACA,IAAIqJ,SAAS,GAAG1L,KAAK,CAACyE,IAAI,CAACjD,GAAG,EAAEa,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACoC,KAAK,CAAC;IAEzE,IAAIiH,OAAO,GAAGD,SAAS,GAAG1L,KAAK,CAACkE,WAAW,CAAC7B,QAAQ,EAAEF,YAAY,CAACG,KAAK,GAAG,IAAI,CAACiG,KAAK,CAAClG,QAAQ,CAAC,CAAC;IAChG;IACAsJ,OAAO,GAAG3L,KAAK,CAACyE,IAAI,CAACkH,OAAO,EAAEtJ,QAAQ,EAAE,CAAC,EAAE,IAAI,CAACqC,KAAK,CAAC;IACtD,OAAOgH,SAAS,GAAG,CAACC,OAAO,GAAGD,SAAS,IAAI,IAAI,CAAChL,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;EACxE;EAEUkL,OAAOA,CAACnK,GAAW;IAC5B,MAAMU,YAAY,GAAG,IAAI,CAACd,UAAU,CAAC,cAAc,CAAC;IACpD,MAAMgB,QAAQ,GAAGF,YAAY,CAACE,QAAQ;IACtC;IACA,IAAIqJ,SAAS,GAAG1L,KAAK,CAACyE,IAAI,CAAChD,GAAG,EAAEY,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACoC,KAAK,CAAC;IACzE,IAAIiH,OAAO,GAAGD,SAAS,GAAG1L,KAAK,CAACkE,WAAW,CAAC7B,QAAQ,EAAEF,YAAY,CAACG,KAAK,GAAG,IAAI,CAACiG,KAAK,CAAClG,QAAQ,CAAC,CAAC;IAChG;IACAsJ,OAAO,GAAG3L,KAAK,CAACyE,IAAI,CAACkH,OAAO,EAAEtJ,QAAQ,EAAE,CAAC,EAAE,IAAI,CAACqC,KAAK,CAAC;IAEtD,OAAOgH,SAAS,GAAG,CAACC,OAAO,GAAGD,SAAS,IAAI,IAAI,CAAChL,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC;EACtE;EAEUmL,YAAYA,CAACC,KAAa,EAAEC,OAAiB,GAEvD;EAEA;;;;;EAKOlJ,YAAYA,CAAA;IAClB,OAAO,IAAI,CAAC/B,aAAa;IACzB;EACD;EAEA;;;;;EAKOQ,gBAAgBA,CAAA;IACtB,OAAOtB,KAAK,CAACe,mBAAmB,CAAC,IAAI,CAACL,GAAG,CAAC,cAAc,CAAC,CAAC;EAC3D;EAEA;;;EAGOsL,qBAAqBA,CAAC1H,QAAqC,EAAEnB,MAAqB;IACxF,MAAMhB,YAAY,GAAG,IAAI,CAACd,UAAU,CAAC,cAAc,CAAC;IAEpD,IAAI,CAACiD,QAAQ,CAAC2H,IAAI,EAAE;MACnB3H,QAAQ,CAAC2H,IAAI,GAAG,EAAE;;IAEnB,IAAI,CAAC3H,QAAQ,CAAC4H,KAAK,EAAE;MACpB5H,QAAQ,CAAC4H,KAAK,GAAG,EAAE;;IAGpBrM,MAAM,CAACmC,IAAI,CAACmB,MAAM,EAAGc,KAAK,IAAI;MAC7B,IAAIa,KAAK,GAAGR,QAAQ,CAAC5D,GAAG,CAACuD,KAAY,CAAC;MACtC,IAAIvE,KAAK,CAACgC,QAAQ,CAACoD,KAAK,CAAC,EAAE;QAC1B,IAAI4G,SAAS,GAAGpH,QAAQ,CAAC2H,IAAK,CAAChI,KAAK,CAAC;QACrC,IAAI0H,OAAO,GAAGrH,QAAQ,CAAC4H,KAAM,CAACjI,KAAK,CAAC;QACpC;QACA;QACA,IAAIa,KAAK,IAAI4G,SAAS,IAAI5G,KAAK,IAAI6G,OAAO,EAAE,C,CAE3C,MACI;UACJ,MAAMtJ,QAAQ,GAAGF,YAAY,CAACE,QAAQ;UACtC,MAAMC,KAAK,GAAGH,YAAY,CAACG,KAAK;UAChC;UACAoJ,SAAS,GAAG1L,KAAK,CAACyE,IAAI,CAACK,KAAK,EAAEzC,QAAQ,EAAEC,KAAK,EAAE,IAAI,CAACoC,KAAK,CAAC;UAC1DiH,OAAO,GAAGD,SAAS,GAAG1L,KAAK,CAACkE,WAAW,CAAC7B,QAAQ,EAAEC,KAAK,GAAG,IAAI,CAACiG,KAAK,CAAClG,QAAQ,CAAC,CAAC;UAC/E;UACAsJ,OAAO,GAAG3L,KAAK,CAACyE,IAAI,CAACkH,OAAO,EAAEtJ,QAAQ,EAAE,CAAC,EAAE,IAAI,CAACqC,KAAK,CAAC;UAEtDJ,QAAQ,CAAC2H,IAAK,CAAChI,KAAK,CAAC,GAAGyH,SAAS;UACjCpH,QAAQ,CAAC4H,KAAM,CAACjI,KAAK,CAAC,GAAG0H,OAAO;;QAGjC,IAAI,CAACE,YAAY,CAACH,SAAS,EAAEpH,QAAQ,CAAC6H,SAAqB,CAAC;;IAE9D,CAAC,CAAC;EACH;EAEUC,gBAAgBA,CAAA;IACzB;EAAA;EAGD;;;EAGOC,oBAAoBA,CAAC/H,QAAqC,EAAEL,KAAa,EAAEqI,YAAoB,EAAEC,YAAoB;IAE3H,IAAIC,SAAS;IACb,IAAIC,UAAU;IAEd,IAAInI,QAAQ,CAAC2H,IAAI,IAAI3H,QAAQ,CAAC4H,KAAK,EAAE;MACpCM,SAAS,GAAGlI,QAAQ,CAAC2H,IAAI,CAAChI,KAAK,CAAC;MAChCwI,UAAU,GAAGnI,QAAQ,CAAC4H,KAAK,CAACjI,KAAK,CAAC;KAClC,MACI;MACJuI,SAAS,GAAGlI,QAAQ,CAAC5D,GAAG,CAACuD,KAAY,CAAC;MACtCwI,UAAU,GAAGD,SAAS;;IAGvB,IAAI1H,KAAK,GAAG0H,SAAS,GAAG,CAACC,UAAU,GAAGD,SAAS,IAAIF,YAAY;IAE/DxH,KAAK,GAAG,IAAI,CAAC4H,UAAU,GAAG,CAAC5H,KAAK,GAAG,IAAI,CAAC4H,UAAU,IAAIH,YAAY;IAElE,OAAO,IAAI,CAACI,eAAe,CAAC7H,KAAK,CAAC;EACnC;EAEA;;;EAGO8H,sBAAsBA,CAACtI,QAAqC,EAAEL,KAAa,EAAEqI,YAAoB,EAAEC,YAAoB;IAC7H,OAAO,IAAI,CAACjM,SAAS,CAACsI,QAAQ,CAACiE,oBAAoB,CAAC,IAAI,CAACR,oBAAoB,CAAC/H,QAAQ,EAAEL,KAAK,EAAEqI,YAAY,EAAEC,YAAY,CAAC,CAAC;EAC5H;EAEA;;;EAGOO,oBAAoBA,CAACxI,QAAqC,EAAEL,KAAa,EAAEqI,YAAoB,EAAEC,YAAoB;IAC3H,IAAIC,SAAS;IACb,IAAIC,UAAU;IAEd,IAAInI,QAAQ,CAAC2H,IAAI,IAAI3H,QAAQ,CAAC4H,KAAK,EAAE;MACpCM,SAAS,GAAGlI,QAAQ,CAAC2H,IAAI,CAAChI,KAAK,CAAC;MAChCwI,UAAU,GAAGnI,QAAQ,CAAC4H,KAAK,CAACjI,KAAK,CAAC;KAClC,MACI;MACJuI,SAAS,GAAGlI,QAAQ,CAAC5D,GAAG,CAACuD,KAAY,CAAC;MACtCwI,UAAU,GAAGD,SAAS;;IAGvB,IAAI1H,KAAK,GAAG0H,SAAS,GAAG,CAACC,UAAU,GAAGD,SAAS,IAAIF,YAAY;IAE/DxH,KAAK,GAAG,IAAI,CAAC4H,UAAU,GAAG,CAAC5H,KAAK,GAAG,IAAI,CAAC4H,UAAU,IAAIH,YAAY;IAClE,OAAO,IAAI,CAACI,eAAe,CAAC7H,KAAK,CAAC;EACnC;EAEA;;;EAGOiI,sBAAsBA,CAACzI,QAAqC,EAAEL,KAAa,EAAEqI,YAAoB,EAAEC,YAAoB;IAC7H,OAAO,IAAI,CAACjM,SAAS,CAACsI,QAAQ,CAACiE,oBAAoB,CAAC,IAAI,CAACC,oBAAoB,CAACxI,QAAQ,EAAEL,KAAK,EAAEqI,YAAY,EAAEC,YAAY,CAAC,CAAC;EAC5H;EAEA;;;EAGOS,iBAAiBA,CAACC,QAAgB,EAAEC,QAAgB;IAC1D,IAAIpI,KAAK,GAAG,IAAI,CAACwG,eAAe,CAAC2B,QAAQ,CAAC;IAC1CnI,KAAK,GAAGA,KAAK,GAAG,CAACoI,QAAQ,GAAG,GAAG,IAAI,IAAI,CAACrK,YAAY,EAAE;IAEtD,IAAIV,YAAY,GAAG,IAAI,CAACd,UAAU,CAAC,cAAc,CAAC;IAClD,IAAI,CAAC3B,KAAK,CAACyN,KAAK,CAACrI,KAAK,CAAC,EAAE;MACxB,MAAMsI,QAAQ,GAAG,IAAI,CAAC1I,KAAK,CAAC2I,MAAM,CAACC,cAAc;MACjD,MAAMjL,QAAQ,GAAGF,YAAY,CAACE,QAAQ;MACtC,MAAM4G,GAAG,GAAG,IAAI,CAACvE,KAAK,CAACuE,GAAG;MAC1B,MAAMC,QAAQ,GAAG,IAAI,CAACxE,KAAK,CAACwE,QAAQ;MACpC,MAAM5G,KAAK,GAAGH,YAAY,CAACG,KAAK;MAEhC;MACAwC,KAAK,GAAG9E,KAAK,CAACyE,IAAI,CAACK,KAAK,EAAEzC,QAAQ,EAAEC,KAAK,EAAE,IAAI,CAACoC,KAAK,EAAE,IAAI,CAACrD,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;MAEjF,IAAIuE,QAAQ,GAAG5F,KAAK,CAACuN,uBAAuB,CAACpL,YAAY,EAAE,IAAI8H,IAAI,CAACnF,KAAK,CAAC,EAAEsI,QAAQ,EAAEnE,GAAG,EAAEC,QAAQ,CAAC;MACpG,IAAIA,QAAQ,EAAE;QACb;QACApE,KAAK,GAAG9E,KAAK,CAACyE,IAAI,CAACK,KAAK,GAAG,IAAI,CAACjC,YAAY,EAAE,GAAG,IAAI,EAAER,QAAQ,EAAEC,KAAK,EAAE,IAAI,CAACoC,KAAK,EAAE,IAAI,CAACrD,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAC9GuE,QAAQ,GAAG5F,KAAK,CAACuN,uBAAuB,CAACpL,YAAY,EAAE,IAAI8H,IAAI,CAACnF,KAAK,GAAGc,QAAQ,GAAGsH,QAAQ,CAAC,EAAEE,QAAQ,EAAEnE,GAAG,EAAEC,QAAQ,CAAC;;MAGvH,OAAO,IAAI,CAACyD,eAAe,CAAC7H,KAAK,GAAGc,QAAQ,GAAGsH,QAAQ,CAAC;;IAEzD,OAAOM,GAAG;EACX;EAEA;;;;;;;;;;EAUOC,cAAcA,CAACR,QAAgB,EAAES,cAAwB;IAC/D;IACA,IAAI,IAAI,CAACrM,UAAU,CAAC,KAAK,CAAC,IAAI,IAAI,EAAE;MACnC,IAAI+H,MAAM,GAAG,IAAI,CAAC1I,GAAG,CAAC,oBAAoB,CAAE,CAAC,IAAI,CAACW,UAAU,CAAC,cAAc,CAAC,CAACgB,QAAQ,CAAC;MACtF,IAAIyC,KAAK,GAAG,IAAI,CAACwG,eAAe,CAAC2B,QAAQ,CAAC;MAC1C,IAAIvN,KAAK,CAACgC,QAAQ,CAACoD,KAAK,CAAC,EAAE;QAC1B,IAAIkF,IAAI,GAAG,IAAIC,IAAI,CAACnF,KAAK,CAAC;QAE1B,IAAI3C,YAAY,GAAG,IAAI,CAACd,UAAU,CAAC,cAAc,CAAC;QAClD,IAAIuE,QAAQ,GAAG5F,KAAK,CAACuN,uBAAuB,CAACpL,YAAY,EAAE6H,IAAI,EAAE,IAAI,CAACtF,KAAK,CAAC2I,MAAM,CAACC,cAAc,EAAE,IAAI,CAAC5I,KAAK,CAACuE,GAAG,EAAE,IAAI,CAACvE,KAAK,CAACwE,QAAQ,CAAC;QAEvI,IAAIwE,cAAc,KAAK,KAAK,EAAE;UAC7B1D,IAAI,GAAG,IAAIC,IAAI,CAACnF,KAAK,GAAG,IAAI,CAACpE,GAAG,CAAC,uBAAuB,EAAE,CAAC,IAAI,CAACA,GAAG,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAAC,GAAGkF,QAAQ,CAAC;;QAGzG,OAAO,IAAI,CAAClB,KAAK,CAAC0F,aAAa,CAAChB,MAAM,CAACY,IAAI,EAAE,IAAI,CAACtJ,GAAG,CAAC,mBAAmB,EAAE0I,MAAM,CAAC,CAAC;;;IAIrF,OAAO,EAAE;EACV;EAEA;;;;;;;EAOOuE,aAAaA,CAAC1L,MAAgB,EAAEgL,QAAgB,EAAEC,QAAiB,EAAEU,IAAc;IACzF,IAAI/G,SAAS,GAAS,IAAI,CAACxF,UAAU,CAAC,MAAM,CAAE,GAAG,IAAI,CAACX,GAAG,CAAC,UAAU,CAAC,CAACW,UAAU,CAAC,QAAQ,CAAG;IAC5F,IAAIyD,KAAK,GAAG,IAAI,CAACwG,eAAe,CAAC2B,QAAQ,CAAC;IAE1C,IAAIC,QAAQ,IAAI,IAAI,EAAE;MACrBA,QAAQ,GAAG,GAAG;;IAGfpI,KAAK,GAAGA,KAAK,GAAG,CAACoI,QAAQ,GAAG,GAAG,IAAI,IAAI,CAACrK,YAAY,EAAE;IAEtD,MAAMgL,MAAM,GAAGhO,MAAM,CAACuH,cAAc,CAACnF,MAAM,CAACsB,SAAS,EAAGe,QAAQ,IAAI;MACnE,IAAIwJ,OAAO,GAAG,CAAC;MACf,IAAIxJ,QAAQ,CAAC2H,IAAI,EAAE;QAClB6B,OAAO,GAAGxJ,QAAQ,CAAC2H,IAAI,CAACpF,SAAS,CAAC;;MAGnC,OAAOjH,MAAM,CAACoH,OAAO,CAAC8G,OAAO,EAAEhJ,KAAK,CAAC;IACtC,CAAC,CAAC;IAEF,IAAI8I,IAAI,IAAI3L,MAAM,CAACvB,GAAG,CAAC,aAAa,CAAC,EAAE;MACtC,IAAIqN,KAAK,GAAG9L,MAAM,CAACsB,SAAS,CAACsK,MAAM,CAAC3G,KAAK,GAAG,CAAC,CAAC;MAC9C,IAAI8G,MAAM,GAAG/L,MAAM,CAACsB,SAAS,CAACsK,MAAM,CAAC3G,KAAK,CAAC;MAE3C,IAAI6G,KAAK,IAAIC,MAAM,EAAE;QACpB,IAAID,KAAK,CAAC9B,IAAI,IAAI+B,MAAM,CAAC9B,KAAK,EAAE;UAC/B,IAAID,IAAI,GAAG8B,KAAK,CAAC9B,IAAI,CAACpF,SAAS,CAAC;UAChC,IAAIqF,KAAK,GAAG8B,MAAM,CAAC9B,KAAK,CAACrF,SAAS,CAAC;UAEnC,IAAI1F,IAAI,CAACgE,GAAG,CAACL,KAAK,GAAGmH,IAAI,CAAC,GAAG9K,IAAI,CAACgE,GAAG,CAACL,KAAK,GAAGoH,KAAK,CAAC,EAAE;YACrD,OAAO8B,MAAM;;;;MAKhB,IAAID,KAAK,EAAE;QACV,OAAOA,KAAK;;MAGb,IAAIC,MAAM,EAAE;QACX,OAAOA,MAAM;;KAEd,MACI;MACJ,MAAM1J,QAAQ,GAAGrC,MAAM,CAACsB,SAAS,CAACsK,MAAM,CAAC3G,KAAK,GAAG,CAAC,CAAC;MAEnD,IAAI5C,QAAQ,EAAE;QACb,IAAIA,QAAQ,CAAC2H,IAAI,IAAI3H,QAAQ,CAAC4H,KAAK,EAAE;UACpC,IAAID,IAAI,GAAG3H,QAAQ,CAAC2H,IAAI,CAACpF,SAAS,CAAC;UACnC,IAAIqF,KAAK,GAAG5H,QAAQ,CAAC4H,KAAK,CAACrF,SAAS,CAAC;UAErC,IAAI/B,KAAK,IAAImH,IAAI,IAAInH,KAAK,IAAIoH,KAAK,EAAE;YACpC,OAAO5H,QAAQ;;;;;EAKpB;EAEA;;;EAGO2J,SAASA,CAAC3J,QAAqC,EAAE4J,QAAqC,EAAEC,YAAoB,EAAEtH,SAAiB;IACrI,MAAMuH,MAAM,GAAG9J,QAAQ,CAAC5D,GAAG,CAACmG,SAAgB,CAAC;IAC7C,MAAMwH,MAAM,GAAGH,QAAQ,CAACxN,GAAG,CAACmG,SAAgB,CAAC;IAE7C,IAAIwH,MAAM,GAAGD,MAAM,GAAG,IAAI,CAACvL,YAAY,EAAE,GAAGsL,YAAY,EAAE;MACzD,OAAO,IAAI;;IAEZ,OAAO,KAAK;EACb;EAEA;;;;;;;;;EASOG,WAAWA,CAACxH,KAAW,EAAEK,GAAS,EAAEvB,QAAiB;IAC3D,IAAI,CAAC2I,YAAY,CAACzH,KAAK,CAAC0H,OAAO,EAAE,EAAErH,GAAG,CAACqH,OAAO,EAAE,EAAE5I,QAAQ,CAAC;EAC5D;EAEA;;;;;;;;;EASO2I,YAAYA,CAACzH,KAAa,EAAEK,GAAW,EAAEvB,QAAiB;IAChE,MAAMpE,GAAG,GAAG,IAAI,CAACH,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC;IAC1C,MAAMI,GAAG,GAAG,IAAI,CAACJ,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC;IAC1C,IAAI,IAAI,CAACA,UAAU,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,IAAI,CAACA,UAAU,CAAC,KAAK,CAAC,IAAI,IAAI,EAAE;MACrE,IAAI,IAAI,CAACX,GAAG,CAAC,WAAW,CAAC,EAAE;QAC1B,MAAM+N,mBAAmB,GAAG,IAAI,CAAC9I,gBAAgB,CAACwB,GAAG,GAAGL,KAAK,CAAC;QAC9D,MAAM3E,YAAY,GAAG,IAAI,CAACzB,GAAG,CAAC,cAAc,CAAC;QAE7C,IAAIgO,OAAO,GAAG,IAAI,CAACzI,cAAc,CAAC9D,YAAY,CAAC;QAC/C,IAAIwM,OAAO,GAAG,IAAI,CAAC5I,cAAc,CAAC5D,YAAY,CAAC,GAAG,CAAC;QACnDwM,OAAO,GAAG3O,KAAK,CAACyE,IAAI,CAACkK,OAAO,EAAEF,mBAAmB,CAACpM,QAAQ,EAAEoM,mBAAmB,CAACnM,KAAK,EAAE,IAAI,CAACwF,IAAI,CAAC;QACjG6G,OAAO,IAAI,IAAI,CAACpG,KAAK,CAACkG,mBAAmB,CAACpM,QAAQ,CAAC,GAAGrC,KAAK,CAACe,mBAAmB,CAAC0N,mBAAmB,CAAC;QACpGE,OAAO,GAAG3O,KAAK,CAACyE,IAAI,CAACkK,OAAO,EAAEF,mBAAmB,CAACpM,QAAQ,EAAEoM,mBAAmB,CAACnM,KAAK,EAAE,IAAI,CAACwF,IAAI,CAAC;QAEjG,IAAI8G,SAAS,GAAG5O,KAAK,CAACyE,IAAI,CAACiK,OAAO,EAAED,mBAAmB,CAACpM,QAAQ,EAAEoM,mBAAmB,CAACnM,KAAK,EAAE,IAAI,CAACwF,IAAI,CAAC;QACvG,IAAI+G,SAAS,GAAG7O,KAAK,CAACyE,IAAI,CAACkK,OAAO,EAAEF,mBAAmB,CAACpM,QAAQ,EAAEoM,mBAAmB,CAACnM,KAAK,EAAE,IAAI,CAACwF,IAAI,CAAC;QAEvG,IAAIgH,CAAC,GAAG,CAAChI,KAAK,GAAG8H,SAAS,KAAKC,SAAS,GAAGD,SAAS,CAAC;QACrD,IAAIG,CAAC,GAAG,CAAC5H,GAAG,GAAGyH,SAAS,KAAKC,SAAS,GAAGD,SAAS,CAAC;QAEnD,IAAI,CAACI,IAAI,CAACF,CAAC,EAAEC,CAAC,EAAEnJ,QAAQ,CAAC;OACzB,MACI;QACJ,IAAI,CAACoJ,IAAI,CAAC,CAAClI,KAAK,GAAGtF,GAAG,KAAKC,GAAG,GAAGD,GAAG,CAAC,EAAE,CAAC2F,GAAG,GAAG3F,GAAG,KAAKC,GAAG,GAAGD,GAAG,CAAC,EAAEoE,QAAQ,CAAC;;;EAG9E;EAGA;;;;;;;EAOOqJ,cAAcA,CAAChC,QAAgB;IACrC,OAAO,IAAIhD,IAAI,CAAC,IAAI,CAACqB,eAAe,CAAC2B,QAAQ,CAAC,CAAC;EAChD;EAEA;;;;;;;EAOOiC,cAAcA,CAAClF,IAAU;IAC/B,OAAO,IAAI,CAAC2C,eAAe,CAAC3C,IAAI,CAACwE,OAAO,EAAE,CAAC;EAC5C;EAEA;;;;;;EAMOW,oBAAoBA,CAAA;IAC1B,IAAI1N,GAAG,GAAG,IAAI,CAACJ,UAAU,CAAC,cAAc,EAAE,IAAI,CAACA,UAAU,CAAC,KAAK,CAAC,CAAC;IACjE,IAAIG,GAAG,GAAG,IAAI,CAACH,UAAU,CAAC,cAAc,EAAE,IAAI,CAACA,UAAU,CAAC,KAAK,CAAC,CAAC;IAEjE,IAAI3B,KAAK,CAACgC,QAAQ,CAACD,GAAG,CAAC,IAAI/B,KAAK,CAACgC,QAAQ,CAACF,GAAG,CAAC,EAAE;MAC/C,OAAO,IAAI,CAAC4G,iBAAiB,IAAI3G,GAAG,GAAGD,GAAG,CAAC;;IAE5C,OAAO,IAAI;EACZ;EAEO4N,YAAYA,CAAC9M,KAAc;IACjC,IAAIA,KAAK,IAAI,IAAI,EAAE;MAClBA,KAAK,GAAG,CAAC;;IAGV,IAAI+M,KAAK,GAAG,IAAI,CAAC3O,GAAG,CAAC,iBAAiB,EAAE,GAAG,CAAC,GAAG,IAAI,CAACmC,YAAY,EAAE;IAClE,IAAI,IAAI,CAACnC,GAAG,CAAC,UAAU,CAAC,CAACW,UAAU,CAAC,QAAQ,CAAC,IAAI,GAAG,EAAE;MACrDiB,KAAK,IAAI,CAAC,CAAC;;IAGZ,IAAIgN,YAAY,GAAG,IAAI,CAAChE,eAAe,CAAC,IAAI,CAACjK,UAAU,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC;IAE9E,MAAMc,YAAY,GAAG,IAAI,CAACd,UAAU,CAAC,cAAc,CAAC;IACpD,IAAIkD,IAAI,GAAG,IAAI,CAACgL,SAAS,CAACD,YAAY,EAAEhN,KAAK,EAAEH,YAAY,CAAC;IAE5D,IAAIgE,YAAY,GAAG,IAAI,CAAC9E,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;IACrD,IAAI+E,YAAY,GAAG,IAAI,CAAC/E,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;IAErD,IAAIG,GAAG,GAAGxB,KAAK,CAACyE,IAAI,CAAC0B,YAAY,EAAEhE,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACoC,KAAK,CAAC;IACzF,IAAIjD,GAAG,GAAGzB,KAAK,CAACyE,IAAI,CAAC2B,YAAY,EAAEjE,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACoC,KAAK,CAAC;IAEzFH,IAAI,IAAI8K,KAAK;IACb9K,IAAI,GAAG5E,KAAK,CAAC6P,UAAU,CAACjL,IAAI,EAAE/C,GAAG,GAAG6N,KAAK,EAAE5N,GAAG,GAAG4N,KAAK,CAAC;IAEvD,OAAO,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAC9C,eAAe,CAACpI,IAAI,CAAC,CAAC;EACzD;EAEUgL,SAASA,CAAChL,IAAY,EAAEjC,KAAa,EAAEH,YAA2B;IAC3E,OAAOnC,KAAK,CAACyE,IAAI,CAACF,IAAI,GAAGjC,KAAK,GAAG,IAAI,CAACO,YAAY,EAAE,EAAEV,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACoC,KAAK,CAAC;EAC7G;;AA7mCAvE,MAAA,CAAAC,cAAA,CAAAH,QAAA;;;;SAAkC;;AAClCE,MAAA,CAAAC,cAAA,CAAAH,QAAA;;;;SAA0CR,SAAS,CAACiQ,UAAU,CAACC,MAAM,CAAC,CAAC1P,QAAQ,CAAC2P,SAAS,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}