{"ast":null,"code":"/** @ignore */ /** */\nimport { BlendMode } from \"./Renderer\";\nimport { Color } from \"../../util/Color\";\nimport { Matrix } from \"../../util/Matrix\";\nimport { Percent, percent } from \"../../util/Percent\";\n//import { Throttler } from \"../../util/Throttler\";\nimport { ArrayDisposer, Disposer, DisposerClass, CounterDisposer, MultiDisposer } from \"../../util/Disposer\";\nimport { TextFormatter } from \"../../util/TextFormatter\";\nimport * as $utils from \"../../util/Utils\";\nimport * as $array from \"../../util/Array\";\nimport * as $object from \"../../util/Object\";\nimport * as $type from \"../../util/Type\";\nimport * as $math from \"../../util/Math\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\n/**\r\n * @ignore\r\n */\nfunction checkArgs(name, actual, expected) {\n  if (actual !== expected) {\n    throw new Error(\"Required \" + expected + \" arguments for \" + name + \" but got \" + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction checkMinArgs(name, actual, expected) {\n  if (actual < expected) {\n    throw new Error(\"Required at least \" + expected + \" arguments for \" + name + \" but got \" + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction checkEvenArgs(name, actual, expected) {\n  checkMinArgs(name, actual, expected);\n  if (actual % expected !== 0) {\n    throw new Error(\"Arguments for \" + name + \" must be in pairs of \" + expected);\n  }\n}\n/**\r\n * @ignore\r\n * This splits the flag so that way 0017 will be processed as 0 0 17\r\n *\r\n * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`\r\n */\nfunction splitArcFlags(args) {\n  for (let i = 0; i < args.length; i += 7) {\n    let index = i + 3;\n    let flag = args[index];\n    if (flag.length > 1) {\n      const a = /^([01])([01])(.*)$/.exec(flag);\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args.splice(index, 0, a[2]);\n        ++index;\n        if (a[3].length > 0) {\n          args[index] = a[3];\n        } else {\n          args.splice(index, 1);\n        }\n      }\n    }\n    ++index;\n    flag = args[index];\n    if (flag.length > 1) {\n      const a = /^([01])(.+)$/.exec(flag);\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args[index] = a[2];\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction assertBinary(value) {\n  if (value === 0 || value === 1) {\n    return value;\n  } else {\n    throw new Error(\"Flag must be 0 or 1\");\n  }\n}\n//  1 -> 0xffffff * (2 / 2)\n//  2 -> 0xffffff * (1 / 2)\n//\n//  3 -> 0xffffff * (3 / 4)\n//  4 -> 0xffffff * (1 / 4)\n//\n//  5 -> 0xffffff * (7 / 8)\n//  6 -> 0xffffff * (5 / 8)\n//  7 -> 0xffffff * (3 / 8)\n//  8 -> 0xffffff * (1 / 8)\n//\n//  9 -> 0xffffff * (15 / 16)\n// 10 -> 0xffffff * (13 / 16)\n// 11 -> 0xffffff * (11 / 16)\n// 12 -> 0xffffff *  (9 / 16)\n// 13 -> 0xffffff *  (7 / 16)\n// 14 -> 0xffffff *  (5 / 16)\n// 15 -> 0xffffff *  (3 / 16)\n// 16 -> 0xffffff *  (1 / 16)\n// @todo remove this old color distribution algo if the new one pans out\n/*function distributeId(id: number): number {\r\n    if (id === 1) {\r\n        return 0x000001;\r\n\r\n    } else {\r\n        // Finds the closest power of 2\r\n        const base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));\r\n\r\n        // Translates the id into an odd fraction index\r\n        const index = ((base - id) * 2) + 1;\r\n\r\n        // TODO is Math.round correct ?\r\n        return Math.round(0xffffff * (index / base));\r\n    }\r\n}*/\n/**\r\n * Function by smeans:\r\n * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/\r\n * @ignore\r\n */\nfunction distributeId(id) {\n  const rgb = [0, 0, 0];\n  for (let i = 0; i < 24; i++) {\n    rgb[i % 3] <<= 1;\n    rgb[i % 3] |= id & 0x01;\n    id >>= 1;\n  }\n  return (rgb[0] | 0) + (rgb[1] << 8) + (rgb[2] << 16);\n}\n/**\r\n * @ignore\r\n */\nfunction eachTargets(hitTarget, f) {\n  for (;;) {\n    if (hitTarget.interactive) {\n      if (!f(hitTarget)) {\n        break;\n      }\n    }\n    if (hitTarget._parent) {\n      hitTarget = hitTarget._parent;\n    } else {\n      break;\n    }\n  }\n}\n// TODO feature detection for mouse/touch/pointer\n/**\r\n * @ignore\r\n */\nfunction onPointerEvent(element, name, f) {\n  return $utils.addEventListener(element, $utils.getRendererEvent(name), event => {\n    const target = $utils.getEventTarget(event);\n    let touches = event.touches;\n    if (touches) {\n      if (touches.length == 0) {\n        touches = event.changedTouches;\n      }\n      f($array.copy(touches), target);\n    } else {\n      f([event], target);\n    }\n  });\n}\n/**\r\n * @ignore\r\n */\nfunction isTainted(image) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  const context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  context.drawImage(image, 0, 0, 1, 1);\n  try {\n    context.getImageData(0, 0, 1, 1);\n    return false;\n  } catch (err) {\n    console.warn(\"Image \\\"\" + image.src + \"\\\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors\");\n    return true;\n  }\n}\n/**\r\n * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.\r\n *\r\n * @ignore\r\n */\nfunction clearCanvas(view) {\n  view.width = 0;\n  view.height = 0;\n  view.style.width = \"0px\";\n  view.style.height = \"0px\";\n}\n/**\r\n * Aligns the coordinate to the pixel, so it renders crisp\r\n *\r\n * @ignore\r\n */\nfunction crisp(x) {\n  return Math.floor(x) + .5;\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasPivot {\n  constructor() {\n    Object.defineProperty(this, \"_x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  get x() {\n    return this._x;\n  }\n  get y() {\n    return this._y;\n  }\n  set x(value) {\n    this._x = value;\n  }\n  set y(value) {\n    this._y = value;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasDisplayObject extends DisposerClass {\n  constructor(renderer) {\n    super();\n    Object.defineProperty(this, \"_layer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"mask\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"visible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"exportable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"interactive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"inactive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"wheelable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"cancelTouch\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"isMeasured\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"buttonMode\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"alpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"compoundAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"angle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"scale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"crisp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"pivot\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new CanvasPivot()\n    });\n    Object.defineProperty(this, \"filter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"cursorOverStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_replacedCursorStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_localMatrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(this, \"_matrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    // TODO can this be replaced with _localMatrix ?\n    Object.defineProperty(this, \"_uMatrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(this, \"_renderer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_parent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_localBounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_bounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_colorId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._renderer = renderer;\n  }\n  subStatus(status) {\n    return {\n      inactive: this.inactive == null ? status.inactive : this.inactive,\n      layer: this._layer || status.layer\n    };\n  }\n  _dispose() {\n    this._renderer._removeObject(this);\n    this.getLayer().dirty = true;\n  }\n  getCanvas() {\n    return this.getLayer().view;\n  }\n  getLayer() {\n    let self = this;\n    for (;;) {\n      if (self._layer) {\n        return self._layer;\n      } else if (self._parent) {\n        self = self._parent;\n      } else {\n        return this._renderer.defaultLayer;\n      }\n    }\n  }\n  setLayer(order, margin) {\n    if (order == null) {\n      this._layer = undefined;\n    } else {\n      const visible = true;\n      this._layer = this._renderer.getLayer(order, visible);\n      this._layer.visible = visible;\n      this._layer.margin = margin;\n      if (margin) {\n        $utils.setInteractive(this._layer.view, false);\n      }\n      this._renderer._ghostLayer.setMargin(this._renderer.layers);\n      if (this._parent) {\n        this._parent.registerChildLayer(this._layer);\n      }\n      this._layer.dirty = true;\n      this._renderer.resizeLayer(this._layer);\n      this._renderer.resizeGhost();\n    }\n  }\n  markDirtyLayer() {\n    this.getLayer().dirty = true;\n  }\n  clear() {\n    this.invalidateBounds();\n  }\n  invalidateBounds() {\n    this._localBounds = undefined;\n  }\n  _addBounds(_bounds) {}\n  _getColorId() {\n    if (this._colorId === undefined) {\n      this._colorId = this._renderer.paintId(this);\n    }\n    return this._colorId;\n  }\n  _isInteractive(status) {\n    return !status.inactive && (this.interactive || this._renderer._forceInteractive > 0);\n  }\n  _isInteractiveMask(status) {\n    return this._isInteractive(status);\n  }\n  contains(child) {\n    for (;;) {\n      if (child === this) {\n        return true;\n      } else if (child._parent) {\n        child = child._parent;\n      } else {\n        return false;\n      }\n    }\n  }\n  toGlobal(point) {\n    return this._matrix.apply(point);\n  }\n  toLocal(point) {\n    return this._matrix.applyInverse(point);\n  }\n  getLocalMatrix() {\n    this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);\n    return this._uMatrix;\n  }\n  getLocalBounds() {\n    if (!this._localBounds) {\n      const bn = 10000000;\n      this._localBounds = {\n        left: bn,\n        top: bn,\n        right: -bn,\n        bottom: -bn\n      };\n      this._addBounds(this._localBounds);\n    }\n    return this._localBounds;\n  }\n  getAdjustedBounds(bounds) {\n    this._setMatrix();\n    const matrix = this.getLocalMatrix();\n    const p0 = matrix.apply({\n      x: bounds.left,\n      y: bounds.top\n    });\n    const p1 = matrix.apply({\n      x: bounds.right,\n      y: bounds.top\n    });\n    const p2 = matrix.apply({\n      x: bounds.right,\n      y: bounds.bottom\n    });\n    const p3 = matrix.apply({\n      x: bounds.left,\n      y: bounds.bottom\n    });\n    return {\n      left: Math.min(p0.x, p1.x, p2.x, p3.x),\n      top: Math.min(p0.y, p1.y, p2.y, p3.y),\n      right: Math.max(p0.x, p1.x, p2.x, p3.x),\n      bottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n    };\n  }\n  on(key, callback, context) {\n    if (this.interactive) {\n      return this._renderer._addEvent(this, key, callback, context);\n    } else {\n      return new Disposer(() => {});\n    }\n  }\n  _setMatrix() {\n    // TODO only calculate this if it has actually changed\n    this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y,\n    // Converts degrees to radians\n    this.angle * Math.PI / 180, this.scale);\n    this._matrix.copyFrom(this._localMatrix);\n    if (this._parent) {\n      // TODO only calculate this if it has actually changed\n      this._matrix.prepend(this._parent._matrix);\n    }\n  }\n  _transform(context, resolution) {\n    const m = this._matrix;\n    let tx = m.tx * resolution;\n    let ty = m.ty * resolution;\n    if (this.crisp) {\n      tx = crisp(tx);\n      ty = crisp(ty);\n    }\n    context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, tx, ty);\n  }\n  _transformMargin(context, resolution, margin) {\n    const m = this._matrix;\n    context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, (m.tx + margin.left) * resolution, (m.ty + margin.top) * resolution);\n  }\n  _transformLayer(context, resolution, layer) {\n    if (layer.margin) {\n      this._transformMargin(context, layer.scale || resolution, layer.margin);\n    } else {\n      this._transform(context, layer.scale || resolution);\n    }\n  }\n  render(status) {\n    if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {\n      this._setMatrix();\n      const subStatus = this.subStatus(status);\n      const resolution = this._renderer.resolution;\n      const layers = this._renderer.layers;\n      const ghostLayer = this._renderer._ghostLayer;\n      const ghostContext = ghostLayer.context;\n      const mask = this.mask;\n      if (mask) {\n        mask._setMatrix();\n      }\n      // TODO improve this\n      $array.each(layers, layer => {\n        if (layer) {\n          const context = layer.context;\n          context.save();\n          // We must apply the mask before we transform the element\n          if (mask) {\n            mask._transformLayer(context, resolution, layer);\n            mask._runPath(context);\n            context.clip();\n          }\n          context.globalAlpha = this.compoundAlpha * this.alpha;\n          this._transformLayer(context, resolution, layer);\n          if (this.filter) {\n            context.filter = this.filter;\n          }\n        }\n      });\n      ghostContext.save();\n      // We must apply the mask before we transform the element\n      if (mask && this._isInteractiveMask(subStatus)) {\n        mask._transformMargin(ghostContext, resolution, ghostLayer.margin);\n        mask._runPath(ghostContext);\n        ghostContext.clip();\n      }\n      this._transformMargin(ghostContext, resolution, ghostLayer.margin);\n      this._render(subStatus);\n      ghostContext.restore();\n      $array.each(layers, layer => {\n        if (layer) {\n          layer.context.restore();\n        }\n      });\n    }\n  }\n  _render(status) {\n    if (this.exportable === false) {\n      status.layer.tainted = true;\n    }\n  }\n  hovering() {\n    return this._renderer._hovering.has(this);\n  }\n  dragging() {\n    return this._renderer._dragging.some(x => x.value === this);\n  }\n  shouldCancelTouch() {\n    const renderer = this._renderer;\n    if (renderer.tapToActivate && !renderer._touchActive) {\n      return false;\n    }\n    if (this.cancelTouch) {\n      return true;\n    } else if (this._parent) {\n      return this._parent.shouldCancelTouch();\n    }\n    return false;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasContainer extends CanvasDisplayObject {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"interactiveChildren\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"_childLayers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_children\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  _isInteractiveMask(status) {\n    return this.interactiveChildren || super._isInteractiveMask(status);\n  }\n  addChild(child) {\n    child._parent = this;\n    this._children.push(child);\n    if (child._layer) {\n      this.registerChildLayer(child._layer);\n    }\n  }\n  addChildAt(child, index) {\n    child._parent = this;\n    this._children.splice(index, 0, child);\n    if (child._layer) {\n      this.registerChildLayer(child._layer);\n    }\n  }\n  removeChild(child) {\n    child._parent = undefined;\n    $array.removeFirst(this._children, child);\n  }\n  _render(status) {\n    super._render(status);\n    const renderer = this._renderer;\n    if (this.interactive && this.interactiveChildren) {\n      ++renderer._forceInteractive;\n    }\n    $array.each(this._children, child => {\n      child.compoundAlpha = this.compoundAlpha * this.alpha;\n      child.render(status);\n    });\n    if (this.interactive && this.interactiveChildren) {\n      --renderer._forceInteractive;\n    }\n  }\n  registerChildLayer(layer) {\n    if (!this._childLayers) {\n      this._childLayers = [];\n    }\n    $array.pushOne(this._childLayers, layer);\n    if (this._parent) {\n      this._parent.registerChildLayer(layer);\n    }\n  }\n  markDirtyLayer() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    super.markDirtyLayer();\n    if (deep && this._childLayers) {\n      $array.each(this._childLayers, layer => layer.dirty = true);\n    }\n  }\n  _dispose() {\n    super._dispose();\n    if (this._childLayers) {\n      $array.each(this._childLayers, layer => {\n        layer.dirty = true;\n      });\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction setPoint(bounds, point) {\n  bounds.left = Math.min(bounds.left, point.x);\n  bounds.top = Math.min(bounds.top, point.y);\n  bounds.right = Math.max(bounds.right, point.x);\n  bounds.bottom = Math.max(bounds.bottom, point.y);\n}\n/**\r\n * @ignore\r\n */\nclass Op {\n  colorize(_context, _forceColor) {}\n  colorizeGhost(context, forceColor) {\n    this.colorize(context, forceColor);\n  }\n  path(_context) {}\n  pathGhost(context) {\n    this.path(context);\n  }\n  addBounds(_bounds) {}\n}\n/**\r\n * @ignore\r\n */\nclass BeginPath extends Op {\n  colorize(context, _forceColor) {\n    context.beginPath();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass BeginFill extends Op {\n  constructor(color) {\n    super();\n    Object.defineProperty(this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n  }\n  colorize(context, forceColor) {\n    if (forceColor !== undefined) {\n      context.fillStyle = forceColor;\n    } else {\n      context.fillStyle = this.color;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass EndFill extends Op {\n  constructor(clearShadow) {\n    super();\n    Object.defineProperty(this, \"clearShadow\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: clearShadow\n    });\n  }\n  colorize(context, _forceColor) {\n    context.fill();\n    if (this.clearShadow) {\n      context.shadowColor = \"\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass EndStroke extends Op {\n  colorize(context, _forceColor) {\n    context.stroke();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineStyle extends Op {\n  constructor(width, color, lineJoin, lineCap) {\n    super();\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(this, \"lineJoin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: lineJoin\n    });\n    Object.defineProperty(this, \"lineCap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: lineCap\n    });\n  }\n  colorize(context, forceColor) {\n    if (forceColor !== undefined) {\n      context.strokeStyle = forceColor;\n    } else {\n      context.strokeStyle = this.color;\n    }\n    context.lineWidth = this.width;\n    if (this.lineJoin) {\n      context.lineJoin = this.lineJoin;\n    }\n    if (this.lineCap) {\n      context.lineCap = this.lineCap;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineDash extends Op {\n  constructor(dash) {\n    super();\n    Object.defineProperty(this, \"dash\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dash\n    });\n  }\n  colorize(context, _forceColor) {\n    context.setLineDash(this.dash);\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineDashOffset extends Op {\n  constructor(dashOffset) {\n    super();\n    Object.defineProperty(this, \"dashOffset\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dashOffset\n    });\n  }\n  colorize(context, _forceColor) {\n    context.lineDashOffset = this.dashOffset;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawRect extends Op {\n  constructor(x, y, width, height) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n  }\n  path(context) {\n    context.rect(this.x, this.y, this.width, this.height);\n  }\n  addBounds(bounds) {\n    const l = this.x;\n    const t = this.y;\n    const r = l + this.width;\n    const b = t + this.height;\n    setPoint(bounds, {\n      x: l,\n      y: t\n    });\n    setPoint(bounds, {\n      x: r,\n      y: t\n    });\n    setPoint(bounds, {\n      x: l,\n      y: b\n    });\n    setPoint(bounds, {\n      x: r,\n      y: b\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawCircle extends Op {\n  constructor(x, y, radius) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n  }\n  path(context) {\n    context.moveTo(this.x + this.radius, this.y);\n    context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n  }\n  // TODO handle skewing and rotation\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x - this.radius,\n      y: this.y - this.radius\n    });\n    setPoint(bounds, {\n      x: this.x + this.radius,\n      y: this.y + this.radius\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawEllipse extends Op {\n  constructor(x, y, radiusX, radiusY) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, \"radiusX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusX\n    });\n    Object.defineProperty(this, \"radiusY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusY\n    });\n  }\n  path(context) {\n    context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);\n  }\n  // TODO handle skewing and rotation\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x - this.radiusX,\n      y: this.y - this.radiusY\n    });\n    setPoint(bounds, {\n      x: this.x + this.radiusX,\n      y: this.y + this.radiusY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Arc extends Op {\n  constructor(cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    super();\n    Object.defineProperty(this, \"cx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cx\n    });\n    Object.defineProperty(this, \"cy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cy\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n    Object.defineProperty(this, \"startAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: startAngle\n    });\n    Object.defineProperty(this, \"endAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: endAngle\n    });\n    Object.defineProperty(this, \"anticlockwise\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: anticlockwise\n    });\n  }\n  path(context) {\n    if (this.radius > 0) {\n      context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);\n    }\n  }\n  addBounds(bounds) {\n    let arcBounds = $math.getArcBounds(this.cx, this.cy, this.startAngle * $math.DEGREES, this.endAngle * $math.DEGREES, this.radius);\n    setPoint(bounds, {\n      x: arcBounds.left,\n      y: arcBounds.top\n    });\n    setPoint(bounds, {\n      x: arcBounds.right,\n      y: arcBounds.bottom\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass ArcTo extends Op {\n  constructor(x1, y1, x2, y2, radius) {\n    super();\n    Object.defineProperty(this, \"x1\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x1\n    });\n    Object.defineProperty(this, \"y1\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y1\n    });\n    Object.defineProperty(this, \"x2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x2\n    });\n    Object.defineProperty(this, \"y2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y2\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n  }\n  path(context) {\n    if (this.radius > 0) {\n      context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);\n    }\n  }\n  // TODO: add points\n  addBounds(_bounds) {\n    /*\r\n    // not finished\r\n    https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically\r\n      if (prevPoint) {\r\n        let x1 = prevPoint.x;\r\n        let y1 = prevPoint.y;\r\n        let x2 = this.x2;\r\n        let y2 = this.y2;\r\n        let r = this.radius;\r\n          let xa = (x2 - x1) / 2;\r\n        let ya = (y2 - y1) / 2;\r\n          let x0 = x1 + xa;\r\n        let y0 = y1 + ya;\r\n          let a = Math.hypot(xa, ya);\r\n        let b = Math.sqrt(r * r - a * a);\r\n          let cx = x0 + b * ya / a;\r\n        let cy = y0 - b * xa / a;\r\n          console.log(cx, cy);\r\n    }*/\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineTo extends Op {\n  constructor(x, y) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.lineTo(this.x, this.y);\n  }\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass MoveTo extends Op {\n  constructor(x, y) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.moveTo(this.x, this.y);\n  }\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass ClosePath extends Op {\n  path(context) {\n    context.closePath();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass BezierCurveTo extends Op {\n  constructor(cpX, cpY, cpX2, cpY2, toX, toY) {\n    super();\n    Object.defineProperty(this, \"cpX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(this, \"cpY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(this, \"cpX2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX2\n    });\n    Object.defineProperty(this, \"cpY2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY2\n    });\n    Object.defineProperty(this, \"toX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(this, \"toY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n  }\n  path(context) {\n    context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.cpX,\n      y: this.cpY\n    });\n    setPoint(bounds, {\n      x: this.cpX2,\n      y: this.cpY2\n    });\n    setPoint(bounds, {\n      x: this.toX,\n      y: this.toY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass QuadraticCurveTo extends Op {\n  constructor(cpX, cpY, toX, toY) {\n    super();\n    Object.defineProperty(this, \"cpX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(this, \"cpY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(this, \"toX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(this, \"toY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n  }\n  path(context) {\n    context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.cpX,\n      y: this.cpY\n    });\n    setPoint(bounds, {\n      x: this.toX,\n      y: this.toY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Shadow extends Op {\n  constructor(color, blur, offsetX, offsetY, opacity) {\n    super();\n    Object.defineProperty(this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(this, \"blur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: blur\n    });\n    Object.defineProperty(this, \"offsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetX\n    });\n    Object.defineProperty(this, \"offsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetY\n    });\n    Object.defineProperty(this, \"opacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: opacity\n    });\n  }\n  colorize(context, _forceColor) {\n    if (this.opacity) {\n      context.fillStyle = this.color;\n    }\n    context.shadowColor = this.color;\n    context.shadowBlur = this.blur;\n    context.shadowOffsetX = this.offsetX;\n    context.shadowOffsetY = this.offsetY;\n  }\n  colorizeGhost(_context, _forceColor) {}\n}\n/**\r\n * @ignore\r\n */\nclass GraphicsImage extends Op {\n  constructor(image, width, height, x, y) {\n    super();\n    Object.defineProperty(this, \"image\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: image\n    });\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.drawImage(this.image, this.x, this.y, this.width, this.height);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n    setPoint(bounds, {\n      x: this.width,\n      y: this.height\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasGraphics extends CanvasDisplayObject {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_operations\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"blendMode\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: BlendMode.NORMAL\n    });\n    Object.defineProperty(this, \"_hasShadows\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_fillAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_strokeAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  clear() {\n    super.clear();\n    this._operations.length = 0;\n  }\n  _pushOp(op) {\n    this._operations.push(op);\n  }\n  beginFill(color) {\n    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this._fillAlpha = alpha;\n    if (color) {\n      if (color instanceof Color) {\n        this._pushOp(new BeginFill(color.toCSS(alpha)));\n      } else {\n        this.isMeasured = true;\n        this._pushOp(new BeginFill(color));\n      }\n    } else {\n      this._pushOp(new BeginFill(\"rgba(0, 0, 0, \" + alpha + \")\"));\n    }\n  }\n  endFill() {\n    this._pushOp(new EndFill(this._hasShadows));\n  }\n  endStroke() {\n    this._pushOp(new EndStroke());\n  }\n  beginPath() {\n    this._pushOp(new BeginPath());\n  }\n  lineStyle() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let color = arguments.length > 1 ? arguments[1] : undefined;\n    let alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let lineJoin = arguments.length > 3 ? arguments[3] : undefined;\n    let lineCap = arguments.length > 4 ? arguments[4] : undefined;\n    this._strokeAlpha = alpha;\n    if (color) {\n      if (color instanceof Color) {\n        this._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin, lineCap));\n      } else {\n        this._pushOp(new LineStyle(width, color, lineJoin, lineCap));\n      }\n    } else {\n      this._pushOp(new LineStyle(width, \"rgba(0, 0, 0, \" + alpha + \")\", lineJoin, lineCap));\n    }\n  }\n  setLineDash(dash) {\n    this._pushOp(new LineDash(dash ? dash : []));\n  }\n  setLineDashOffset() {\n    let dashOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this._pushOp(new LineDashOffset(dashOffset));\n  }\n  drawRect(x, y, width, height) {\n    this._pushOp(new DrawRect(x, y, width, height));\n  }\n  drawCircle(x, y, radius) {\n    this._pushOp(new DrawCircle(x, y, radius));\n  }\n  drawEllipse(x, y, radiusX, radiusY) {\n    this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));\n  }\n  arc(cx, cy, radius, startAngle, endAngle) {\n    let anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));\n  }\n  arcTo(x1, y1, x2, y2, radius) {\n    this._pushOp(new ArcTo(x1, y1, x2, y2, radius));\n  }\n  lineTo(x, y) {\n    this._pushOp(new LineTo(x, y));\n  }\n  moveTo(x, y) {\n    this._pushOp(new MoveTo(x, y));\n  }\n  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));\n  }\n  quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));\n  }\n  closePath() {\n    this._pushOp(new ClosePath());\n  }\n  shadow(color) {\n    let blur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let offsetX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let offsetY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let opacity = arguments.length > 4 ? arguments[4] : undefined;\n    this._hasShadows = true;\n    this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));\n  }\n  image(image, width, height, x, y) {\n    this._pushOp(new GraphicsImage(image, width, height, x, y));\n  }\n  // https://svgwg.org/svg2-draft/paths.html#DProperty\n  // TODO better error checking\n  svgPath(path) {\n    let x = 0;\n    let y = 0;\n    let cpx = null;\n    let cpy = null;\n    let qcpx = null;\n    let qcpy = null;\n    const SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;\n    const ARGS_REGEXP = /[\\u0009\\u0020\\u000A\\u000C\\u000D]*([\\+\\-]?[0-9]*\\.?[0-9]+(?:[eE][\\+\\-]?[0-9]+)?)[\\u0009\\u0020\\u000A\\u000C\\u000D]*,?/g;\n    let match;\n    while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {\n      const name = match[1];\n      const rest = match[2];\n      const args = [];\n      while ((match = ARGS_REGEXP.exec(rest)) !== null) {\n        args.push(match[1]);\n      }\n      // Reset control point\n      if (name !== \"S\" && name !== \"s\" && name !== \"C\" && name !== \"c\") {\n        cpx = null;\n        cpy = null;\n      }\n      // Reset control point\n      if (name !== \"Q\" && name !== \"q\" && name !== \"T\" && name !== \"t\") {\n        qcpx = null;\n        qcpy = null;\n      }\n      switch (name) {\n        case \"M\":\n          checkEvenArgs(name, args.length, 2);\n          x = +args[0];\n          y = +args[1];\n          this.moveTo(x, y);\n          for (let i = 2; i < args.length; i += 2) {\n            x = +args[i];\n            y = +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"m\":\n          checkEvenArgs(name, args.length, 2);\n          x += +args[0];\n          y += +args[1];\n          this.moveTo(x, y);\n          for (let i = 2; i < args.length; i += 2) {\n            x += +args[i];\n            y += +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"L\":\n          checkEvenArgs(name, args.length, 2);\n          for (let i = 0; i < args.length; i += 2) {\n            x = +args[i];\n            y = +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"l\":\n          checkEvenArgs(name, args.length, 2);\n          for (let i = 0; i < args.length; i += 2) {\n            x += +args[i];\n            y += +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"H\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            x = +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"h\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            x += +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"V\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            y = +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"v\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            y += +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"C\":\n          checkEvenArgs(name, args.length, 6);\n          for (let i = 0; i < args.length; i += 6) {\n            const x1 = +args[i];\n            const y1 = +args[i + 1];\n            cpx = +args[i + 2];\n            cpy = +args[i + 3];\n            x = +args[i + 4];\n            y = +args[i + 5];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"c\":\n          checkEvenArgs(name, args.length, 6);\n          for (let i = 0; i < args.length; i += 6) {\n            const x1 = +args[i] + x;\n            const y1 = +args[i + 1] + y;\n            cpx = +args[i + 2] + x;\n            cpy = +args[i + 3] + y;\n            x += +args[i + 4];\n            y += +args[i + 5];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"S\":\n          checkEvenArgs(name, args.length, 4);\n          if (cpx === null || cpy === null) {\n            cpx = x;\n            cpy = y;\n          }\n          for (let i = 0; i < args.length; i += 4) {\n            const x1 = 2 * x - cpx;\n            const y1 = 2 * y - cpy;\n            cpx = +args[i];\n            cpy = +args[i + 1];\n            x = +args[i + 2];\n            y = +args[i + 3];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"s\":\n          checkEvenArgs(name, args.length, 4);\n          if (cpx === null || cpy === null) {\n            cpx = x;\n            cpy = y;\n          }\n          for (let i = 0; i < args.length; i += 4) {\n            const x1 = 2 * x - cpx;\n            const y1 = 2 * y - cpy;\n            cpx = +args[i] + x;\n            cpy = +args[i + 1] + y;\n            x += +args[i + 2];\n            y += +args[i + 3];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"Q\":\n          checkEvenArgs(name, args.length, 4);\n          for (let i = 0; i < args.length; i += 4) {\n            qcpx = +args[i];\n            qcpy = +args[i + 1];\n            x = +args[i + 2];\n            y = +args[i + 3];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"q\":\n          checkEvenArgs(name, args.length, 4);\n          for (let i = 0; i < args.length; i += 4) {\n            qcpx = +args[i] + x;\n            qcpy = +args[i + 1] + y;\n            x += +args[i + 2];\n            y += +args[i + 3];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"T\":\n          checkEvenArgs(name, args.length, 2);\n          if (qcpx === null || qcpy === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          for (let i = 0; i < args.length; i += 2) {\n            qcpx = 2 * x - qcpx;\n            qcpy = 2 * y - qcpy;\n            x = +args[i];\n            y = +args[i + 1];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"t\":\n          checkEvenArgs(name, args.length, 2);\n          if (qcpx === null || qcpy === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          for (let i = 0; i < args.length; i += 2) {\n            qcpx = 2 * x - qcpx;\n            qcpy = 2 * y - qcpy;\n            x += +args[i];\n            y += +args[i + 1];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"A\":\n        case \"a\":\n          const relative = name === \"a\";\n          splitArcFlags(args);\n          checkEvenArgs(name, args.length, 7);\n          for (let i = 0; i < args.length; i += 7) {\n            let cx = +args[i + 5];\n            let cy = +args[i + 6];\n            if (relative) {\n              cx += x;\n              cy += y;\n            }\n            const bs = arcToBezier({\n              px: x,\n              py: y,\n              rx: +args[i],\n              ry: +args[i + 1],\n              xAxisRotation: +args[i + 2],\n              largeArcFlag: assertBinary(+args[i + 3]),\n              sweepFlag: assertBinary(+args[i + 4]),\n              cx,\n              cy\n            });\n            $array.each(bs, b => {\n              this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);\n              x = b.x;\n              y = b.y;\n            });\n          }\n          break;\n        case \"Z\":\n        case \"z\":\n          checkArgs(name, args.length, 0);\n          this.closePath();\n          break;\n      }\n    }\n  }\n  _runPath(context) {\n    context.beginPath();\n    $array.each(this._operations, op => {\n      op.path(context);\n    });\n  }\n  _render(status) {\n    super._render(status);\n    const layerDirty = status.layer.dirty;\n    const interactive = this._isInteractive(status);\n    if (layerDirty || interactive) {\n      const context = status.layer.context;\n      const ghostContext = this._renderer._ghostLayer.context;\n      if (layerDirty) {\n        context.globalCompositeOperation = this.blendMode;\n        context.beginPath();\n      }\n      let color;\n      if (interactive) {\n        ghostContext.beginPath();\n        color = this._getColorId();\n      }\n      $array.each(this._operations, op => {\n        if (layerDirty) {\n          op.path(context);\n          op.colorize(context, undefined);\n        }\n        if (interactive) {\n          op.pathGhost(ghostContext);\n          op.colorizeGhost(ghostContext, color);\n        }\n      });\n    }\n  }\n  renderDetached(context) {\n    if (this.visible) {\n      this._setMatrix();\n      context.save();\n      // We must apply the mask before we transform the element\n      const mask = this.mask;\n      if (mask) {\n        mask._setMatrix();\n        mask._transform(context, 1);\n        mask._runPath(context);\n        context.clip();\n      }\n      // TODO handle compoundAlpha somehow ?\n      context.globalAlpha = this.compoundAlpha * this.alpha;\n      this._transform(context, 1);\n      if (this.filter) {\n        context.filter = this.filter;\n      }\n      context.globalCompositeOperation = this.blendMode;\n      context.beginPath();\n      $array.each(this._operations, op => {\n        op.path(context);\n        op.colorize(context, undefined);\n      });\n      context.restore();\n    }\n  }\n  _addBounds(bounds) {\n    if (this.visible && this.isMeasured) {\n      $array.each(this._operations, op => {\n        op.addBounds(bounds);\n      });\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasText extends CanvasDisplayObject {\n  constructor(renderer, text, style) {\n    super(renderer);\n    Object.defineProperty(this, \"text\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"style\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"resolution\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"textVisible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"_textInfo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_originalScale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    this.text = text;\n    this.style = style;\n  }\n  invalidateBounds() {\n    super.invalidateBounds();\n    this._textInfo = undefined;\n  }\n  _shared(context) {\n    if (this.style.textAlign) {\n      context.textAlign = this.style.textAlign;\n    }\n    if (this.style.direction) {\n      context.direction = this.style.direction;\n    }\n    if (this.style.textBaseline) {\n      context.textBaseline = this.style.textBaseline;\n    }\n  }\n  _prerender(status) {\n    let ignoreGhost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ignoreFontWeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super._render(status);\n    const context = status.layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    // Font style\n    const style = this.style;\n    let fontStyle = this._getFontStyle(undefined, ignoreFontWeight);\n    context.font = fontStyle;\n    if (this._isInteractive(status) && !ignoreGhost) {\n      ghostContext.font = fontStyle;\n    }\n    // Other parameters\n    if (style.fill) {\n      if (style.fill instanceof Color) {\n        context.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);\n      } else {\n        context.fillStyle = style.fill;\n      }\n    }\n    if (style.shadowColor) {\n      status.layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);\n    }\n    if (style.shadowBlur) {\n      status.layer.context.shadowBlur = style.shadowBlur;\n    }\n    if (style.shadowOffsetX) {\n      status.layer.context.shadowOffsetX = style.shadowOffsetX;\n    }\n    if (style.shadowOffsetY) {\n      status.layer.context.shadowOffsetY = style.shadowOffsetY;\n    }\n    this._shared(context);\n    if (this._isInteractive(status) && !ignoreGhost) {\n      ghostContext.fillStyle = this._getColorId();\n      this._shared(ghostContext);\n    }\n  }\n  _getFontStyle(style2) {\n    let ignoreFontWeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // Process defaults\n    const style = this.style;\n    let fontStyle = [];\n    if (style2 && style2.fontVariant) {\n      fontStyle.push(style2.fontVariant);\n    } else if (style.fontVariant) {\n      fontStyle.push(style.fontVariant);\n    }\n    if (!ignoreFontWeight) {\n      if (style2 && style2.fontWeight) {\n        fontStyle.push(style2.fontWeight);\n      } else if (style.fontWeight) {\n        fontStyle.push(style.fontWeight);\n      }\n    }\n    if (style2 && style2.fontStyle) {\n      fontStyle.push(style2.fontStyle);\n    } else if (style.fontStyle) {\n      fontStyle.push(style.fontStyle);\n    }\n    if (style2 && style2.fontSize) {\n      if ($type.isNumber(style2.fontSize)) {\n        style2.fontSize = style2.fontSize + \"px\";\n      }\n      fontStyle.push(style2.fontSize);\n    } else if (style.fontSize) {\n      if ($type.isNumber(style.fontSize)) {\n        style.fontSize = style.fontSize + \"px\";\n      }\n      fontStyle.push(style.fontSize);\n    }\n    if (style2 && style2.fontFamily) {\n      fontStyle.push(style2.fontFamily);\n    } else if (style.fontFamily) {\n      fontStyle.push(style.fontFamily);\n    } else if (fontStyle.length) {\n      fontStyle.push(\"Arial\");\n    }\n    return fontStyle.join(\" \");\n  }\n  _render(status) {\n    // We need measurements in order to properly position text for alignment\n    if (!this._textInfo) {\n      this._measure(status);\n    }\n    if (this.textVisible) {\n      const interactive = this._isInteractive(status);\n      const context = status.layer.context;\n      const layerDirty = status.layer.dirty;\n      const ghostContext = this._renderer._ghostLayer.context;\n      context.save();\n      ghostContext.save();\n      this._prerender(status);\n      // const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n      // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;\n      // Process text info produced by _measure()\n      $array.each(this._textInfo, (line, _index) => {\n        $array.each(line.textChunks, (chunk, _index) => {\n          // Set style\n          if (chunk.style) {\n            context.save();\n            ghostContext.save();\n            context.font = chunk.style;\n            if (this._isInteractive(status)) {\n              ghostContext.font = chunk.style;\n            }\n          }\n          if (chunk.fill) {\n            context.save();\n            context.fillStyle = chunk.fill.toCSS();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Draw text\n          if (layerDirty) {\n            context.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n          }\n          // Draw underline\n          if (chunk.textDecoration == \"underline\" || chunk.textDecoration == \"line-through\") {\n            let thickness = 1;\n            let offset = 1;\n            let fontSize = chunk.height;\n            const oversizedBehavior = this.style.oversizedBehavior || \"\";\n            if ([\"truncate\", \"wrap\", \"wrap-no-break\"].indexOf(oversizedBehavior) > -1) {\n              // Measure actual width of the text so the line fits\n              const metrics = this._measureText(chunk.text, context);\n              chunk.width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n            }\n            let offsetX = chunk.offsetX;\n            switch (this.style.textAlign) {\n              case \"right\":\n              case \"end\":\n                offsetX -= chunk.width;\n                break;\n              case \"center\":\n                offsetX -= chunk.width / 2;\n                break;\n            }\n            if (chunk.style) {\n              const format = TextFormatter.getTextStyle(chunk.style);\n              switch (format.fontWeight) {\n                case \"bolder\":\n                case \"bold\":\n                case \"700\":\n                case \"800\":\n                case \"900\":\n                  thickness = 2;\n                  break;\n              }\n            }\n            if (fontSize) {\n              offset = fontSize / 20;\n            }\n            let y;\n            if (chunk.textDecoration == \"line-through\") {\n              y = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;\n            } else {\n              y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;\n            }\n            context.save();\n            context.beginPath();\n            if (chunk.fill) {\n              context.strokeStyle = chunk.fill.toCSS();\n            } else if (this.style.fill && this.style.fill instanceof Color) {\n              context.strokeStyle = this.style.fill.toCSS();\n            }\n            context.lineWidth = thickness * offset;\n            context.moveTo(offsetX, y);\n            context.lineTo(offsetX + chunk.width, y);\n            context.stroke();\n            context.restore();\n          }\n          if (interactive && this.interactive) {\n            // Draw text in ghost canvas ONLY if it is set as interactive\n            // explicitly. This way we avoid hit test anomalies caused by anti\n            // aliasing of text.\n            ghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n          }\n          if (chunk.fill) {\n            context.restore();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Reset style\n          if (chunk.style) {\n            context.restore();\n            ghostContext.restore();\n          }\n        });\n      });\n      context.restore();\n      ghostContext.restore();\n    }\n  }\n  _addBounds(bounds) {\n    if (this.visible && this.isMeasured) {\n      //if (this._textVisible) {\n      const x = this._measure({\n        inactive: this.inactive,\n        layer: this.getLayer()\n      });\n      setPoint(bounds, {\n        x: x.left,\n        y: x.top\n      });\n      setPoint(bounds, {\n        x: x.right,\n        y: x.bottom\n      });\n      //}\n    }\n  }\n\n  _ignoreFontWeight() {\n    return /apple/i.test(navigator.vendor);\n  }\n  _measure(status) {\n    const context = status.layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    const rtl = this.style.direction == \"rtl\";\n    // Reset text info\n    this._textInfo = [];\n    // Init\n    const oversizedBehavior = this.style.oversizedBehavior;\n    const maxWidth = this.style.maxWidth;\n    const truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n    const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n    // Pre-render\n    context.save();\n    ghostContext.save();\n    this._prerender(status, true, this._ignoreFontWeight());\n    // Get default font metrix\n    const refText = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \";\n    // Split up text into lines\n    const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n    let styleRestored = true;\n    let minX = 0;\n    let maxX = 0;\n    // Iterate through the lines\n    let offsetY = 0;\n    let currentStyle;\n    $array.each(lines, (line, _index) => {\n      // Split up line into format/value chunks\n      let chunks;\n      if (line == \"\") {\n        chunks = [{\n          type: \"value\",\n          text: \"\"\n        }];\n      } else {\n        chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n      }\n      while (chunks.length > 0) {\n        // Init line object\n        let lineInfo = {\n          offsetY: offsetY,\n          ascent: 0,\n          width: 0,\n          height: 0,\n          left: 0,\n          right: 0,\n          textChunks: []\n        };\n        // Measure reference text\n        const metrics = this._measureText(refText, context);\n        const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n        lineInfo.height = height;\n        lineInfo.ascent = metrics.actualBoundingBoxAscent;\n        let currentFormat;\n        let currentDecoration = this.style.textDecoration;\n        let currentFill;\n        let currentChunkWidth;\n        let skipFurtherText = false;\n        let firstTextChunk = true;\n        let leftoverChunks = [];\n        let currentVerticalAlign;\n        //let offsetX = 0;\n        //let chunk;\n        //while(chunk = chunks.shift()) {\n        $array.eachContinue(chunks, (chunk, index) => {\n          // Format chunk\n          if (chunk.type == \"format\") {\n            if (chunk.text == \"[/]\") {\n              if (!styleRestored) {\n                context.restore();\n                ghostContext.restore();\n                styleRestored = true;\n              }\n              currentFill = undefined;\n              currentStyle = undefined;\n              currentChunkWidth = undefined;\n              currentDecoration = this.style.textDecoration;\n              currentVerticalAlign = undefined;\n              currentFormat = chunk.text;\n            } else {\n              if (!styleRestored) {\n                context.restore();\n                ghostContext.restore();\n              }\n              let format = TextFormatter.getTextStyle(chunk.text);\n              const fontStyle = this._getFontStyle(format);\n              context.save();\n              ghostContext.save();\n              context.font = fontStyle;\n              currentStyle = fontStyle;\n              currentFormat = chunk.text;\n              if (format.textDecoration) {\n                currentDecoration = format.textDecoration;\n              }\n              if (format.fill) {\n                currentFill = format.fill;\n              }\n              if (format.width) {\n                currentChunkWidth = $type.toNumber(format.width);\n              }\n              if (format.verticalAlign) {\n                currentVerticalAlign = format.verticalAlign;\n              }\n              styleRestored = false;\n              // Measure reference text after change of format\n              const metrics = this._measureText(refText, context);\n              const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n              if (height > lineInfo.height) {\n                lineInfo.height = height;\n              }\n              if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n                lineInfo.ascent = metrics.actualBoundingBoxAscent;\n              }\n            }\n          }\n          // Text chunk\n          else if (chunk.type == \"value\" && !skipFurtherText) {\n            // Measure\n            const metrics = this._measureText(chunk.text, context);\n            let chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n            // Check for fit\n            if (truncate) {\n              // Break words?\n              let breakWords = firstTextChunk || this.style.breakWords || false;\n              // Measure ellipsis and check if it fits\n              const ellipsis = this.style.ellipsis || \"\";\n              const ellipsisMetrics = this._measureText(ellipsis, context);\n              const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n              // Check fit\n              if (lineInfo.width + chunkWidth > maxWidth) {\n                const excessWidth = maxWidth - lineInfo.width - ellipsisWidth;\n                chunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);\n                chunk.text += ellipsis;\n                skipFurtherText = true;\n              }\n            } else if (wrap) {\n              // Check fit\n              if (lineInfo.width + chunkWidth > maxWidth) {\n                const excessWidth = maxWidth - lineInfo.width;\n                const tmpText = this._truncateText(context, chunk.text, excessWidth, false, firstTextChunk && this.style.oversizedBehavior != \"wrap-no-break\");\n                if (tmpText == \"\") {\n                  // Unable to fit a single letter - hide the whole label\n                  this.textVisible = true;\n                  return false;\n                }\n                //skipFurtherText = true;\n                //Add remaining chunks for the next line\n                leftoverChunks = chunks.slice(index + 1);\n                //Add remaining text of current chunk if it was forced-cut\n                if ($utils.trim(tmpText) != $utils.trim(chunk.text)) {\n                  leftoverChunks.unshift({\n                    type: \"value\",\n                    text: chunk.text.substr(tmpText.length)\n                  });\n                  if (currentFormat) {\n                    leftoverChunks.unshift({\n                      type: \"format\",\n                      text: currentFormat\n                    });\n                  }\n                }\n                // Set current chunk (truncated)\n                chunk.text = $utils.trim(tmpText);\n                chunks = [];\n                skipFurtherText = true;\n              }\n            }\n            // Chunk width?\n            let leftBoundMod = 1;\n            let rightBoundMod = 1;\n            if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n              // increase horizontal bounding boxes accordingly\n              const boundsMod = chunkWidth / currentChunkWidth;\n              switch (this.style.textAlign) {\n                case \"right\":\n                case \"end\":\n                  leftBoundMod = boundsMod;\n                  break;\n                case \"center\":\n                  leftBoundMod = boundsMod;\n                  rightBoundMod = boundsMod;\n                  break;\n                default:\n                  rightBoundMod = boundsMod;\n              }\n              chunkWidth = currentChunkWidth;\n            }\n            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            if (chunkHeight > lineInfo.height) {\n              lineInfo.height = chunkHeight;\n            }\n            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n              lineInfo.ascent = metrics.actualBoundingBoxAscent;\n            }\n            lineInfo.width += chunkWidth;\n            lineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;\n            lineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;\n            lineInfo.textChunks.push({\n              style: currentStyle,\n              fill: currentFill,\n              text: chunk.text,\n              width: chunkWidth,\n              height: chunkHeight,\n              left: metrics.actualBoundingBoxLeft,\n              right: metrics.actualBoundingBoxRight,\n              ascent: metrics.actualBoundingBoxAscent,\n              offsetX: 0,\n              offsetY: 0,\n              textDecoration: currentDecoration,\n              verticalAlign: currentVerticalAlign\n            });\n            //offsetX += chunkWidth;\n            firstTextChunk = false;\n          }\n          if (leftoverChunks) {\n            //return false;\n          }\n          return true;\n          //}\n        });\n\n        if (this.style.lineHeight instanceof Percent) {\n          lineInfo.height *= this.style.lineHeight.value;\n          lineInfo.ascent *= this.style.lineHeight.value;\n        } else {\n          lineInfo.height *= this.style.lineHeight || 1.2;\n          lineInfo.ascent *= this.style.lineHeight || 1.2;\n        }\n        if (minX < lineInfo.left) {\n          minX = lineInfo.left;\n        }\n        if (maxX < lineInfo.right) {\n          maxX = lineInfo.right;\n        }\n        this._textInfo.push(lineInfo);\n        //lineInfo.offsetY += lineInfo.ascent;\n        offsetY += lineInfo.height;\n        // Reset chunks so that it can proceed to the next line\n        chunks = leftoverChunks || [];\n      }\n    });\n    if (!styleRestored) {\n      context.restore();\n      ghostContext.restore();\n    }\n    // Adjust chunk internal offsets\n    $array.each(this._textInfo, (lineInfo, _index) => {\n      let currentChunkOffset = 0;\n      $array.each(lineInfo.textChunks, chunk => {\n        chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;\n        chunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);\n        currentChunkOffset += chunk.width;\n        if (chunk.verticalAlign) {\n          switch (chunk.verticalAlign) {\n            case \"super\":\n              chunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;\n              break;\n            case \"sub\":\n              chunk.offsetY += chunk.height / 2;\n              break;\n          }\n        }\n      });\n    });\n    const bounds = {\n      left: rtl ? -maxX : -minX,\n      top: 0,\n      right: rtl ? minX : maxX,\n      bottom: offsetY\n    };\n    // We need to fit?\n    if (oversizedBehavior !== \"none\") {\n      const ratio = this._fitRatio(bounds);\n      if (ratio < 1) {\n        if (oversizedBehavior == \"fit\") {\n          if ($type.isNumber(this.style.minScale) && ratio < this.style.minScale) {\n            this.textVisible = false;\n            bounds.left = 0;\n            bounds.top = 0;\n            bounds.right = 0;\n            bounds.bottom = 0;\n          } else {\n            if (!this._originalScale || this._originalScale == 1) {\n              this._originalScale = this.scale;\n            }\n            this.scale = ratio;\n            this.textVisible = true;\n          }\n        } else if (oversizedBehavior == \"hide\") {\n          this.textVisible = false;\n          bounds.left = 0;\n          bounds.top = 0;\n          bounds.right = 0;\n          bounds.bottom = 0;\n        } else {\n          switch (this.style.textAlign) {\n            case \"right\":\n            case \"end\":\n              bounds.left = rtl ? maxWidth : -maxWidth;\n              bounds.right = 0;\n              break;\n            case \"center\":\n              bounds.left = -maxWidth / 2;\n              bounds.right = maxWidth / 2;\n              break;\n            default:\n              bounds.left = 0;\n              bounds.right = rtl ? -maxWidth : maxWidth;\n          }\n          this.scale = this._originalScale || 1;\n          this._originalScale = undefined;\n          this.textVisible = true;\n        }\n      } else {\n        this.scale = this._originalScale || 1;\n        this._originalScale = undefined;\n        this.textVisible = true;\n      }\n    }\n    context.restore();\n    ghostContext.restore();\n    return bounds;\n  }\n  _fitRatio(bounds) {\n    const maxW = this.style.maxWidth;\n    const maxH = this.style.maxHeight;\n    if (!$type.isNumber(maxW) && !$type.isNumber(maxH)) {\n      return 1;\n    }\n    const w = bounds.right - bounds.left;\n    const h = bounds.bottom - bounds.top;\n    return Math.min(maxW / w || 1, maxH / h || 1);\n  }\n  _truncateText(context, text, maxWidth) {\n    let breakWords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let fallbackBreakWords = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let width;\n    do {\n      if (breakWords) {\n        text = text.slice(0, -1);\n      } else {\n        let tmp = text.replace(/[^,;:!?\\\\\\/\\s]+[,;:!?\\\\\\/\\s]*$/g, \"\");\n        if ((tmp == \"\" || tmp === text) && fallbackBreakWords) {\n          breakWords = true;\n        } else if (tmp == \"\") {\n          return text;\n        } else {\n          text = tmp;\n        }\n      }\n      const metrics = this._measureText(text, context);\n      width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n    } while (width > maxWidth && text != \"\");\n    return text;\n  }\n  _measureText(text, context) {\n    let metrics = context.measureText(text);\n    let fakeMetrics = {};\n    if (metrics.actualBoundingBoxAscent == null) {\n      const div = document.createElement(\"div\");\n      div.innerText = text;\n      div.style.visibility = \"hidden\";\n      div.style.position = \"absolute\";\n      div.style.top = \"-1000000px;\";\n      div.style.fontFamily = this.style.fontFamily || \"\";\n      div.style.fontSize = this.style.fontSize + \"\";\n      document.body.appendChild(div);\n      const bbox = div.getBoundingClientRect();\n      document.body.removeChild(div);\n      const h = bbox.height;\n      const w = metrics.width;\n      let left = 0;\n      let right = w;\n      fakeMetrics = {\n        actualBoundingBoxAscent: h,\n        actualBoundingBoxDescent: 0,\n        actualBoundingBoxLeft: left,\n        actualBoundingBoxRight: right,\n        fontBoundingBoxAscent: h,\n        fontBoundingBoxDescent: 0,\n        width: w\n      };\n      //return fake;\n    } else {\n      fakeMetrics = {\n        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,\n        actualBoundingBoxRight: metrics.actualBoundingBoxRight,\n        fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n        fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n        width: metrics.width\n      };\n    }\n    const w = metrics.width;\n    switch (this.style.textAlign) {\n      case \"right\":\n      case \"end\":\n        fakeMetrics.actualBoundingBoxLeft = w;\n        fakeMetrics.actualBoundingBoxRight = 0;\n        break;\n      case \"center\":\n        fakeMetrics.actualBoundingBoxLeft = w / 2;\n        fakeMetrics.actualBoundingBoxRight = w / 2;\n        break;\n      default:\n        fakeMetrics.actualBoundingBoxLeft = 0;\n        fakeMetrics.actualBoundingBoxRight = w;\n    }\n    return fakeMetrics;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasTextStyle {\n  constructor() {\n    //public wordWrapWidth: number = 100;\n    Object.defineProperty(this, \"fill\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fillOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textAlign\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontFamily\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontWeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontVariant\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textDecoration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowColor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowBlur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // leading?: number;\n    // letterSpacing?: number;\n    Object.defineProperty(this, \"lineHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: percent(120)\n    });\n    Object.defineProperty(this, \"baselineRatio\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0.19\n    });\n    // padding?: number;\n    // stroke?: number;\n    // strokeThickness?: number;\n    // trim?: number;\n    // wordWrap?: boolean;\n    Object.defineProperty(this, \"direction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textBaseline\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"oversizedBehavior\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"none\"\n    });\n    Object.defineProperty(this, \"breakWords\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"ellipsis\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"\"\n    });\n    Object.defineProperty(this, \"maxWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"maxHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"minScale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ignoreFormatting\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasRadialText extends CanvasText {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"textType\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"circular\"\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"startAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inside\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"orientation\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"auto\"\n    });\n    Object.defineProperty(this, \"kerning\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_textReversed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _render(status) {\n    switch (this.textType) {\n      case \"circular\":\n        this._renderCircular(status);\n        break;\n      default:\n        super._render(status);\n        break;\n    }\n  }\n  _renderCircular(status) {\n    if (this.textVisible) {\n      this._prerender(status);\n      const interactive = this._isInteractive(status);\n      const context = status.layer.context;\n      const layerDirty = status.layer.dirty;\n      const ghostContext = this._renderer._ghostLayer.context;\n      // Savepoint\n      context.save();\n      if (interactive) {\n        ghostContext.save();\n      }\n      // We need measurements in order to properly position text for alignment\n      if (!this._textInfo) {\n        this._measure(status);\n      }\n      // Init\n      let radius = this.radius || 0;\n      let startAngle = this.startAngle || 0;\n      let deltaAngle = 0;\n      let orientation = this.orientation;\n      let inward = orientation == \"auto\" ? \"auto\" : orientation == \"inward\";\n      const inside = this.inside;\n      const align = this.style.textAlign || \"left\";\n      const kerning = this.kerning || 0;\n      let clockwise = align == \"left\" ? 1 : -1;\n      const shouldReverse = !this._textReversed;\n      // Check if we need to invert the whole stuff\n      if (inward == \"auto\") {\n        // Calc max angle so we know whether we need to flip it\n        let maxAngle = 0;\n        let midAngle = 0;\n        $array.each(this._textInfo, (line, _index) => {\n          const deltaAngle = startAngle + line.width / (radius - line.height) / 2 * -clockwise;\n          if (deltaAngle > maxAngle) {\n            maxAngle = deltaAngle;\n          }\n        });\n        if (align == \"left\") {\n          midAngle = (maxAngle + deltaAngle / 2) * $math.DEGREES;\n        } else if (align == \"right\") {\n          midAngle = (maxAngle - deltaAngle / 2) * $math.DEGREES;\n        } else {\n          midAngle = startAngle * $math.DEGREES;\n        }\n        midAngle = $math.normalizeAngle(midAngle);\n        inward = midAngle >= 270 || midAngle <= 90;\n      }\n      if (inward == true && shouldReverse) {\n        this._textInfo.reverse();\n        this._textReversed = true;\n      }\n      // if ((inward == false && align == \"left\") || (inward == true && align == \"right\")) {\n      // \tclockwise *= -1;\n      // }\n      // Process text info produced by _measure()\n      $array.each(this._textInfo, (line, _index) => {\n        const textHeight = line.height;\n        // Adjust radius (for `inside = false`)\n        // Radius adjustment for `inside = false` is below the line calculation\n        if (!inside) {\n          radius += textHeight;\n        }\n        // Reverse letters if we're painting them counter-clockwise\n        if ((clockwise == -1 && inward || clockwise == 1 && !inward) && shouldReverse) {\n          line.textChunks.reverse();\n        }\n        // Init angles\n        let lineStartAngle = startAngle;\n        deltaAngle = 0;\n        // Adjust for center-align\n        if (align == \"center\") {\n          lineStartAngle += line.width / (radius - textHeight) / 2 * -clockwise;\n          deltaAngle = lineStartAngle - startAngle;\n        }\n        // if (inward == \"auto\") {\n        // \tlet midAngle;\n        // \tif (align == \"left\") {\n        // \t\tmidAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;\n        // \t}\n        // \telse if () {\n        // \t\tmidAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;\n        // \t}\n        // \tinward = (midAngle >= 270) || (midAngle <= 90);\n        // }\n        // Rotate letters if they are facing outward\n        lineStartAngle += Math.PI * (inward ? 0 : 1); // Rotate 180 if outward\n        // Savepoint\n        context.save();\n        if (interactive) {\n          ghostContext.save();\n        }\n        // Assume starting angle\n        context.rotate(lineStartAngle);\n        if (interactive) {\n          ghostContext.rotate(lineStartAngle);\n        }\n        let angleShift = 0;\n        $array.each(line.textChunks, (chunk, _index) => {\n          // Draw the letter\n          const char = chunk.text;\n          const charWidth = chunk.width;\n          // Rotate half a letter\n          angleShift = charWidth / 2 / (radius - textHeight) * clockwise;\n          context.rotate(angleShift);\n          if (interactive) {\n            ghostContext.rotate(angleShift);\n          }\n          // Set style\n          if (chunk.style) {\n            context.save();\n            ghostContext.save();\n            context.font = chunk.style;\n            if (interactive) {\n              ghostContext.font = chunk.style;\n            }\n          }\n          if (chunk.fill) {\n            context.save();\n            context.fillStyle = chunk.fill.toCSS();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Center letters\n          context.textBaseline = \"middle\";\n          context.textAlign = \"center\";\n          if (interactive) {\n            ghostContext.textBaseline = \"middle\";\n            ghostContext.textAlign = \"center\";\n          }\n          // Plop the letter\n          if (layerDirty) {\n            context.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n          }\n          if (interactive) {\n            ghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n          }\n          if (chunk.fill) {\n            context.restore();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Reset style\n          if (chunk.style) {\n            context.restore();\n            ghostContext.restore();\n          }\n          // Rotate half a letter and add spacing\n          angleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;\n          context.rotate(angleShift);\n          if (interactive) {\n            ghostContext.rotate(angleShift);\n          }\n        });\n        // Restore angle\n        context.restore();\n        if (interactive) {\n          ghostContext.restore();\n        }\n        // Adjust radius (for `inside = true`)\n        if (inside) {\n          radius -= textHeight;\n        }\n      });\n      // Restore\n      context.restore();\n      if (interactive) {\n        ghostContext.restore();\n      }\n    }\n  }\n  _measure(status) {\n    switch (this.textType) {\n      case \"circular\":\n        return this._measureCircular(status);\n      default:\n        return super._measure(status);\n    }\n  }\n  _measureCircular(status) {\n    const context = status.layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    const rtl = this.style.direction == \"rtl\";\n    const oversizedBehavior = this.style.oversizedBehavior;\n    const maxWidth = this.style.maxWidth;\n    const truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n    const ellipsis = this.style.ellipsis || \"\";\n    let ellipsisMetrics;\n    //const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n    // Reset text info\n    this.textVisible = true;\n    this._textInfo = [];\n    this._textReversed = false;\n    // Pre-render\n    context.save();\n    ghostContext.save();\n    this._prerender(status, true);\n    // Split up text into lines\n    const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n    let styleRestored = true;\n    let totalWidth = 0;\n    // Iterate through the lines\n    let offsetY = 0;\n    $array.each(lines, (line, _index) => {\n      // Split up line into format/value chunks\n      let chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n      // Init line object\n      let lineInfo = {\n        offsetY: offsetY,\n        ascent: 0,\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        textChunks: []\n      };\n      let currentStyle;\n      let currentFill;\n      let currentChunkWidth;\n      //while(chunk = chunks.shift()) {\n      $array.each(chunks, (chunk, _index) => {\n        // Format chunk\n        if (chunk.type == \"format\") {\n          if (chunk.text == \"[/]\") {\n            if (!styleRestored) {\n              context.restore();\n              ghostContext.restore();\n              styleRestored = true;\n            }\n            currentFill = undefined;\n            currentStyle = undefined;\n            currentChunkWidth = undefined;\n          } else {\n            let format = TextFormatter.getTextStyle(chunk.text);\n            const fontStyle = this._getFontStyle(format);\n            context.save();\n            ghostContext.save();\n            context.font = fontStyle;\n            currentStyle = fontStyle;\n            if (format.fill) {\n              currentFill = format.fill;\n            }\n            if (format.width) {\n              currentChunkWidth = $type.toNumber(format.width);\n            }\n            styleRestored = false;\n          }\n          if (truncate) {\n            ellipsisMetrics = this._measureText(ellipsis, context);\n          }\n        }\n        // Text format\n        else if (chunk.type == \"value\") {\n          // Measure each letter\n          let chars = chunk.text.match(/./ug) || [];\n          if (rtl) {\n            chars = $utils.splitString(chunk.text);\n            chars.reverse();\n          }\n          for (let i = 0; i < chars.length; i++) {\n            const char = chars[i];\n            // Measure\n            const metrics = this._measureText(char, context);\n            let chunkWidth = metrics.width;\n            // Chunk width?\n            if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n              chunkWidth = currentChunkWidth;\n            }\n            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            if (chunkHeight > lineInfo.height) {\n              lineInfo.height = chunkHeight;\n            }\n            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n              lineInfo.ascent = metrics.actualBoundingBoxAscent;\n            }\n            totalWidth += chunkWidth;\n            // Handle oversized behavior\n            if (truncate) {\n              // Measure ellipsis and check if it fits\n              if (!ellipsisMetrics) {\n                ellipsisMetrics = this._measureText(ellipsis, context);\n              }\n              const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n              //totalWidth += ellipsisWidth;\n              if (totalWidth + ellipsisWidth > maxWidth) {\n                if (lineInfo.textChunks.length == 1) {\n                  this.textVisible = false;\n                } else {\n                  lineInfo.width += ellipsisWidth;\n                  lineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;\n                  lineInfo.right += ellipsisMetrics.actualBoundingBoxRight;\n                  lineInfo.textChunks.push({\n                    style: currentStyle,\n                    fill: currentFill,\n                    text: ellipsis,\n                    width: ellipsisWidth,\n                    height: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,\n                    left: ellipsisMetrics.actualBoundingBoxLeft,\n                    right: ellipsisMetrics.actualBoundingBoxRight,\n                    ascent: ellipsisMetrics.actualBoundingBoxAscent,\n                    offsetX: 0,\n                    offsetY: chunkHeight,\n                    textDecoration: undefined\n                  });\n                }\n                break;\n              }\n            }\n            lineInfo.width += chunkWidth;\n            lineInfo.left += metrics.actualBoundingBoxLeft;\n            lineInfo.right += metrics.actualBoundingBoxRight;\n            lineInfo.textChunks.push({\n              style: currentStyle,\n              fill: currentFill,\n              text: char,\n              width: chunkWidth,\n              height: chunkHeight + metrics.actualBoundingBoxDescent,\n              left: metrics.actualBoundingBoxLeft,\n              right: metrics.actualBoundingBoxRight,\n              ascent: metrics.actualBoundingBoxAscent,\n              offsetX: 0,\n              offsetY: chunkHeight,\n              textDecoration: undefined\n            });\n            if (rtl) {\n              // @todo still needed?\n              //break;\n            }\n          }\n        }\n      });\n      if (this.style.lineHeight instanceof Percent) {\n        lineInfo.height *= this.style.lineHeight.value;\n      } else {\n        lineInfo.height *= this.style.lineHeight || 1.2;\n      }\n      this._textInfo.push(lineInfo);\n      //lineInfo.offsetY += lineInfo.ascent;\n      offsetY += lineInfo.height;\n    });\n    if (!styleRestored) {\n      context.restore();\n      ghostContext.restore();\n    }\n    if (oversizedBehavior == \"hide\" && totalWidth > maxWidth) {\n      this.textVisible = false;\n    }\n    // Adjust chunk internal offsets\n    $array.each(this._textInfo, lineInfo => {\n      $array.each(lineInfo.textChunks, chunk => {\n        chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);\n      });\n    });\n    context.restore();\n    ghostContext.restore();\n    return {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasImage extends CanvasDisplayObject {\n  constructor(renderer, image) {\n    super(renderer);\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"image\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowColor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowBlur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_imageMask\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.image = image;\n  }\n  _dispose() {\n    super._dispose();\n    if (this._imageMask) {\n      clearCanvas(this._imageMask);\n    }\n  }\n  getLocalBounds() {\n    if (!this._localBounds) {\n      let w = 0;\n      let h = 0;\n      if (this.width) {\n        w = this.width;\n      }\n      if (this.height) {\n        h = this.height;\n      }\n      this._localBounds = {\n        left: 0,\n        top: 0,\n        right: w,\n        bottom: h\n      };\n      this._addBounds(this._localBounds);\n    }\n    return this._localBounds;\n  }\n  _render(status) {\n    super._render(status);\n    if (this.image) {\n      if (this.tainted === undefined) {\n        this.tainted = isTainted(this.image);\n        status.layer.tainted = true;\n      }\n      if (this.tainted && this._renderer._omitTainted) {\n        return;\n      }\n      if (status.layer.dirty) {\n        if (this.shadowColor) {\n          status.layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);\n        }\n        if (this.shadowBlur) {\n          status.layer.context.shadowBlur = this.shadowBlur;\n        }\n        if (this.shadowOffsetX) {\n          status.layer.context.shadowOffsetX = this.shadowOffsetX;\n        }\n        if (this.shadowOffsetY) {\n          status.layer.context.shadowOffsetY = this.shadowOffsetY;\n        }\n        // TODO should this round ?\n        const width = this.width || this.image.naturalWidth;\n        const height = this.height || this.image.naturalHeight;\n        status.layer.context.drawImage(this.image, 0, 0, width, height);\n      }\n      if (this.interactive && this._isInteractive(status)) {\n        const mask = this._getMask(this.image);\n        this._renderer._ghostLayer.context.drawImage(mask, 0, 0);\n      }\n    }\n  }\n  clear() {\n    super.clear();\n    this.image = undefined;\n    this._imageMask = undefined;\n  }\n  _getMask(image) {\n    if (this._imageMask === undefined) {\n      // TODO should this round ?\n      const width = this.width || image.naturalWidth;\n      const height = this.height || image.naturalHeight;\n      // We need to create a second canvas because destination-in clears out the entire canvas\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = width;\n      canvas.height = height;\n      const context = canvas.getContext(\"2d\");\n      context.imageSmoothingEnabled = false;\n      context.fillStyle = this._getColorId();\n      context.fillRect(0, 0, width, height);\n      if (!isTainted(image)) {\n        context.globalCompositeOperation = \"destination-in\";\n        context.drawImage(image, 0, 0, width, height);\n      }\n      this._imageMask = canvas;\n    }\n    return this._imageMask;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasRendererEvent {\n  constructor(event, originalPoint, point, bbox) {\n    Object.defineProperty(this, \"event\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: event\n    });\n    Object.defineProperty(this, \"originalPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: originalPoint\n    });\n    Object.defineProperty(this, \"point\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: point\n    });\n    Object.defineProperty(this, \"bbox\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: bbox\n    });\n    Object.defineProperty(this, \"id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"simulated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"native\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    if ($utils.supports(\"touchevents\") && event instanceof Touch) {\n      this.id = event.identifier;\n    } else {\n      this.id = null;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasRenderer extends ArrayDisposer {\n  constructor(resolution) {\n    super();\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"div\")\n    });\n    Object.defineProperty(this, \"_layerDom\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"div\")\n    });\n    Object.defineProperty(this, \"layers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_dirtyLayers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"defaultLayer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.getLayer(0)\n    });\n    Object.defineProperty(this, \"_ghostLayer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new GhostLayer()\n    });\n    Object.defineProperty(this, \"_patternCanvas\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"canvas\")\n    });\n    Object.defineProperty(this, \"_patternContext\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._patternCanvas.getContext(\"2d\")\n    });\n    Object.defineProperty(this, \"_realWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_realHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_calculatedWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_calculatedHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"resolution\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"interactionsEnabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"_listeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_events\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_colorId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_colorMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_forceInteractive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_omitTainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    // TODO this should store the Id as well\n    Object.defineProperty(this, \"_hovering\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"_dragging\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_mousedown\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_lastPointerMoveEvent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tapToActivate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"tapToActivateTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3000\n    });\n    Object.defineProperty(this, \"_touchActive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_touchActiveTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (resolution == null) {\n      this.resolution = window.devicePixelRatio;\n    } else {\n      this.resolution = resolution;\n    }\n    this.view.style.position = \"absolute\";\n    this.view.setAttribute(\"aria-hidden\", \"true\");\n    this.view.appendChild(this._layerDom);\n    this._disposers.push(new Disposer(() => {\n      $object.each(this._events, (_key, events) => {\n        events.disposer.dispose();\n      });\n      $array.each(this.layers, layer => {\n        clearCanvas(layer.view);\n        if (layer.exportableView) {\n          clearCanvas(layer.exportableView);\n        }\n      });\n      clearCanvas(this._ghostLayer.view);\n      clearCanvas(this._patternCanvas);\n    }));\n    /*\r\n    this._disposers.push($utils.addEventListener(this._ghostLayer.view, \"click\", (originalEvent: MouseEvent) => {\r\n        const event = this.getEvent(originalEvent);\r\n        const target = this._getHitTarget(event.originalPoint, event.bbox);\r\n        console.debug(target);\r\n    }));\r\n    */\n    // Monitor for possible pixel ratio changes (when page is zoomed)\n    this._disposers.push($utils.onZoom(() => {\n      if (resolution == null) {\n        this.resolution = window.devicePixelRatio;\n      }\n    }));\n    // We need this in order top prevent default touch gestures when dragging\n    // draggable elements\n    if ($utils.supports(\"touchevents\")) {\n      const listener = ev => {\n        if (this._dragging.length !== 0) {\n          $array.eachContinue(this._dragging, item => {\n            if (item.value.shouldCancelTouch()) {\n              ev.preventDefault();\n              return false;\n            }\n            return true;\n          });\n        }\n        // If touch down happends, delay touch out\n        if (this._touchActiveTimeout) {\n          this._delayTouchDeactivate();\n        }\n      };\n      this._disposers.push($utils.addEventListener(window, \"touchstart\", listener, {\n        passive: false\n      }));\n      this._disposers.push($utils.addEventListener(this.view, \"touchstart\", listener, {\n        passive: false\n      }));\n      this._disposers.push($utils.addEventListener(this.view, \"touchmove\", () => {\n        // If touch is moving, delay touch out\n        if (this._touchActiveTimeout) {\n          this._delayTouchDeactivate();\n        }\n      }, {\n        passive: true\n      }));\n      this._disposers.push($utils.addEventListener(window, \"click\", _ev => {\n        this._touchActive = false;\n      }, {\n        passive: true\n      }));\n      this._disposers.push($utils.addEventListener(this.view, \"click\", _ev => {\n        window.setTimeout(() => {\n          this._touchActive = true;\n          this._delayTouchDeactivate();\n        }, 100);\n      }, {\n        passive: true\n      }));\n    }\n    // Prevent scrolling of the window when hovering on \"wheelable\" object\n    if ($utils.supports(\"wheelevents\")) {\n      this._disposers.push($utils.addEventListener(this.view, \"wheel\", ev => {\n        let prevent = false;\n        this._hovering.forEach(obj => {\n          if (obj.wheelable) {\n            prevent = true;\n            return false;\n          }\n        });\n        if (prevent) {\n          ev.preventDefault();\n        }\n      }, {\n        passive: false\n      }));\n    }\n  }\n  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {\r\n      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);\r\n  });\r\n  */\n  resetImageArray() {\n    this._ghostLayer.imageArray = undefined;\n  }\n  _delayTouchDeactivate() {\n    if (this._touchActiveTimeout) {\n      clearTimeout(this._touchActiveTimeout);\n    }\n    if (this.tapToActivateTimeout > 0) {\n      this._touchActiveTimeout = window.setTimeout(() => {\n        this._touchActive = false;\n      }, this.tapToActivateTimeout);\n    }\n  }\n  get debugGhostView() {\n    return !!this._ghostLayer.view.parentNode;\n  }\n  set debugGhostView(value) {\n    if (value) {\n      if (!this._ghostLayer.view.parentNode) {\n        this.view.appendChild(this._ghostLayer.view);\n      }\n    } else {\n      if (this._ghostLayer.view.parentNode) {\n        this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);\n      }\n    }\n  }\n  createLinearGradient(x1, y1, x2, y2) {\n    return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);\n  }\n  createRadialGradient(x1, y1, radius1, x2, y2, radius2) {\n    return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);\n  }\n  createPattern(graphics, background, repetition, width, height) {\n    // const patternCanvas = document.createElement(\"canvas\");\n    // const patternContext = patternCanvas.getContext(\"2d\")!;\n    // patternCanvas.width = width;\n    // patternCanvas.height = height;\n    // if (fill) {\n    // \tpatternContext.fillStyle = fill.toCSS();\n    // \tpatternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);\n    // }\n    // const layer = {\n    // \tview: patternCanvas,\n    // \tcontext: patternContext,\n    // \tvisible: true,\n    // \torder: 0,\n    // \twidth: width,\n    // \theight: height,\n    // \tdirty: true\n    // };\n    // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);\n    // // patternContext.stroke();\n    // image.targetLayer = layer;\n    // image.render(layer);\n    //this._layerDom.appendChild(patternCanvas);\n    this._patternCanvas.width = width;\n    this._patternCanvas.height = height;\n    this._patternContext.clearRect(0, 0, width, height);\n    // patternCanvas.style.width = width * this.resolution + \"px\";\n    // patternCanvas.style.height = height * this.resolution + \"px\";\n    background.renderDetached(this._patternContext);\n    graphics.renderDetached(this._patternContext);\n    return this._patternContext.createPattern(this._patternCanvas, repetition);\n  }\n  makeContainer() {\n    return new CanvasContainer(this);\n  }\n  makeGraphics() {\n    return new CanvasGraphics(this);\n  }\n  makeText(text, style) {\n    return new CanvasText(this, text, style);\n  }\n  makeTextStyle() {\n    return new CanvasTextStyle();\n  }\n  makeRadialText(text, style) {\n    return new CanvasRadialText(this, text, style);\n  }\n  makePicture(image) {\n    return new CanvasImage(this, image);\n  }\n  resizeLayer(layer) {\n    layer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);\n  }\n  resizeGhost() {\n    this._ghostLayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);\n  }\n  resize(realWidth, realHeight, calculatedWidth, calculatedHeight) {\n    this._realWidth = realWidth;\n    this._realHeight = realHeight;\n    this._calculatedWidth = calculatedWidth;\n    this._calculatedHeight = calculatedHeight;\n    $array.each(this.layers, layer => {\n      if (layer) {\n        layer.dirty = true;\n        this.resizeLayer(layer);\n      }\n    });\n    this.resizeGhost();\n    this.view.style.width = calculatedWidth + \"px\";\n    this.view.style.height = calculatedHeight + \"px\";\n  }\n  createDetachedLayer() {\n    let willReadFrequently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const view = document.createElement(\"canvas\");\n    const context = view.getContext(\"2d\", {\n      willReadFrequently: willReadFrequently\n    });\n    const layer = new CanvasLayer(view, context);\n    view.style.position = \"absolute\";\n    view.style.top = \"0px\";\n    view.style.left = \"0px\";\n    return layer;\n  }\n  getLayerByOrder(order) {\n    const layers = this.layers;\n    const length = layers.length;\n    for (let i = 0; i < length; i++) {\n      const layer = layers[i];\n      if (layer.order == order) {\n        return layer;\n      }\n    }\n  }\n  getLayer(order) {\n    let visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let existingLayer = this.getLayerByOrder(order);\n    if (existingLayer) {\n      return existingLayer;\n    }\n    const layer = this.createDetachedLayer(order == 99);\n    layer.order = order;\n    layer.visible = visible;\n    layer.view.className = \"am5-layer-\" + order;\n    if (layer.visible) {\n      this.resizeLayer(layer);\n    }\n    const layers = this.layers;\n    layers.push(layer);\n    layers.sort((a, b) => {\n      if (a.order > b.order) {\n        return 1;\n      } else if (a.order < b.order) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n    const length = layers.length;\n    const layerIndex = $array.indexOf(layers, layer);\n    let next;\n    for (let i = layerIndex + 1; i < length; i++) {\n      if (layers[i].visible) {\n        next = layers[i];\n        break;\n      }\n    }\n    if (layer.visible) {\n      if (next === undefined) {\n        this._layerDom.appendChild(layer.view);\n      } else {\n        this._layerDom.insertBefore(layer.view, next.view);\n      }\n    }\n    return layer;\n  }\n  render(root) {\n    this._dirtyLayers.length = 0;\n    $array.each(this.layers, layer => {\n      if (layer) {\n        if (layer.dirty && layer.visible) {\n          this._dirtyLayers.push(layer);\n          layer.clear();\n        }\n      }\n    });\n    this._ghostLayer.clear();\n    root.render({\n      inactive: null,\n      layer: this.defaultLayer\n    });\n    this._ghostLayer.context.restore();\n    //setTimeout(() => {\n    // Remove this after the Chrome bug is fixed:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394\n    $array.each(this.layers, layer => {\n      if (layer) {\n        const context = layer.context;\n        context.beginPath();\n        context.moveTo(0, 0);\n        context.stroke();\n      }\n    });\n    $array.each(this._dirtyLayers, layer => {\n      layer.context.restore();\n      layer.dirty = false;\n    });\n    //}, 100)\n    if (this._hovering.size && this._lastPointerMoveEvent) {\n      const {\n        events,\n        target,\n        native\n      } = this._lastPointerMoveEvent;\n      //this._mouseMoveThrottler.run();\n      $array.each(events, event => {\n        this._dispatchGlobalMousemove(event, target, native);\n      });\n    }\n  }\n  paintId(obj) {\n    const id = distributeId(++this._colorId);\n    const color = Color.fromHex(id).toCSS();\n    this._colorMap[color] = obj;\n    return color;\n  }\n  _removeObject(obj) {\n    if (obj._colorId !== undefined) {\n      delete this._colorMap[obj._colorId];\n    }\n  }\n  // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {\n  // \treturn this._colorMap[colorId];\n  // }\n  _adjustBoundingBox(bbox) {\n    const margin = this._ghostLayer.margin;\n    return new DOMRect(-margin.left, -margin.top, bbox.width + margin.left + margin.right, bbox.height + margin.top + margin.bottom);\n  }\n  getEvent(originalEvent) {\n    let adjustPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const bbox = this.view.getBoundingClientRect();\n    const x = originalEvent.clientX || 0;\n    const y = originalEvent.clientY || 0;\n    const widthScale = this._calculatedWidth / this._realWidth;\n    const heightScale = this._calculatedHeight / this._realHeight;\n    const originalPoint = {\n      x: x - bbox.left,\n      y: y - bbox.top\n    };\n    const point = {\n      x: (x - (adjustPoint ? bbox.left : 0)) * widthScale,\n      y: (y - (adjustPoint ? bbox.top : 0)) * heightScale\n    };\n    return new CanvasRendererEvent(originalEvent, originalPoint, point, this._adjustBoundingBox(bbox));\n  }\n  _getHitTarget(point, bbox, target) {\n    if (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {\n      return;\n    }\n    if (!target || !this._layerDom.contains(target)) {\n      return;\n    }\n    const pixel = this._ghostLayer.getImageData(point, bbox);\n    if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {\n      return false;\n    }\n    const colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();\n    const hit = this._colorMap[colorId];\n    return hit;\n  }\n  getObjectAtPoint(point) {\n    const data = this._ghostLayer.getImageArray(point);\n    if (data[0] === 0 && data[1] === 0 && data[2] === 0) {\n      return undefined;\n    }\n    const colorId = Color.fromRGB(data[0], data[1], data[2]).toCSS();\n    const hit = this._colorMap[colorId];\n    return hit;\n  }\n  _withEvents(key, f) {\n    const events = this._events[key];\n    if (events !== undefined) {\n      events.dispatching = true;\n      try {\n        f(events);\n      } finally {\n        events.dispatching = false;\n        if (events.cleanup) {\n          events.cleanup = false;\n          $array.keepIf(events.callbacks, callback => {\n            return !callback.disposed;\n          });\n          if (events.callbacks.length === 0) {\n            events.disposer.dispose();\n            delete this._events[key];\n          }\n        }\n      }\n    }\n  }\n  _dispatchEventAll(key, event) {\n    if (!this.interactionsEnabled) {\n      return;\n    }\n    this._withEvents(key, events => {\n      $array.each(events.callbacks, callback => {\n        if (!callback.disposed) {\n          callback.callback.call(callback.context, event);\n        }\n      });\n    });\n  }\n  _dispatchEvent(key, target, event) {\n    if (!this.interactionsEnabled) {\n      return false;\n    }\n    let dispatched = false;\n    this._withEvents(key, events => {\n      $array.each(events.callbacks, callback => {\n        if (!callback.disposed && callback.object === target) {\n          callback.callback.call(callback.context, event);\n          dispatched = true;\n        }\n      });\n    });\n    return dispatched;\n  }\n  _dispatchMousedown(originalEvent, originalTarget) {\n    const button = originalEvent.button;\n    if (button != 0 && button != 2 && button != 1 && button !== undefined) {\n      // Ignore non-primary mouse buttons\n      return;\n    }\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      const id = event.id;\n      let dragged = false;\n      eachTargets(target, obj => {\n        const info = {\n          id: id,\n          value: obj\n        };\n        this._mousedown.push(info);\n        if (!dragged && this._dispatchEvent(\"pointerdown\", obj, event)) {\n          // Only dispatch the first element which matches\n          dragged = true;\n          const has = this._dragging.some(x => {\n            return x.value === obj && x.id === id;\n          });\n          if (!has) {\n            this._dragging.push(info);\n          }\n        }\n        return true;\n      });\n    }\n  }\n  _dispatchGlobalMousemove(originalEvent, originalTarget, native) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    event.native = native;\n    if (target) {\n      this._hovering.forEach(obj => {\n        if (!obj.contains(target)) {\n          this._hovering.delete(obj);\n          if (obj.cursorOverStyle) {\n            $utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle);\n          }\n          this._dispatchEvent(\"pointerout\", obj, event);\n        }\n      });\n      if (event.native) {\n        eachTargets(target, obj => {\n          if (!this._hovering.has(obj)) {\n            this._hovering.add(obj);\n            if (obj.cursorOverStyle) {\n              obj._replacedCursorStyle = $utils.getStyle(document.body, \"cursor\");\n              $utils.setStyle(document.body, \"cursor\", obj.cursorOverStyle);\n            }\n            this._dispatchEvent(\"pointerover\", obj, event);\n          }\n          return true;\n        });\n      }\n      //} else if (target === false) {\n    } else {\n      this._hovering.forEach(obj => {\n        if (obj.cursorOverStyle) {\n          $utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle);\n        }\n        this._dispatchEvent(\"pointerout\", obj, event);\n      });\n      this._hovering.clear();\n    }\n    this._dispatchEventAll(\"globalpointermove\", event);\n  }\n  removeHovering(graphics) {\n    this._hovering.delete(graphics);\n    if (graphics.cursorOverStyle) {\n      $utils.setStyle(document.body, \"cursor\", graphics._replacedCursorStyle);\n    }\n  }\n  _dispatchGlobalMouseup(originalEvent, native) {\n    const event = this.getEvent(originalEvent);\n    event.native = native;\n    //const target = this._getHitTarget(event.originalPoint);\n    this._dispatchEventAll(\"globalpointerup\", event);\n  }\n  _dispatchDragMove(originalEvent) {\n    if (this._dragging.length !== 0) {\n      const event = this.getEvent(originalEvent);\n      const id = event.id;\n      this._dragging.forEach(obj => {\n        if (obj.id === id) {\n          this._dispatchEvent(\"pointermove\", obj.value, event);\n        }\n      });\n    }\n  }\n  _dispatchDragEnd(originalEvent, originalTarget) {\n    const button = originalEvent.button;\n    let clickevent;\n    if (button == 0 || button === undefined) {\n      clickevent = \"click\";\n    } else if (button == 2) {\n      clickevent = \"rightclick\";\n    } else if (button == 1) {\n      clickevent = \"middleclick\";\n    } else {\n      // Ignore non-primary mouse buttons\n      return;\n    }\n    const event = this.getEvent(originalEvent);\n    const id = event.id;\n    if (this._mousedown.length !== 0) {\n      const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n      if (target) {\n        this._mousedown.forEach(obj => {\n          if (obj.id === id && obj.value.contains(target)) {\n            this._dispatchEvent(clickevent, obj.value, event);\n          }\n        });\n      }\n      this._mousedown.length = 0;\n    }\n    if (this._dragging.length !== 0) {\n      this._dragging.forEach(obj => {\n        if (obj.id === id) {\n          this._dispatchEvent(\"pointerup\", obj.value, event);\n        }\n      });\n      this._dragging.length = 0;\n    }\n  }\n  _dispatchDoubleClick(originalEvent, originalTarget) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      eachTargets(target, obj => {\n        if (this._dispatchEvent(\"dblclick\", obj, event)) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  }\n  _dispatchWheel(originalEvent, originalTarget) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      eachTargets(target, obj => {\n        if (this._dispatchEvent(\"wheel\", obj, event)) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  }\n  _makeSharedEvent(key, f) {\n    if (this._listeners[key] === undefined) {\n      const listener = f();\n      this._listeners[key] = new CounterDisposer(() => {\n        delete this._listeners[key];\n        listener.dispose();\n      });\n    }\n    return this._listeners[key].increment();\n  }\n  _onPointerEvent(name, f) {\n    let native = false;\n    let timer = null;\n    function clear() {\n      timer = null;\n      native = false;\n    }\n    return new MultiDisposer([new Disposer(() => {\n      if (timer !== null) {\n        clearTimeout(timer);\n      }\n      clear();\n    }), $utils.addEventListener(this.view, $utils.getRendererEvent(name), _ => {\n      native = true;\n      if (timer !== null) {\n        clearTimeout(timer);\n      }\n      timer = window.setTimeout(clear, 0);\n    }), onPointerEvent(window, name, (ev, target) => {\n      if (timer !== null) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      f(ev, target, native);\n      native = false;\n    })]);\n  }\n  // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)\n  _initEvent(key) {\n    switch (key) {\n      case \"globalpointermove\":\n      case \"pointerover\":\n      case \"pointerout\":\n        return this._makeSharedEvent(\"pointermove\", () => {\n          const listener = (events, target, native) => {\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n            $array.each(events, event => {\n              this._dispatchGlobalMousemove(event, target, native);\n            });\n          };\n          return new MultiDisposer([this._onPointerEvent(\"pointerdown\", listener), this._onPointerEvent(\"pointermove\", listener)]);\n        });\n      case \"globalpointerup\":\n        return this._makeSharedEvent(\"pointerup\", () => {\n          const mouseup = this._onPointerEvent(\"pointerup\", (events, target, native) => {\n            $array.each(events, event => {\n              this._dispatchGlobalMouseup(event, native);\n            });\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n          });\n          const pointercancel = this._onPointerEvent(\"pointercancel\", (events, target, native) => {\n            $array.each(events, event => {\n              this._dispatchGlobalMouseup(event, native);\n            });\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n          });\n          return new Disposer(() => {\n            mouseup.dispose();\n            pointercancel.dispose();\n          });\n        });\n      case \"click\":\n      case \"rightclick\":\n      case \"middleclick\":\n      case \"pointerdown\":\n      /*\r\n          return this._makeSharedEvent(\"pointerdown\", () => {\r\n              return this._onPointerEvent(\"pointerdown\", (event, target, native) => {\r\n                  this._lastPointerMoveEvent = { event, target, native };\r\n                  this._dispatchMousedown(event)\r\n              });\r\n          });\r\n      */\n      case \"pointermove\":\n      case \"pointerup\":\n        return this._makeSharedEvent(\"pointerdown\", () => {\n          //const throttler = new Throttler();\n          const mousedown = this._onPointerEvent(\"pointerdown\", (events, target) => {\n            $array.each(events, ev => {\n              this._dispatchMousedown(ev, target);\n            });\n          });\n          // TODO handle throttling properly for multitouch\n          const mousemove = this._onPointerEvent(\"pointermove\", ev => {\n            //throttler.throttle(() => {\n            $array.each(ev, ev => {\n              this._dispatchDragMove(ev);\n            });\n            //});\n          });\n\n          const mouseup = this._onPointerEvent(\"pointerup\", (ev, target) => {\n            $array.each(ev, ev => {\n              this._dispatchDragEnd(ev, target);\n            });\n          });\n          const pointercancel = this._onPointerEvent(\"pointercancel\", (ev, target) => {\n            $array.each(ev, ev => {\n              this._dispatchDragEnd(ev, target);\n            });\n          });\n          return new Disposer(() => {\n            mousedown.dispose();\n            mousemove.dispose();\n            mouseup.dispose();\n            pointercancel.dispose();\n          });\n        });\n      case \"dblclick\":\n        return this._makeSharedEvent(\"dblclick\", () => {\n          return this._onPointerEvent(\"dblclick\", (ev, target) => {\n            $array.each(ev, ev => {\n              this._dispatchDoubleClick(ev, target);\n            });\n          });\n        });\n      case \"wheel\":\n        return this._makeSharedEvent(\"wheel\", () => {\n          return $utils.addEventListener(this.view, $utils.getRendererEvent(\"wheel\"), event => {\n            this._dispatchWheel(event, $utils.getEventTarget(event));\n          }, {\n            passive: false\n          });\n        });\n    }\n  }\n  _addEvent(object, key, callback, context) {\n    let events = this._events[key];\n    if (events === undefined) {\n      events = this._events[key] = {\n        disposer: this._initEvent(key),\n        callbacks: [],\n        dispatching: false,\n        cleanup: false\n      };\n    }\n    const listener = {\n      object,\n      context,\n      callback,\n      disposed: false\n    };\n    events.callbacks.push(listener);\n    return new Disposer(() => {\n      listener.disposed = true;\n      if (events.dispatching) {\n        events.cleanup = true;\n      } else {\n        $array.removeFirst(events.callbacks, listener);\n        if (events.callbacks.length === 0) {\n          events.disposer.dispose();\n          delete this._events[key];\n        }\n      }\n    });\n  }\n  getCanvas(root, options) {\n    // Make sure everything is rendered\n    this.render(root);\n    if (!options) {\n      options = {};\n    }\n    let scale = this.resolution;\n    let canvasWidth = Math.floor(this._calculatedWidth * this.resolution);\n    let canvasHeight = Math.floor(this._calculatedHeight * this.resolution);\n    // Check if we need to scale\n    if (options.minWidth && options.minWidth > canvasWidth) {\n      let minScale = options.minWidth / canvasWidth;\n      if (minScale > scale) {\n        scale = minScale * this.resolution;\n      }\n    }\n    if (options.minHeight && options.minHeight > canvasHeight) {\n      let minScale = options.minHeight / canvasHeight;\n      if (minScale > scale) {\n        scale = minScale * this.resolution;\n      }\n    }\n    if (options.maxWidth && options.maxWidth < canvasWidth) {\n      let maxScale = options.maxWidth / canvasWidth;\n      if (maxScale < scale) {\n        scale = maxScale * this.resolution;\n      }\n    }\n    if (options.maxHeight && options.maxHeight > canvasHeight) {\n      let maxScale = options.maxHeight / canvasHeight;\n      if (maxScale < scale) {\n        scale = maxScale * this.resolution;\n      }\n    }\n    // Check if we need to compensate for pixel ratio\n    if (options.maintainPixelRatio) {\n      scale /= this.resolution;\n    }\n    // Init list canvases to remove from DOM after export\n    const canvases = [];\n    // Set up new canvas for export\n    let forceRender = false;\n    const canvas = document.createElement(\"canvas\");\n    if (scale != this.resolution) {\n      forceRender = true;\n      canvasWidth = canvasWidth * scale / this.resolution;\n      canvasHeight = canvasHeight * scale / this.resolution;\n    }\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    // Add to DOM so it inherits CSS\n    canvas.style.position = \"fixed\";\n    canvas.style.top = \"-10000px\";\n    this.view.appendChild(canvas);\n    canvases.push(canvas);\n    // Context\n    const context = canvas.getContext(\"2d\");\n    let width = 0;\n    let height = 0;\n    let needRerender = false;\n    $array.each(this.layers, layer => {\n      if (layer && layer.visible) {\n        if (layer.tainted || forceRender) {\n          needRerender = true;\n          layer.exportableView = layer.view;\n          layer.exportableContext = layer.context;\n          layer.view = document.createElement(\"canvas\");\n          // Add to DOM so it inherits CSS\n          layer.view.style.position = \"fixed\";\n          layer.view.style.top = \"-10000px\";\n          this.view.appendChild(layer.view);\n          canvases.push(layer.view);\n          let extraX = 0;\n          let extraY = 0;\n          if (layer.margin) {\n            extraX += layer.margin.left || 0 + layer.margin.right || 0;\n            extraY += layer.margin.top || 0 + layer.margin.bottom || 0;\n          }\n          layer.view.width = canvasWidth + extraX;\n          layer.view.height = canvasHeight + extraY;\n          layer.context = layer.view.getContext(\"2d\");\n          layer.dirty = true;\n          layer.scale = scale;\n        }\n      }\n    });\n    if (needRerender) {\n      this._omitTainted = true;\n      this.render(root);\n      this._omitTainted = false;\n    }\n    $array.each(this.layers, layer => {\n      if (layer && layer.visible) {\n        // Layer is fine. Just plop it into our target canvas\n        let x = 0;\n        let y = 0;\n        if (layer.margin) {\n          x = -(layer.margin.left || 0) * this.resolution;\n          y = -(layer.margin.top || 0) * this.resolution;\n        }\n        context.drawImage(layer.view, x, y);\n        // Restore layer original canvas\n        if (layer.exportableView) {\n          layer.view = layer.exportableView;\n          layer.exportableView = undefined;\n        }\n        if (layer.exportableContext) {\n          layer.context = layer.exportableContext;\n          layer.exportableContext = undefined;\n        }\n        if (width < layer.view.clientWidth) {\n          width = layer.view.clientWidth;\n        }\n        if (height < layer.view.clientHeight) {\n          height = layer.view.clientHeight;\n        }\n        layer.scale = undefined;\n      }\n    });\n    canvas.style.width = width + \"px\";\n    canvas.style.height = height + \"px\";\n    $array.each(canvases, canvas => {\n      canvas.style.position = \"\";\n      canvas.style.top = \"\";\n      this.view.removeChild(canvas);\n    });\n    return canvas;\n  }\n}\nclass GhostLayer {\n  constructor() {\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"margin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(this, \"_resolution\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"_width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"imageArray\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.view = document.createElement(\"canvas\");\n    this.context = this.view.getContext(\"2d\", {\n      alpha: false,\n      willReadFrequently: true\n    });\n    this.context.imageSmoothingEnabled = false;\n    this.view.style.position = \"absolute\";\n    this.view.style.top = \"0px\";\n    this.view.style.left = \"0px\";\n  }\n  resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {\n    this._resolution = resolution;\n    canvasWidth += this.margin.left + this.margin.right;\n    canvasHeight += this.margin.top + this.margin.bottom;\n    // TODO this should take into account calculateSize\n    domWidth += this.margin.left + this.margin.right;\n    domHeight += this.margin.top + this.margin.bottom;\n    this.view.style.left = -this.margin.left + \"px\";\n    this.view.style.top = -this.margin.top + \"px\";\n    this._width = Math.floor(canvasWidth * resolution);\n    this._height = Math.floor(canvasHeight * resolution);\n    this.view.width = this._width;\n    this.view.style.width = domWidth + \"px\";\n    this.view.height = this._height;\n    this.view.style.height = domHeight + \"px\";\n  }\n  getImageData(point, bbox) {\n    return this.context.getImageData(\n    // TODO should this round ?\n    Math.round((point.x - bbox.left) / bbox.width * this._width), Math.round((point.y - bbox.top) / bbox.height * this._height), 1, 1);\n  }\n  getImageArray(point) {\n    if (!this.imageArray) {\n      this.imageArray = this.context.getImageData(0, 0, this._width, this._height).data;\n    }\n    const data = this.imageArray;\n    const x = Math.round(point.x * this._resolution);\n    const y = Math.round(point.y * this._resolution);\n    const i = (y * this._width + x) * 4;\n    return [data[i], data[i + 1], data[i + 2], data[i + 3]];\n  }\n  setMargin(layers) {\n    this.margin.left = 0;\n    this.margin.right = 0;\n    this.margin.top = 0;\n    this.margin.bottom = 0;\n    $array.each(layers, layer => {\n      if (layer.margin) {\n        this.margin.left = Math.max(this.margin.left, layer.margin.left);\n        this.margin.right = Math.max(this.margin.right, layer.margin.right);\n        this.margin.top = Math.max(this.margin.top, layer.margin.top);\n        this.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);\n      }\n    });\n  }\n  clear() {\n    this.context.save();\n    this.context.fillStyle = '#000';\n    this.context.fillRect(0, 0, this._width, this._height);\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasLayer {\n  constructor(view, context) {\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"margin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"order\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"visible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"scale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"dirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"exportableView\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"exportableContext\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    this.view = view;\n    this.context = context;\n  }\n  resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {\n    // TODO should this take into account calculateSize ?\n    if (this.width != null) {\n      canvasWidth = this.width;\n      domWidth = this.width;\n    }\n    // TODO should this take into account calculateSize ?\n    if (this.height != null) {\n      canvasHeight = this.height;\n      domHeight = this.height;\n    }\n    if (this.margin) {\n      canvasWidth += this.margin.left + this.margin.right;\n      canvasHeight += this.margin.top + this.margin.bottom;\n      // TODO this should take into account calculateSize\n      domWidth += this.margin.left + this.margin.right;\n      domHeight += this.margin.top + this.margin.bottom;\n      this.view.style.left = -this.margin.left + \"px\";\n      this.view.style.top = -this.margin.top + \"px\";\n    } else {\n      this.view.style.left = \"0px\";\n      this.view.style.top = \"0px\";\n    }\n    this._width = Math.floor(canvasWidth * resolution);\n    this._height = Math.floor(canvasHeight * resolution);\n    this.view.width = this._width;\n    this.view.style.width = domWidth + \"px\";\n    this.view.height = this._height;\n    this.view.style.height = domHeight + \"px\";\n  }\n  clear() {\n    this.context.save();\n    this.context.clearRect(0, 0, this._width, this._height);\n  }\n}","map":{"version":3,"names":["BlendMode","Color","Matrix","Percent","percent","ArrayDisposer","Disposer","DisposerClass","CounterDisposer","MultiDisposer","TextFormatter","$utils","$array","$object","$type","$math","arcToBezier","checkArgs","name","actual","expected","Error","checkMinArgs","checkEvenArgs","splitArcFlags","args","i","length","index","flag","a","exec","splice","assertBinary","value","distributeId","id","rgb","eachTargets","hitTarget","f","interactive","_parent","onPointerEvent","element","addEventListener","getRendererEvent","event","target","getEventTarget","touches","changedTouches","copy","isTainted","image","canvas","document","createElement","width","height","context","getContext","willReadFrequently","drawImage","getImageData","err","console","warn","src","clearCanvas","view","style","crisp","x","Math","floor","CanvasPivot","constructor","Object","defineProperty","_x","y","_y","CanvasDisplayObject","renderer","_renderer","subStatus","status","inactive","layer","_layer","_dispose","_removeObject","getLayer","dirty","getCanvas","self","defaultLayer","setLayer","order","margin","undefined","visible","setInteractive","_ghostLayer","setMargin","layers","registerChildLayer","resizeLayer","resizeGhost","markDirtyLayer","clear","invalidateBounds","_localBounds","_addBounds","_bounds","_getColorId","_colorId","paintId","_isInteractive","_forceInteractive","_isInteractiveMask","contains","child","toGlobal","point","_matrix","apply","toLocal","applyInverse","getLocalMatrix","_uMatrix","setTransform","pivot","angle","PI","scale","getLocalBounds","bn","left","top","right","bottom","getAdjustedBounds","bounds","_setMatrix","matrix","p0","p1","p2","p3","min","max","on","key","callback","_addEvent","_localMatrix","copyFrom","prepend","_transform","resolution","m","tx","ty","b","c","d","_transformMargin","_transformLayer","render","exportable","_omitTainted","ghostLayer","ghostContext","mask","each","save","_runPath","clip","globalAlpha","compoundAlpha","alpha","filter","_render","restore","tainted","hovering","_hovering","has","dragging","_dragging","some","shouldCancelTouch","tapToActivate","_touchActive","cancelTouch","CanvasContainer","interactiveChildren","addChild","_children","push","addChildAt","removeChild","removeFirst","_childLayers","pushOne","deep","arguments","setPoint","Op","colorize","_context","_forceColor","colorizeGhost","forceColor","path","pathGhost","addBounds","BeginPath","beginPath","BeginFill","color","fillStyle","EndFill","clearShadow","fill","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","EndStroke","stroke","LineStyle","lineJoin","lineCap","strokeStyle","lineWidth","LineDash","dash","setLineDash","LineDashOffset","dashOffset","lineDashOffset","DrawRect","rect","l","t","r","DrawCircle","radius","moveTo","arc","DrawEllipse","radiusX","radiusY","ellipse","Arc","cx","cy","startAngle","endAngle","anticlockwise","arcBounds","getArcBounds","DEGREES","ArcTo","x1","y1","x2","y2","arcTo","LineTo","lineTo","MoveTo","ClosePath","closePath","BezierCurveTo","cpX","cpY","cpX2","cpY2","toX","toY","bezierCurveTo","QuadraticCurveTo","quadraticCurveTo","Shadow","blur","offsetX","offsetY","opacity","GraphicsImage","CanvasGraphics","NORMAL","_operations","_pushOp","op","beginFill","_fillAlpha","toCSS","isMeasured","endFill","_hasShadows","endStroke","lineStyle","_strokeAlpha","setLineDashOffset","drawRect","drawCircle","drawEllipse","shadow","svgPath","cpx","cpy","qcpx","qcpy","SEGMENTS_REGEXP","ARGS_REGEXP","match","rest","relative","bs","px","py","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","layerDirty","globalCompositeOperation","blendMode","renderDetached","CanvasText","text","_textInfo","_shared","textAlign","direction","textBaseline","_prerender","ignoreGhost","ignoreFontWeight","fontStyle","_getFontStyle","font","fillOpacity","shadowOpacity","style2","fontVariant","fontWeight","fontSize","isNumber","fontFamily","join","_measure","textVisible","line","_index","textChunks","chunk","fillText","textDecoration","thickness","offset","oversizedBehavior","indexOf","metrics","_measureText","actualBoundingBoxLeft","actualBoundingBoxRight","format","getTextStyle","_ignoreFontWeight","test","navigator","vendor","rtl","maxWidth","truncate","wrap","refText","lines","toString","replace","split","styleRestored","minX","maxX","currentStyle","chunks","type","ignoreFormatting","lineInfo","ascent","actualBoundingBoxAscent","actualBoundingBoxDescent","currentFormat","currentDecoration","currentFill","currentChunkWidth","skipFurtherText","firstTextChunk","leftoverChunks","currentVerticalAlign","eachContinue","toNumber","verticalAlign","chunkWidth","breakWords","ellipsis","ellipsisMetrics","ellipsisWidth","excessWidth","_truncateText","tmpText","slice","trim","unshift","substr","leftBoundMod","rightBoundMod","boundsMod","chunkHeight","lineHeight","currentChunkOffset","baselineRatio","ratio","_fitRatio","minScale","_originalScale","maxW","maxH","maxHeight","w","h","fallbackBreakWords","tmp","measureText","fakeMetrics","div","innerText","visibility","position","body","appendChild","bbox","getBoundingClientRect","fontBoundingBoxAscent","fontBoundingBoxDescent","CanvasTextStyle","CanvasRadialText","textType","_renderCircular","deltaAngle","orientation","inward","inside","align","kerning","clockwise","shouldReverse","_textReversed","maxAngle","midAngle","normalizeAngle","reverse","textHeight","lineStartAngle","rotate","angleShift","char","charWidth","_measureCircular","totalWidth","chars","splitString","round","CanvasImage","_imageMask","naturalWidth","naturalHeight","_getMask","imageSmoothingEnabled","fillRect","CanvasRendererEvent","originalPoint","supports","Touch","identifier","CanvasRenderer","GhostLayer","_patternCanvas","Set","window","devicePixelRatio","setAttribute","_layerDom","_disposers","_events","_key","events","disposer","dispose","exportableView","onZoom","listener","ev","item","preventDefault","_touchActiveTimeout","_delayTouchDeactivate","passive","_ev","setTimeout","prevent","forEach","obj","wheelable","resetImageArray","imageArray","clearTimeout","tapToActivateTimeout","debugGhostView","parentNode","createLinearGradient","createRadialGradient","radius1","radius2","createPattern","graphics","background","repetition","_patternContext","clearRect","makeContainer","makeGraphics","makeText","makeTextStyle","makeRadialText","makePicture","resize","_calculatedWidth","_calculatedHeight","realWidth","realHeight","calculatedWidth","calculatedHeight","_realWidth","_realHeight","createDetachedLayer","CanvasLayer","getLayerByOrder","existingLayer","className","sort","layerIndex","next","insertBefore","root","_dirtyLayers","size","_lastPointerMoveEvent","native","_dispatchGlobalMousemove","fromHex","_colorMap","_adjustBoundingBox","DOMRect","getEvent","originalEvent","adjustPoint","clientX","clientY","widthScale","heightScale","_getHitTarget","pixel","data","colorId","fromRGB","hit","getObjectAtPoint","getImageArray","_withEvents","dispatching","cleanup","keepIf","callbacks","disposed","_dispatchEventAll","interactionsEnabled","call","_dispatchEvent","dispatched","object","_dispatchMousedown","originalTarget","button","dragged","info","_mousedown","delete","cursorOverStyle","setStyle","_replacedCursorStyle","add","getStyle","removeHovering","_dispatchGlobalMouseup","_dispatchDragMove","_dispatchDragEnd","clickevent","_dispatchDoubleClick","_dispatchWheel","_makeSharedEvent","_listeners","increment","_onPointerEvent","timer","_","_initEvent","mouseup","pointercancel","mousedown","mousemove","options","canvasWidth","canvasHeight","minWidth","minHeight","maxScale","maintainPixelRatio","canvases","forceRender","needRerender","exportableContext","extraX","extraY","clientWidth","clientHeight","domWidth","domHeight","_resolution","_width","_height"],"sources":["C:\\Users\\Moham\\Downloads\\Github projects\\Digital-Portfolio-main\\Frontend\\node_modules\\src\\.internal\\core\\render\\backend\\CanvasRenderer.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport {\n\tIRenderer, IContainer, IDisplayObject, IGraphics, IRendererEvents, IMargin,\n\tIText, ITextStyle, IRadialText, IPicture, IRendererEvent, ILayer, ICanvasOptions, BlendMode, IPointerEvent, Id\n} from \"./Renderer\";\nimport type { IBounds } from \"../../util/IBounds\";\nimport type { IPoint } from \"../../util/IPoint\";\nimport { Color } from \"../../util/Color\";\nimport { Matrix } from \"../../util/Matrix\";\nimport { Percent, percent } from \"../../util/Percent\";\n//import { Throttler } from \"../../util/Throttler\";\nimport { ArrayDisposer, Disposer, DisposerClass, IDisposer, CounterDisposer, MultiDisposer } from \"../../util/Disposer\";\nimport { TextFormatter, ITextChunk } from \"../../util/TextFormatter\";\nimport * as $utils from \"../../util/Utils\";\nimport * as $array from \"../../util/Array\";\nimport * as $object from \"../../util/Object\";\nimport * as $type from \"../../util/Type\";\nimport * as $math from \"../../util/Math\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\n\n\n/**\n * @ignore\n */\nfunction checkArgs(name: string, actual: number, expected: number) {\n\tif (actual !== expected) {\n\t\tthrow new Error(\"Required \" + expected + \" arguments for \" + name + \" but got \" + actual);\n\t}\n}\n\n/**\n * @ignore\n */\nfunction checkMinArgs(name: string, actual: number, expected: number) {\n\tif (actual < expected) {\n\t\tthrow new Error(\"Required at least \" + expected + \" arguments for \" + name + \" but got \" + actual);\n\t}\n}\n\n/**\n * @ignore\n */\nfunction checkEvenArgs(name: string, actual: number, expected: number) {\n\tcheckMinArgs(name, actual, expected);\n\n\tif ((actual % expected) !== 0) {\n\t\tthrow new Error(\"Arguments for \" + name + \" must be in pairs of \" + expected);\n\t}\n}\n\n/**\n * @ignore\n * This splits the flag so that way 0017 will be processed as 0 0 17\n *\n * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`\n */\nfunction splitArcFlags(args: Array<string>) {\n\tfor (let i = 0; i < args.length; i += 7) {\n\t\tlet index = i + 3;\n\t\tlet flag = args[index];\n\n\t\tif (flag.length > 1) {\n\t\t\tconst a = /^([01])([01])(.*)$/.exec(flag);\n\n\t\t\tif (a !== null) {\n\t\t\t\targs.splice(index, 0, a[1]);\n\t\t\t\t++index;\n\n\t\t\t\targs.splice(index, 0, a[2]);\n\t\t\t\t++index;\n\n\t\t\t\tif (a[3].length > 0) {\n\t\t\t\t\targs[index] = a[3];\n\n\t\t\t\t} else {\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++index;\n\n\t\tflag = args[index];\n\n\t\tif (flag.length > 1) {\n\t\t\tconst a = /^([01])(.+)$/.exec(flag);\n\n\t\t\tif (a !== null) {\n\t\t\t\targs.splice(index, 0, a[1]);\n\t\t\t\t++index;\n\n\t\t\t\targs[index] = a[2];\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nfunction assertBinary(value: number): 0 | 1 {\n\tif (value === 0 || value === 1) {\n\t\treturn value;\n\n\t} else {\n\t\tthrow new Error(\"Flag must be 0 or 1\");\n\t}\n}\n\n//  1 -> 0xffffff * (2 / 2)\n//  2 -> 0xffffff * (1 / 2)\n//\n//  3 -> 0xffffff * (3 / 4)\n//  4 -> 0xffffff * (1 / 4)\n//\n//  5 -> 0xffffff * (7 / 8)\n//  6 -> 0xffffff * (5 / 8)\n//  7 -> 0xffffff * (3 / 8)\n//  8 -> 0xffffff * (1 / 8)\n//\n//  9 -> 0xffffff * (15 / 16)\n// 10 -> 0xffffff * (13 / 16)\n// 11 -> 0xffffff * (11 / 16)\n// 12 -> 0xffffff *  (9 / 16)\n// 13 -> 0xffffff *  (7 / 16)\n// 14 -> 0xffffff *  (5 / 16)\n// 15 -> 0xffffff *  (3 / 16)\n// 16 -> 0xffffff *  (1 / 16)\n// @todo remove this old color distribution algo if the new one pans out\n/*function distributeId(id: number): number {\n\tif (id === 1) {\n\t\treturn 0x000001;\n\n\t} else {\n\t\t// Finds the closest power of 2\n\t\tconst base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));\n\n\t\t// Translates the id into an odd fraction index\n\t\tconst index = ((base - id) * 2) + 1;\n\n\t\t// TODO is Math.round correct ?\n\t\treturn Math.round(0xffffff * (index / base));\n\t}\n}*/\n\n/**\n * Function by smeans:\n * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/\n * @ignore\n */\nfunction distributeId(id: number): number {\n\tconst rgb = [0, 0, 0];\n\n\tfor (let i = 0; i < 24; i++) {\n\t\trgb[i % 3] <<= 1;\n\t\trgb[i % 3] |= id & 0x01;\n\t\tid >>= 1;\n\t}\n\n\treturn (rgb[0] | 0) + (rgb[1] << 8) + (rgb[2] << 16);\n}\n\n/**\n * @ignore\n */\nfunction eachTargets(hitTarget: CanvasDisplayObject, f: (target: CanvasDisplayObject) => boolean): void {\n\tfor (; ;) {\n\t\tif (hitTarget.interactive) {\n\t\t\tif (!f(hitTarget)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hitTarget._parent) {\n\t\t\thitTarget = hitTarget._parent;\n\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// TODO feature detection for mouse/touch/pointer\n/**\n * @ignore\n */\nfunction onPointerEvent(element: EventTarget, name: string, f: (event: Array<IPointerEvent>, target: Node | null) => void): IDisposer {\n\treturn $utils.addEventListener(element, $utils.getRendererEvent(name), (event: MouseEvent | TouchEvent) => {\n\t\tconst target = $utils.getEventTarget(event);\n\n\t\tlet touches = (<any>event).touches;\n\t\tif (touches) {\n\t\t\tif (touches.length == 0) {\n\t\t\t\ttouches = (<any>event).changedTouches;\n\t\t\t}\n\n\t\t\tf($array.copy(<TouchList>touches), target);\n\n\t\t} else {\n\t\t\tf([<MouseEvent>event], target);\n\t\t}\n\t});\n}\n\n/**\n * @ignore\n */\nfunction isTainted(image: HTMLImageElement): boolean {\n\tconst canvas = document.createElement(\"canvas\");\n\tcanvas.width = 1;\n\tcanvas.height = 1;\n\tconst context = canvas.getContext(\"2d\", { willReadFrequently: true })! as CanvasRenderingContext2D;\n\tcontext.drawImage(image, 0, 0, 1, 1);\n\n\ttry {\n\t\tcontext.getImageData(0, 0, 1, 1);\n\t\treturn false;\n\t}\n\tcatch (err) {\n\t\tconsole.warn(\"Image \\\"\" + image.src + \"\\\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors\");\n\t\treturn true;\n\t}\n}\n\n/**\n * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.\n *\n * @ignore\n */\nfunction clearCanvas(view: HTMLCanvasElement) {\n\tview.width = 0;\n\tview.height = 0;\n\tview.style.width = \"0px\";\n\tview.style.height = \"0px\";\n}\n\n\n/**\n * Aligns the coordinate to the pixel, so it renders crisp\n *\n * @ignore\n */\nfunction crisp(x: number): number {\n\treturn Math.floor(x) + .5;\n}\n\n/**\n * @ignore\n */\nexport class CanvasPivot implements IPoint {\n\tprotected _x: number = 0;\n\tprotected _y: number = 0;\n\n\tget x(): number {\n\t\treturn this._x;\n\t}\n\n\tget y(): number {\n\t\treturn this._y;\n\t}\n\n\tset x(value: number) {\n\t\tthis._x = value;\n\t}\n\n\tset y(value: number) {\n\t\tthis._y = value;\n\t}\n}\n\n\ninterface IStatus {\n\tlayer: CanvasLayer;\n\tinactive: boolean | null;\n}\n\n/**\n * @ignore\n */\nexport class CanvasDisplayObject extends DisposerClass implements IDisplayObject, IDisposer {\n\tpublic _layer?: CanvasLayer;\n\n\tpublic mask: CanvasGraphics | null = null;\n\tpublic visible: boolean = true;\n\tpublic exportable?: boolean = true;\n\tpublic interactive: boolean = false;\n\tpublic inactive: boolean | null = null;\n\tpublic wheelable: boolean = false;\n\tpublic cancelTouch: boolean = false;\n\tpublic isMeasured: boolean = false;\n\tpublic buttonMode: boolean = false;\n\tpublic alpha: number = 1;\n\tpublic compoundAlpha: number = 1;\n\tpublic angle: number = 0;\n\tpublic scale: number = 1;\n\tpublic x: number = 0;\n\tpublic y: number = 0;\n\tpublic crisp: boolean = false;\n\tpublic pivot: CanvasPivot = new CanvasPivot();\n\n\tpublic filter?: string;\n\n\tpublic cursorOverStyle?: string;\n\tpublic _replacedCursorStyle?: string;\n\n\tpublic _localMatrix: Matrix = new Matrix();\n\tpublic _matrix: Matrix = new Matrix();\n\t// TODO can this be replaced with _localMatrix ?\n\tprotected _uMatrix: Matrix = new Matrix();\n\n\tpublic _renderer: CanvasRenderer;\n\tpublic _parent: CanvasContainer | undefined;\n\n\tprotected _localBounds: IBounds | undefined;\n\tprotected _bounds: IBounds | undefined;\n\tpublic _colorId: string | undefined;\n\n\tconstructor(renderer: CanvasRenderer) {\n\t\tsuper();\n\t\tthis._renderer = renderer;\n\t}\n\n\tprotected subStatus(status: IStatus): IStatus {\n\t\treturn {\n\t\t\tinactive: (this.inactive == null ? status.inactive : this.inactive),\n\t\t\tlayer: this._layer || status.layer,\n\t\t};\n\t}\n\n\tprotected _dispose(): void {\n\t\tthis._renderer._removeObject(this);\n\t\tthis.getLayer().dirty = true;\n\t}\n\n\tpublic getCanvas(): HTMLCanvasElement {\n\t\treturn this.getLayer().view;\n\t}\n\n\tpublic getLayer(): CanvasLayer {\n\t\tlet self: CanvasDisplayObject = this;\n\n\t\tfor (; ;) {\n\t\t\tif (self._layer) {\n\t\t\t\treturn self._layer;\n\n\t\t\t} else if (self._parent) {\n\t\t\t\tself = self._parent;\n\n\t\t\t} else {\n\t\t\t\treturn this._renderer.defaultLayer;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic setLayer(order: number | undefined, margin: IMargin | undefined): void {\n\t\tif (order == null) {\n\t\t\tthis._layer = undefined;\n\n\t\t} else {\n\t\t\tconst visible = true;\n\t\t\tthis._layer = this._renderer.getLayer(order, visible);\n\t\t\tthis._layer.visible = visible;\n\t\t\tthis._layer.margin = margin;\n\t\t\tif (margin) {\n\t\t\t\t$utils.setInteractive(this._layer.view, false);\n\t\t\t}\n\n\t\t\tthis._renderer._ghostLayer.setMargin(this._renderer.layers);\n\n\t\t\tif (this._parent) {\n\t\t\t\tthis._parent.registerChildLayer(this._layer);\n\t\t\t}\n\n\t\t\tthis._layer.dirty = true;\n\t\t\tthis._renderer.resizeLayer(this._layer);\n\t\t\tthis._renderer.resizeGhost();\n\t\t}\n\t}\n\n\tpublic markDirtyLayer(): void {\n\t\tthis.getLayer().dirty = true;\n\t}\n\n\tpublic clear(): void {\n\t\tthis.invalidateBounds();\n\t}\n\n\tpublic invalidateBounds(): void {\n\t\tthis._localBounds = undefined;\n\t}\n\n\tpublic _addBounds(_bounds: IBounds): void { }\n\n\tprotected _getColorId(): string {\n\t\tif (this._colorId === undefined) {\n\t\t\tthis._colorId = this._renderer.paintId(this);\n\t\t}\n\n\t\treturn this._colorId;\n\t}\n\n\tprotected _isInteractive(status: IStatus): boolean {\n\t\treturn !status.inactive && (this.interactive || this._renderer._forceInteractive > 0);\n\t}\n\n\tprotected _isInteractiveMask(status: IStatus): boolean {\n\t\treturn this._isInteractive(status);\n\t}\n\n\tpublic contains(child: CanvasDisplayObject): boolean {\n\t\tfor (; ;) {\n\t\t\tif (child === this) {\n\t\t\t\treturn true;\n\n\t\t\t} else if (child._parent) {\n\t\t\t\tchild = child._parent;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\ttoGlobal(point: IPoint): IPoint {\n\t\treturn this._matrix.apply(point);\n\t}\n\n\ttoLocal(point: IPoint): IPoint {\n\t\treturn this._matrix.applyInverse(point);\n\t}\n\n\tpublic getLocalMatrix(): Matrix {\n\t\tthis._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);\n\t\treturn this._uMatrix;\n\t}\n\n\tgetLocalBounds(): IBounds {\n\t\tif (!this._localBounds) {\n\n\t\t\tconst bn = 10000000;\n\t\t\tthis._localBounds = {\n\t\t\t\tleft: bn,\n\t\t\t\ttop: bn,\n\t\t\t\tright: -bn,\n\t\t\t\tbottom: -bn\n\t\t\t};\n\n\t\t\tthis._addBounds(this._localBounds);\n\t\t}\n\t\treturn this._localBounds;\n\t}\n\n\tgetAdjustedBounds(bounds: IBounds): IBounds {\n\t\tthis._setMatrix();\n\n\t\tconst matrix = this.getLocalMatrix();\n\n\t\tconst p0 = matrix.apply({ x: bounds.left, y: bounds.top });\n\t\tconst p1 = matrix.apply({ x: bounds.right, y: bounds.top });\n\t\tconst p2 = matrix.apply({ x: bounds.right, y: bounds.bottom });\n\t\tconst p3 = matrix.apply({ x: bounds.left, y: bounds.bottom });\n\n\t\treturn {\n\t\t\tleft: Math.min(p0.x, p1.x, p2.x, p3.x),\n\t\t\ttop: Math.min(p0.y, p1.y, p2.y, p3.y),\n\t\t\tright: Math.max(p0.x, p1.x, p2.x, p3.x),\n\t\t\tbottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n\t\t}\n\t}\n\n\ton<C, Key extends keyof IRendererEvents>(key: Key, callback: (this: C, event: IRendererEvents[Key]) => void, context?: C): IDisposer {\n\t\tif (this.interactive) {\n\t\t\treturn this._renderer._addEvent(this, key, callback, context);\n\n\t\t} else {\n\t\t\treturn new Disposer(() => { });\n\t\t}\n\t}\n\n\tpublic _setMatrix(): void {\n\t\t// TODO only calculate this if it has actually changed\n\t\tthis._localMatrix.setTransform(\n\t\t\tthis.x,\n\t\t\tthis.y,\n\t\t\tthis.pivot.x,\n\t\t\tthis.pivot.y,\n\t\t\t// Converts degrees to radians\n\t\t\tthis.angle * Math.PI / 180,\n\t\t\tthis.scale\n\t\t);\n\n\t\tthis._matrix.copyFrom(this._localMatrix);\n\n\t\tif (this._parent) {\n\t\t\t// TODO only calculate this if it has actually changed\n\t\t\tthis._matrix.prepend(this._parent._matrix);\n\t\t}\n\t}\n\n\tpublic _transform(context: CanvasRenderingContext2D, resolution: number): void {\n\t\tconst m = this._matrix;\n\t\tlet tx = m.tx * resolution;\n\t\tlet ty = m.ty * resolution;\n\t\tif (this.crisp) {\n\t\t\ttx = crisp(tx);\n\t\t\tty = crisp(ty);\n\t\t}\n\n\t\tcontext.setTransform(\n\t\t\tm.a * resolution,\n\t\t\tm.b * resolution,\n\t\t\tm.c * resolution,\n\t\t\tm.d * resolution,\n\t\t\ttx,\n\t\t\tty)\n\n\t}\n\n\tpublic _transformMargin(context: CanvasRenderingContext2D, resolution: number, margin: IMargin): void {\n\t\tconst m = this._matrix;\n\t\tcontext.setTransform(\n\t\t\tm.a * resolution,\n\t\t\tm.b * resolution,\n\t\t\tm.c * resolution,\n\t\t\tm.d * resolution,\n\t\t\t(m.tx + margin.left) * resolution,\n\t\t\t(m.ty + margin.top) * resolution\n\t\t);\n\t}\n\n\tpublic _transformLayer(context: CanvasRenderingContext2D, resolution: number, layer: CanvasLayer): void {\n\t\tif (layer.margin) {\n\t\t\tthis._transformMargin(context, layer.scale || resolution, layer.margin);\n\n\t\t} else {\n\t\t\tthis._transform(context, layer.scale || resolution);\n\t\t}\n\t}\n\n\tpublic render(status: IStatus): void {\n\t\tif (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {\n\t\t\tthis._setMatrix();\n\n\t\t\tconst subStatus = this.subStatus(status);\n\n\t\t\tconst resolution = this._renderer.resolution;\n\n\t\t\tconst layers = this._renderer.layers;\n\t\t\tconst ghostLayer = this._renderer._ghostLayer;\n\t\t\tconst ghostContext = ghostLayer.context;\n\n\t\t\tconst mask = this.mask;\n\t\t\tif (mask) {\n\t\t\t\tmask._setMatrix();\n\t\t\t}\n\n\t\t\t// TODO improve this\n\t\t\t$array.each(layers, (layer) => {\n\t\t\t\tif (layer) {\n\t\t\t\t\tconst context = layer.context;\n\t\t\t\t\tcontext.save();\n\n\t\t\t\t\t// We must apply the mask before we transform the element\n\t\t\t\t\tif (mask) {\n\t\t\t\t\t\tmask._transformLayer(context, resolution, layer);\n\t\t\t\t\t\tmask._runPath(context);\n\t\t\t\t\t\tcontext.clip();\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.globalAlpha = this.compoundAlpha * this.alpha;\n\n\t\t\t\t\tthis._transformLayer(context, resolution, layer);\n\n\t\t\t\t\tif (this.filter) {\n\t\t\t\t\t\tcontext.filter = this.filter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tghostContext.save();\n\n\t\t\t// We must apply the mask before we transform the element\n\t\t\tif (mask && this._isInteractiveMask(subStatus)) {\n\t\t\t\tmask._transformMargin(ghostContext, resolution, ghostLayer.margin);\n\t\t\t\tmask._runPath(ghostContext);\n\t\t\t\tghostContext.clip();\n\t\t\t}\n\n\t\t\tthis._transformMargin(ghostContext, resolution, ghostLayer.margin);\n\n\t\t\tthis._render(subStatus);\n\n\t\t\tghostContext.restore();\n\n\t\t\t$array.each(layers, (layer) => {\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.context.restore();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _render(status: IStatus): void {\n\t\tif (this.exportable === false) {\n\t\t\tstatus.layer.tainted = true;\n\t\t}\n\t}\n\n\thovering(): boolean {\n\t\treturn this._renderer._hovering.has(this);\n\t}\n\n\tdragging(): boolean {\n\t\treturn this._renderer._dragging.some((x) => x.value === this);\n\t}\n\n\n\tpublic shouldCancelTouch(): boolean {\n\t\tconst renderer = this._renderer;\n\t\tif (renderer.tapToActivate && !renderer._touchActive) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.cancelTouch) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this._parent) {\n\t\t\treturn this._parent.shouldCancelTouch();\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasContainer extends CanvasDisplayObject implements IContainer {\n\tpublic interactiveChildren: boolean = true;\n\tprivate _childLayers?: CanvasLayer[];\n\n\tprotected _children: Array<CanvasDisplayObject> = [];\n\n\tprotected _isInteractiveMask(status: IStatus): boolean {\n\t\treturn this.interactiveChildren || super._isInteractiveMask(status);\n\t}\n\n\taddChild(child: CanvasDisplayObject): void {\n\t\tchild._parent = this;\n\t\tthis._children.push(child);\n\t\tif (child._layer) {\n\t\t\tthis.registerChildLayer(child._layer);\n\t\t}\n\t}\n\n\taddChildAt(child: CanvasDisplayObject, index: number): void {\n\t\tchild._parent = this;\n\t\tthis._children.splice(index, 0, child);\n\t\tif (child._layer) {\n\t\t\tthis.registerChildLayer(child._layer);\n\t\t}\n\t}\n\n\tremoveChild(child: CanvasDisplayObject): void {\n\t\tchild._parent = undefined;\n\t\t$array.removeFirst(this._children, child);\n\t}\n\n\tprotected _render(status: IStatus): void {\n\t\tsuper._render(status);\n\n\t\tconst renderer = this._renderer;\n\n\t\tif (this.interactive && this.interactiveChildren) {\n\t\t\t++renderer._forceInteractive;\n\t\t}\n\n\t\t$array.each(this._children, (child) => {\n\t\t\tchild.compoundAlpha = this.compoundAlpha * this.alpha;\n\t\t\tchild.render(status);\n\t\t});\n\n\t\tif (this.interactive && this.interactiveChildren) {\n\t\t\t--renderer._forceInteractive;\n\t\t}\n\t}\n\n\tregisterChildLayer(layer: CanvasLayer): void {\n\t\tif (!this._childLayers) {\n\t\t\tthis._childLayers = [];\n\t\t}\n\t\t$array.pushOne(this._childLayers, layer);\n\t\tif (this._parent) {\n\t\t\tthis._parent.registerChildLayer(layer);\n\t\t}\n\t}\n\n\tpublic markDirtyLayer(deep: boolean = false): void {\n\t\tsuper.markDirtyLayer();\n\t\tif (deep && this._childLayers) {\n\t\t\t$array.each(this._childLayers, (layer) => layer.dirty = true);\n\t\t}\n\t}\n\n\tprotected _dispose() {\n\t\tsuper._dispose();\n\t\tif (this._childLayers) {\n\t\t\t$array.each(this._childLayers, (layer) => {\n\t\t\t\tlayer.dirty = true;\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nfunction setPoint(bounds: IBounds, point: IPoint): void {\n\tbounds.left = Math.min(bounds.left, point.x);\n\tbounds.top = Math.min(bounds.top, point.y);\n\tbounds.right = Math.max(bounds.right, point.x);\n\tbounds.bottom = Math.max(bounds.bottom, point.y);\n}\n\n/**\n * @ignore\n */\nabstract class Op {\n\tpublic colorize(_context: CanvasRenderingContext2D, _forceColor: string | undefined): void { }\n\n\tpublic colorizeGhost(context: CanvasRenderingContext2D, forceColor: string | undefined): void {\n\t\tthis.colorize(context, forceColor);\n\t}\n\n\tpublic path(_context: CanvasRenderingContext2D): void { }\n\n\tpublic pathGhost(context: CanvasRenderingContext2D): void {\n\t\tthis.path(context);\n\t}\n\n\tpublic addBounds(_bounds: IBounds): void { }\n}\n\n/**\n * @ignore\n */\nclass BeginPath extends Op {\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.beginPath();\n\t}\n}\n\n/**\n * @ignore\n */\nclass BeginFill extends Op {\n\tconstructor(public color: string | CanvasGradient | CanvasPattern) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, forceColor: string | undefined): void {\n\t\tif (forceColor !== undefined) {\n\t\t\tcontext.fillStyle = forceColor;\n\n\t\t} else {\n\t\t\tcontext.fillStyle = this.color;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nclass EndFill extends Op {\n\tconstructor(public clearShadow: boolean) { super(); }\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.fill();\n\t\tif (this.clearShadow) {\n\t\t\tcontext.shadowColor = \"\";\n\t\t\tcontext.shadowBlur = 0;\n\t\t\tcontext.shadowOffsetX = 0;\n\t\t\tcontext.shadowOffsetY = 0;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nclass EndStroke extends Op {\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.stroke();\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineStyle extends Op {\n\tconstructor(public width: number, public color: string | CanvasGradient | CanvasPattern, public lineJoin?: \"miter\" | \"round\" | \"bevel\", public lineCap?: \"butt\" | \"round\" | \"square\") { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, forceColor: string | undefined): void {\n\t\tif (forceColor !== undefined) {\n\t\t\tcontext.strokeStyle = forceColor;\n\n\t\t} else {\n\t\t\tcontext.strokeStyle = this.color;\n\t\t}\n\n\t\tcontext.lineWidth = this.width;\n\t\tif (this.lineJoin) {\n\t\t\tcontext.lineJoin = this.lineJoin;\n\t\t}\n\n\t\tif (this.lineCap) {\n\t\t\tcontext.lineCap = this.lineCap;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineDash extends Op {\n\tconstructor(public dash: number[]) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.setLineDash(this.dash);\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineDashOffset extends Op {\n\tconstructor(public dashOffset: number) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.lineDashOffset = this.dashOffset;\n\t}\n}\n\n/**\n * @ignore\n */\nclass DrawRect extends Op {\n\tconstructor(public x: number, public y: number, public width: number, public height: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.rect(this.x, this.y, this.width, this.height);\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tconst l = this.x;\n\t\tconst t = this.y;\n\t\tconst r = l + this.width;\n\t\tconst b = t + this.height;\n\n\t\tsetPoint(bounds, { x: l, y: t });\n\t\tsetPoint(bounds, { x: r, y: t });\n\t\tsetPoint(bounds, { x: l, y: b });\n\t\tsetPoint(bounds, { x: r, y: b });\n\t}\n}\n\n/**\n * @ignore\n */\nclass DrawCircle extends Op {\n\tconstructor(public x: number, public y: number, public radius: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.moveTo(this.x + this.radius, this.y);\n\t\tcontext.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n\t}\n\n\t// TODO handle skewing and rotation\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x - this.radius, y: this.y - this.radius });\n\t\tsetPoint(bounds, { x: this.x + this.radius, y: this.y + this.radius });\n\t}\n}\n\n/**\n * @ignore\n */\nclass DrawEllipse extends Op {\n\tconstructor(public x: number, public y: number, public radiusX: number, public radiusY: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);\n\t}\n\n\t// TODO handle skewing and rotation\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x - this.radiusX, y: this.y - this.radiusY });\n\t\tsetPoint(bounds, { x: this.x + this.radiusX, y: this.y + this.radiusY });\n\t}\n}\n\n/**\n * @ignore\n */\nclass Arc extends Op {\n\tconstructor(\n\t\tpublic cx: number,\n\t\tpublic cy: number,\n\t\tpublic radius: number,\n\t\tpublic startAngle: number,\n\t\tpublic endAngle: number,\n\t\tpublic anticlockwise: boolean,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tif (this.radius > 0) {\n\t\t\tcontext.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);\n\t\t}\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tlet arcBounds = $math.getArcBounds(this.cx, this.cy, this.startAngle * $math.DEGREES, this.endAngle * $math.DEGREES, this.radius);\n\t\tsetPoint(bounds, { x: arcBounds.left, y: arcBounds.top });\n\t\tsetPoint(bounds, { x: arcBounds.right, y: arcBounds.bottom });\n\t}\n}\n\n/**\n * @ignore\n */\nclass ArcTo extends Op {\n\tconstructor(\n\t\tpublic x1: number,\n\t\tpublic y1: number,\n\t\tpublic x2: number,\n\t\tpublic y2: number,\n\t\tpublic radius: number,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tif (this.radius > 0) {\n\t\t\tcontext.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);\n\t\t}\n\t}\n\n\t// TODO: add points\n\tpublic addBounds(_bounds: IBounds): void {\n\t\t/*\n\t\t// not finished\n\t\thttps://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically\n\n\t\tif (prevPoint) {\n\t\t\tlet x1 = prevPoint.x;\n\t\t\tlet y1 = prevPoint.y;\n\t\t\tlet x2 = this.x2;\n\t\t\tlet y2 = this.y2;\n\t\t\tlet r = this.radius;\n\n\t\t\tlet xa = (x2 - x1) / 2;\n\t\t\tlet ya = (y2 - y1) / 2;\n\n\t\t\tlet x0 = x1 + xa;\n\t\t\tlet y0 = y1 + ya;\n\n\t\t\tlet a = Math.hypot(xa, ya);\n\t\t\tlet b = Math.sqrt(r * r - a * a);\n\n\t\t\tlet cx = x0 + b * ya / a;\n\t\t\tlet cy = y0 - b * xa / a;\n\n\t\t\tconsole.log(cx, cy);\n\t\t}*/\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineTo extends Op {\n\tconstructor(public x: number, public y: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.lineTo(this.x, this.y);\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x, y: this.y });\n\t}\n}\n\n/**\n * @ignore\n */\nclass MoveTo extends Op {\n\tconstructor(public x: number, public y: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.moveTo(this.x, this.y);\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x, y: this.y });\n\t}\n}\n\n/**\n * @ignore\n */\nclass ClosePath extends Op {\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.closePath();\n\t}\n}\n\n/**\n * @ignore\n */\nclass BezierCurveTo extends Op {\n\tconstructor(\n\t\tpublic cpX: number,\n\t\tpublic cpY: number,\n\t\tpublic cpX2: number,\n\t\tpublic cpY2: number,\n\t\tpublic toX: number,\n\t\tpublic toY: number,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);\n\t}\n\n\t// TODO: OK?\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.cpX, y: this.cpY });\n\t\tsetPoint(bounds, { x: this.cpX2, y: this.cpY2 });\n\t\tsetPoint(bounds, { x: this.toX, y: this.toY });\n\t}\n}\n\n/**\n * @ignore\n */\nclass QuadraticCurveTo extends Op {\n\tconstructor(\n\t\tpublic cpX: number,\n\t\tpublic cpY: number,\n\t\tpublic toX: number,\n\t\tpublic toY: number,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);\n\t}\n\n\t// TODO: OK?\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.cpX, y: this.cpY });\n\t\tsetPoint(bounds, { x: this.toX, y: this.toY });\n\t}\n}\n\n/**\n * @ignore\n */\nclass Shadow extends Op {\n\tconstructor(\n\t\tpublic color: string,\n\t\tpublic blur: number,\n\t\tpublic offsetX: number,\n\t\tpublic offsetY: number,\n\t\tpublic opacity?: number\n\t) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tif (this.opacity) {\n\t\t\tcontext.fillStyle = this.color;\n\t\t}\n\t\tcontext.shadowColor = this.color;\n\t\tcontext.shadowBlur = this.blur;\n\t\tcontext.shadowOffsetX = this.offsetX;\n\t\tcontext.shadowOffsetY = this.offsetY;\n\t}\n\n\tpublic colorizeGhost(_context: CanvasRenderingContext2D, _forceColor: string | undefined): void {}\n}\n\n/**\n * @ignore\n */\nclass GraphicsImage extends Op {\n\tconstructor(\n\t\tpublic image: HTMLImageElement | HTMLCanvasElement,\n\t\tpublic width: number,\n\t\tpublic height: number,\n\t\tpublic x: number,\n\t\tpublic y: number\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.drawImage(this.image, this.x, this.y, this.width, this.height);\n\t}\n\n\t// TODO: OK?\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x, y: this.y });\n\t\tsetPoint(bounds, { x: this.width, y: this.height });\n\t}\n}\n\n/**\n * @ignore\n */\nexport class CanvasGraphics extends CanvasDisplayObject implements IGraphics {\n\tprotected _operations: Array<Op> = [];\n\n\tpublic blendMode: BlendMode = BlendMode.NORMAL;\n\n\tprotected _hasShadows: boolean = false;\n\tprotected _fillAlpha?: number;\n\tprotected _strokeAlpha?: number;\n\n\tclear(): void {\n\t\tsuper.clear();\n\t\tthis._operations.length = 0;\n\t}\n\n\tprotected _pushOp(op: Op): void {\n\t\tthis._operations.push(op);\n\t}\n\n\tbeginFill(color?: Color | CanvasGradient | CanvasPattern, alpha: number = 1): void {\n\t\tthis._fillAlpha = alpha;\n\t\tif (color) {\n\t\t\tif (color instanceof Color) {\n\t\t\t\tthis._pushOp(new BeginFill(color.toCSS(alpha)));\n\n\t\t\t} else {\n\t\t\t\tthis.isMeasured = true;\n\t\t\t\tthis._pushOp(new BeginFill(color));\n\t\t\t}\n\t\t} else {\n\t\t\tthis._pushOp(new BeginFill(\"rgba(0, 0, 0, \" + alpha + \")\"));\n\t\t}\n\t}\n\n\tendFill(): void {\n\t\tthis._pushOp(new EndFill(this._hasShadows));\n\t}\n\n\tendStroke(): void {\n\t\tthis._pushOp(new EndStroke());\n\t}\n\n\tbeginPath(): void {\n\t\tthis._pushOp(new BeginPath());\n\t}\n\n\tlineStyle(width: number = 0, color?: Color | CanvasGradient | CanvasPattern, alpha: number = 1, lineJoin?: \"miter\" | \"round\" | \"bevel\", lineCap?: \"butt\" | \"round\" | \"square\"): void {\n\t\tthis._strokeAlpha = alpha;\n\t\tif (color) {\n\t\t\tif (color instanceof Color) {\n\t\t\t\tthis._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin, lineCap));\n\t\t\t} else {\n\t\t\t\tthis._pushOp(new LineStyle(width, color, lineJoin, lineCap));\n\t\t\t}\n\t\t} else {\n\t\t\tthis._pushOp(new LineStyle(width, \"rgba(0, 0, 0, \" + alpha + \")\", lineJoin, lineCap));\n\t\t}\n\t}\n\n\tsetLineDash(dash?: number[]): void {\n\t\tthis._pushOp(new LineDash(dash ? dash : []));\n\t}\n\n\tsetLineDashOffset(dashOffset: number = 0): void {\n\t\tthis._pushOp(new LineDashOffset(dashOffset));\n\t}\n\n\tdrawRect(x: number, y: number, width: number, height: number): void {\n\t\tthis._pushOp(new DrawRect(x, y, width, height));\n\t}\n\n\tdrawCircle(x: number, y: number, radius: number): void {\n\t\tthis._pushOp(new DrawCircle(x, y, radius));\n\t}\n\n\tdrawEllipse(x: number, y: number, radiusX: number, radiusY: number): void {\n\t\tthis._pushOp(new DrawEllipse(x, y, radiusX, radiusY));\n\t}\n\n\tarc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise: boolean = false): void {\n\t\tthis._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));\n\t}\n\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void {\n\t\tthis._pushOp(new ArcTo(x1, y1, x2, y2, radius));\n\t}\n\n\tlineTo(x: number, y: number): void {\n\t\tthis._pushOp(new LineTo(x, y));\n\t}\n\n\tmoveTo(x: number, y: number): void {\n\t\tthis._pushOp(new MoveTo(x, y));\n\t}\n\n\tbezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): void {\n\t\tthis._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));\n\t}\n\n\tquadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): void {\n\t\tthis._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));\n\t}\n\n\tclosePath(): void {\n\t\tthis._pushOp(new ClosePath());\n\t}\n\n\tshadow(color: Color, blur: number = 0, offsetX: number = 0, offsetY: number = 0, opacity?: number): void {\n\t\tthis._hasShadows = true;\n\t\tthis._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));\n\t}\n\n\timage(image: HTMLImageElement | HTMLCanvasElement, width: number, height: number, x: number, y: number): void {\n\t\tthis._pushOp(new GraphicsImage(image, width, height, x, y));\n\t}\n\n\t// https://svgwg.org/svg2-draft/paths.html#DProperty\n\t// TODO better error checking\n\tsvgPath(path: string): void {\n\t\tlet x = 0;\n\t\tlet y = 0;\n\t\tlet cpx: number | null = null;\n\t\tlet cpy: number | null = null;\n\t\tlet qcpx: number | null = null;\n\t\tlet qcpy: number | null = null;\n\n\t\tconst SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;\n\t\tconst ARGS_REGEXP = /[\\u0009\\u0020\\u000A\\u000C\\u000D]*([\\+\\-]?[0-9]*\\.?[0-9]+(?:[eE][\\+\\-]?[0-9]+)?)[\\u0009\\u0020\\u000A\\u000C\\u000D]*,?/g;\n\n\t\tlet match;\n\n\t\twhile ((match = SEGMENTS_REGEXP.exec(path)) !== null) {\n\t\t\tconst name = match[1];\n\t\t\tconst rest = match[2];\n\n\t\t\tconst args: Array<string> = [];\n\n\t\t\twhile ((match = ARGS_REGEXP.exec(rest)) !== null) {\n\t\t\t\targs.push(match[1]);\n\t\t\t}\n\n\t\t\t// Reset control point\n\t\t\tif (name !== \"S\" && name !== \"s\" && name !== \"C\" && name !== \"c\") {\n\t\t\t\tcpx = null;\n\t\t\t\tcpy = null;\n\t\t\t}\n\n\t\t\t// Reset control point\n\t\t\tif (name !== \"Q\" && name !== \"q\" && name !== \"T\" && name !== \"t\") {\n\t\t\t\tqcpx = null;\n\t\t\t\tqcpy = null;\n\t\t\t}\n\n\t\t\tswitch (name) {\n\t\t\t\tcase \"M\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tx = +args[0];\n\t\t\t\t\ty = +args[1];\n\t\t\t\t\tthis.moveTo(x, y);\n\n\t\t\t\t\tfor (let i = 2; i < args.length; i += 2) {\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\ty = +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"m\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tx += +args[0];\n\t\t\t\t\ty += +args[1];\n\t\t\t\t\tthis.moveTo(x, y);\n\n\t\t\t\t\tfor (let i = 2; i < args.length; i += 2) {\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\ty += +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"L\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\ty = +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"l\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\ty += +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"H\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"h\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"V\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\ty = +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\ty += +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"C\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 6);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 6) {\n\t\t\t\t\t\tconst x1 = +args[i];\n\t\t\t\t\t\tconst y1 = +args[i + 1];\n\t\t\t\t\t\tcpx = +args[i + 2];\n\t\t\t\t\t\tcpy = +args[i + 3];\n\t\t\t\t\t\tx = +args[i + 4];\n\t\t\t\t\t\ty = +args[i + 5];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"c\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 6);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 6) {\n\t\t\t\t\t\tconst x1 = +args[i] + x;\n\t\t\t\t\t\tconst y1 = +args[i + 1] + y;\n\t\t\t\t\t\tcpx = +args[i + 2] + x;\n\t\t\t\t\t\tcpy = +args[i + 3] + y;\n\t\t\t\t\t\tx += +args[i + 4];\n\t\t\t\t\t\ty += +args[i + 5];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"S\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tif (cpx === null || cpy === null) {\n\t\t\t\t\t\tcpx = x;\n\t\t\t\t\t\tcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tconst x1 = 2 * x - cpx;\n\t\t\t\t\t\tconst y1 = 2 * y - cpy;\n\t\t\t\t\t\tcpx = +args[i];\n\t\t\t\t\t\tcpy = +args[i + 1];\n\t\t\t\t\t\tx = +args[i + 2];\n\t\t\t\t\t\ty = +args[i + 3];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"s\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tif (cpx === null || cpy === null) {\n\t\t\t\t\t\tcpx = x;\n\t\t\t\t\t\tcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tconst x1 = 2 * x - cpx;\n\t\t\t\t\t\tconst y1 = 2 * y - cpy;\n\t\t\t\t\t\tcpx = +args[i] + x;\n\t\t\t\t\t\tcpy = +args[i + 1] + y;\n\t\t\t\t\t\tx += +args[i + 2];\n\t\t\t\t\t\ty += +args[i + 3];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Q\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tqcpx = +args[i];\n\t\t\t\t\t\tqcpy = +args[i + 1];\n\t\t\t\t\t\tx = +args[i + 2];\n\t\t\t\t\t\ty = +args[i + 3];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"q\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tqcpx = +args[i] + x;\n\t\t\t\t\t\tqcpy = +args[i + 1] + y;\n\t\t\t\t\t\tx += +args[i + 2];\n\t\t\t\t\t\ty += +args[i + 3];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"T\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tif (qcpx === null || qcpy === null) {\n\t\t\t\t\t\tqcpx = x;\n\t\t\t\t\t\tqcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tqcpx = 2 * x - qcpx;\n\t\t\t\t\t\tqcpy = 2 * y - qcpy;\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\ty = +args[i + 1];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"t\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tif (qcpx === null || qcpy === null) {\n\t\t\t\t\t\tqcpx = x;\n\t\t\t\t\t\tqcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tqcpx = 2 * x - qcpx;\n\t\t\t\t\t\tqcpy = 2 * y - qcpy;\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\ty += +args[i + 1];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"A\":\n\t\t\t\tcase \"a\":\n\t\t\t\t\tconst relative = (name === \"a\");\n\n\t\t\t\t\tsplitArcFlags(args);\n\t\t\t\t\tcheckEvenArgs(name, args.length, 7);\n\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 7) {\n\t\t\t\t\t\tlet cx = +args[i + 5];\n\t\t\t\t\t\tlet cy = +args[i + 6];\n\n\t\t\t\t\t\tif (relative) {\n\t\t\t\t\t\t\tcx += x;\n\t\t\t\t\t\t\tcy += y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst bs = arcToBezier({\n\t\t\t\t\t\t\tpx: x,\n\t\t\t\t\t\t\tpy: y,\n\t\t\t\t\t\t\trx: +args[i],\n\t\t\t\t\t\t\try: +args[i + 1],\n\t\t\t\t\t\t\txAxisRotation: +args[i + 2],\n\t\t\t\t\t\t\tlargeArcFlag: assertBinary(+args[i + 3]),\n\t\t\t\t\t\t\tsweepFlag: assertBinary(+args[i + 4]),\n\t\t\t\t\t\t\tcx,\n\t\t\t\t\t\t\tcy,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t$array.each(bs, (b) => {\n\t\t\t\t\t\t\tthis.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);\n\t\t\t\t\t\t\tx = b.x;\n\t\t\t\t\t\t\ty = b.y;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Z\":\n\t\t\t\tcase \"z\":\n\t\t\t\t\tcheckArgs(name, args.length, 0);\n\t\t\t\t\tthis.closePath();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _runPath(context: CanvasRenderingContext2D): void {\n\t\tcontext.beginPath();\n\n\t\t$array.each(this._operations, (op) => {\n\t\t\top.path(context);\n\t\t});\n\t}\n\n\tprotected _render(status: IStatus): void {\n\t\tsuper._render(status);\n\n\t\tconst layerDirty = status.layer.dirty;\n\t\tconst interactive = this._isInteractive(status);\n\n\t\tif (layerDirty || interactive) {\n\n\t\t\tconst context = status.layer.context;\n\t\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t\tif (layerDirty) {\n\t\t\t\tcontext.globalCompositeOperation = this.blendMode;\n\n\t\t\t\tcontext.beginPath();\n\t\t\t}\n\n\t\t\tlet color: string | undefined;\n\n\t\t\tif (interactive) {\n\t\t\t\tghostContext.beginPath();\n\t\t\t\tcolor = this._getColorId();\n\t\t\t}\n\n\t\t\t$array.each(this._operations, (op) => {\n\t\t\t\tif (layerDirty) {\n\t\t\t\t\top.path(context);\n\t\t\t\t\top.colorize(context, undefined);\n\t\t\t\t}\n\n\t\t\t\tif (interactive) {\n\t\t\t\t\top.pathGhost(ghostContext);\n\t\t\t\t\top.colorizeGhost(ghostContext, color);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic renderDetached(context: CanvasRenderingContext2D): void {\n\t\tif (this.visible) {\n\t\t\tthis._setMatrix();\n\n\t\t\tcontext.save();\n\n\t\t\t// We must apply the mask before we transform the element\n\t\t\tconst mask = this.mask;\n\t\t\tif (mask) {\n\t\t\t\tmask._setMatrix();\n\t\t\t\tmask._transform(context, 1);\n\t\t\t\tmask._runPath(context);\n\t\t\t\tcontext.clip();\n\t\t\t}\n\n\t\t\t// TODO handle compoundAlpha somehow ?\n\t\t\tcontext.globalAlpha = this.compoundAlpha * this.alpha;\n\n\t\t\tthis._transform(context, 1);\n\n\t\t\tif (this.filter) {\n\t\t\t\tcontext.filter = this.filter;\n\t\t\t}\n\n\t\t\tcontext.globalCompositeOperation = this.blendMode;\n\n\t\t\tcontext.beginPath();\n\n\t\t\t$array.each(this._operations, (op) => {\n\t\t\t\top.path(context);\n\t\t\t\top.colorize(context, undefined);\n\t\t\t});\n\n\t\t\tcontext.restore();\n\t\t}\n\t}\n\n\tpublic _addBounds(bounds: IBounds): void {\n\t\tif (this.visible && this.isMeasured) {\n\t\t\t$array.each(this._operations, (op) => {\n\t\t\t\top.addBounds(bounds);\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\ninterface ILineChunk {\n\tstyle: string | undefined,\n\tfill: Color | undefined,\n\ttext: string,\n\twidth: number,\n\theight: number,\n\tleft: number,\n\tright: number,\n\tascent: number,\n\toffsetX: number,\n\toffsetY: number,\n\ttextDecoration: string | undefined,\n\tverticalAlign?: \"baseline\" | \"sub\" | \"super\"\n}\n\n/**\n * @ignore\n */\ninterface ILine {\n\toffsetY: number,\n\tascent: number,\n\twidth: number,\n\theight: number,\n\tleft: number,\n\tright: number,\n\ttextChunks: Array<ILineChunk>,\n}\n\n/**\n * @ignore\n */\nexport class CanvasText extends CanvasDisplayObject implements IText {\n\tpublic text: string;\n\tpublic style: CanvasTextStyle;\n\tpublic resolution: number = 1;\n\tpublic textVisible: boolean = true;\n\n\tprotected _textInfo: Array<ILine> | undefined;\n\tprotected _originalScale?: number = 1;\n\n\tconstructor(renderer: CanvasRenderer, text: string, style: CanvasTextStyle) {\n\t\tsuper(renderer);\n\t\tthis.text = text;\n\t\tthis.style = style;\n\t}\n\n\tpublic invalidateBounds(): void {\n\t\tsuper.invalidateBounds();\n\t\tthis._textInfo = undefined;\n\t}\n\n\tprivate _shared(context: CanvasRenderingContext2D) {\n\t\tif (this.style.textAlign) {\n\t\t\tcontext.textAlign = this.style.textAlign;\n\t\t}\n\n\t\tif (this.style.direction) {\n\t\t\tcontext.direction = this.style.direction;\n\t\t}\n\n\t\tif (this.style.textBaseline) {\n\t\t\tcontext.textBaseline = this.style.textBaseline;\n\t\t}\n\n\t}\n\n\tprotected _prerender(status: IStatus, ignoreGhost = false, ignoreFontWeight = false): void {\n\t\tsuper._render(status);\n\n\t\tconst context = status.layer.context;\n\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t// Font style\n\n\t\tconst style = this.style;\n\t\tlet fontStyle = this._getFontStyle(undefined, ignoreFontWeight);\n\n\t\tcontext.font = fontStyle;\n\t\tif (this._isInteractive(status) && !ignoreGhost) {\n\t\t\tghostContext.font = fontStyle;\n\t\t}\n\n\t\t// Other parameters\n\t\tif (style.fill) {\n\t\t\tif (style.fill instanceof Color) {\n\t\t\t\tcontext.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);\n\t\t\t} else {\n\t\t\t\tcontext.fillStyle = style.fill;\n\t\t\t}\n\t\t}\n\n\t\tif (style.shadowColor) {\n\t\t\tstatus.layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);\n\t\t}\n\t\tif (style.shadowBlur) {\n\t\t\tstatus.layer.context.shadowBlur = style.shadowBlur;\n\t\t}\n\t\tif (style.shadowOffsetX) {\n\t\t\tstatus.layer.context.shadowOffsetX = style.shadowOffsetX;\n\t\t}\n\t\tif (style.shadowOffsetY) {\n\t\t\tstatus.layer.context.shadowOffsetY = style.shadowOffsetY;\n\t\t}\n\n\t\tthis._shared(context);\n\n\t\tif (this._isInteractive(status) && !ignoreGhost) {\n\t\t\tghostContext.fillStyle = this._getColorId();\n\t\t\tthis._shared(ghostContext);\n\t\t}\n\t}\n\n\tprotected _getFontStyle(style2?: ITextStyle, ignoreFontWeight = false): string {\n\n\t\t// Process defaults\n\t\tconst style = this.style;\n\t\tlet fontStyle: string[] = [];\n\n\t\tif (style2 && style2.fontVariant) {\n\t\t\tfontStyle.push(style2.fontVariant);\n\t\t}\n\t\telse if (style.fontVariant) {\n\t\t\tfontStyle.push(style.fontVariant);\n\t\t}\n\n\t\tif (!ignoreFontWeight) {\n\t\t\tif (style2 && style2.fontWeight) {\n\t\t\t\tfontStyle.push(style2.fontWeight);\n\t\t\t}\n\t\t\telse if (style.fontWeight) {\n\t\t\t\tfontStyle.push(style.fontWeight);\n\t\t\t}\n\t\t}\n\n\t\tif (style2 && style2.fontStyle) {\n\t\t\tfontStyle.push(style2.fontStyle);\n\t\t}\n\t\telse if (style.fontStyle) {\n\t\t\tfontStyle.push(style.fontStyle);\n\t\t}\n\n\t\tif (style2 && style2.fontSize) {\n\t\t\tif ($type.isNumber(style2.fontSize)) {\n\t\t\t\tstyle2.fontSize = style2.fontSize + \"px\";\n\t\t\t}\n\t\t\tfontStyle.push(style2.fontSize);\n\t\t}\n\t\telse if (style.fontSize) {\n\t\t\tif ($type.isNumber(style.fontSize)) {\n\t\t\t\tstyle.fontSize = style.fontSize + \"px\";\n\t\t\t}\n\t\t\tfontStyle.push(style.fontSize);\n\t\t}\n\n\t\tif (style2 && style2.fontFamily) {\n\t\t\tfontStyle.push(style2.fontFamily);\n\t\t}\n\t\telse if (style.fontFamily) {\n\t\t\tfontStyle.push(style.fontFamily);\n\t\t}\n\t\telse if (fontStyle.length) {\n\t\t\tfontStyle.push(\"Arial\");\n\t\t}\n\n\t\treturn fontStyle.join(\" \");\n\t}\n\n\tprotected _render(status: IStatus): void {\n\t\t// We need measurements in order to properly position text for alignment\n\t\tif (!this._textInfo) {\n\t\t\tthis._measure(status);\n\t\t}\n\n\t\tif (this.textVisible) {\n\n\t\t\tconst interactive = this._isInteractive(status);\n\t\t\tconst context = status.layer.context;\n\t\t\tconst layerDirty = status.layer.dirty;\n\t\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t\tcontext.save();\n\t\t\tghostContext.save();\n\t\t\tthis._prerender(status);\n\n\t\t\t// const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n\t\t\t// const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;\n\n\t\t\t// Process text info produced by _measure()\n\t\t\t$array.each(this._textInfo!, (line, _index) => {\n\t\t\t\t$array.each(line.textChunks, (chunk, _index) => {\n\n\t\t\t\t\t// Set style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tghostContext.save();\n\n\t\t\t\t\t\tcontext.font = chunk.style;\n\t\t\t\t\t\tif (this._isInteractive(status)) {\n\t\t\t\t\t\t\tghostContext.font = chunk.style;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.fillStyle = chunk.fill.toCSS();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw text\n\t\t\t\t\tif (layerDirty) {\n\t\t\t\t\t\tcontext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw underline\n\t\t\t\t\tif (chunk.textDecoration == \"underline\" || chunk.textDecoration == \"line-through\") {\n\n\t\t\t\t\t\tlet thickness = 1;\n\t\t\t\t\t\tlet offset = 1;\n\t\t\t\t\t\tlet fontSize = chunk.height;\n\n\t\t\t\t\t\tconst oversizedBehavior = this.style.oversizedBehavior || \"\";\n\t\t\t\t\t\tif ([\"truncate\", \"wrap\", \"wrap-no-break\"].indexOf(oversizedBehavior) > -1) {\n\t\t\t\t\t\t\t// Measure actual width of the text so the line fits\n\t\t\t\t\t\t\tconst metrics = this._measureText(chunk.text, context);\n\t\t\t\t\t\t\tchunk.width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet offsetX = chunk.offsetX;\n\t\t\t\t\t\tswitch (this.style.textAlign) {\n\t\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\toffsetX -= chunk.width;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\t\t\toffsetX -= chunk.width / 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\t\tconst format = TextFormatter.getTextStyle(chunk.style);\n\t\t\t\t\t\t\tswitch (format.fontWeight) {\n\t\t\t\t\t\t\t\tcase \"bolder\":\n\t\t\t\t\t\t\t\tcase \"bold\":\n\t\t\t\t\t\t\t\tcase \"700\":\n\t\t\t\t\t\t\t\tcase \"800\":\n\t\t\t\t\t\t\t\tcase \"900\":\n\t\t\t\t\t\t\t\t\tthickness = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (fontSize) {\n\t\t\t\t\t\t\toffset = fontSize / 20;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet y: number;\n\n\t\t\t\t\t\tif (chunk.textDecoration == \"line-through\") {\n\t\t\t\t\t\t\ty = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ty = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.beginPath();\n\t\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\t\tcontext.strokeStyle = chunk.fill.toCSS();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.style.fill && this.style.fill instanceof Color) {\n\t\t\t\t\t\t\tcontext.strokeStyle = this.style.fill.toCSS();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontext.lineWidth = thickness * offset;\n\t\t\t\t\t\tcontext.moveTo(offsetX, y);\n\t\t\t\t\t\tcontext.lineTo(offsetX + chunk.width, y);\n\t\t\t\t\t\tcontext.stroke();\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (interactive && this.interactive) {\n\t\t\t\t\t\t// Draw text in ghost canvas ONLY if it is set as interactive\n\t\t\t\t\t\t// explicitly. This way we avoid hit test anomalies caused by anti\n\t\t\t\t\t\t// aliasing of text.\n\t\t\t\t\t\tghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcontext.restore();\n\t\t\tghostContext.restore();\n\t\t}\n\t}\n\n\tpublic _addBounds(bounds: IBounds): void {\n\t\tif (this.visible && this.isMeasured) {\n\t\t\t//if (this._textVisible) {\n\t\t\tconst x = this._measure({\n\t\t\t\tinactive: this.inactive,\n\t\t\t\tlayer: this.getLayer(),\n\t\t\t});\n\t\t\tsetPoint(bounds, { x: x.left, y: x.top });\n\t\t\tsetPoint(bounds, { x: x.right, y: x.bottom });\n\t\t\t//}\n\t\t}\n\t}\n\n\tprotected _ignoreFontWeight(): boolean {\n\t\treturn /apple/i.test(navigator.vendor);\n\t}\n\n\tpublic _measure(status: IStatus): IBounds {\n\t\tconst context = status.layer.context;\n\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\t\tconst rtl = this.style.direction == \"rtl\";\n\n\t\t// Reset text info\n\t\tthis._textInfo = [];\n\n\t\t// Init\n\t\tconst oversizedBehavior = this.style.oversizedBehavior;\n\t\tconst maxWidth = this.style.maxWidth!;\n\n\t\tconst truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n\t\tconst wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n\n\t\t// Pre-render\n\t\tcontext.save();\n\t\tghostContext.save();\n\t\tthis._prerender(status, true, this._ignoreFontWeight());\n\n\t\t// Get default font metrix\n\t\tconst refText = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \";\n\n\t\t// Split up text into lines\n\t\tconst lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n\t\tlet styleRestored = true;\n\t\tlet minX = 0;\n\t\tlet maxX = 0;\n\n\t\t// Iterate through the lines\n\t\tlet offsetY = 0;\n\t\tlet currentStyle: string | undefined;\n\t\t$array.each(lines, (line, _index) => {\n\n\t\t\t// Split up line into format/value chunks\n\t\t\tlet chunks: ITextChunk[];\n\t\t\tif (line == \"\") {\n\t\t\t\tchunks = [{\n\t\t\t\t\ttype: \"value\",\n\t\t\t\t\ttext: \"\"\n\t\t\t\t}];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n\t\t\t}\n\n\t\t\twhile (chunks.length > 0) {\n\n\t\t\t\t// Init line object\n\t\t\t\tlet lineInfo: ILine = {\n\t\t\t\t\toffsetY: offsetY,\n\t\t\t\t\tascent: 0,\n\t\t\t\t\twidth: 0,\n\t\t\t\t\theight: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttextChunks: []\n\t\t\t\t};\n\n\t\t\t\t// Measure reference text\n\t\t\t\tconst metrics = this._measureText(refText, context);\n\n\t\t\t\tconst height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\t\t\t\tlineInfo.height = height;\n\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\n\t\t\t\tlet currentFormat: string;\n\t\t\t\tlet currentDecoration: string | undefined = this.style.textDecoration;\n\t\t\t\tlet currentFill: Color | undefined;\n\t\t\t\tlet currentChunkWidth: number | undefined;\n\t\t\t\tlet skipFurtherText = false;\n\t\t\t\tlet firstTextChunk = true;\n\t\t\t\tlet leftoverChunks: Array<ITextChunk> = [];\n\t\t\t\tlet currentVerticalAlign: \"baseline\" | \"sub\" | \"super\" | undefined;\n\t\t\t\t//let offsetX = 0;\n\t\t\t\t//let chunk;\n\n\t\t\t\t//while(chunk = chunks.shift()) {\n\t\t\t\t$array.eachContinue(chunks, (chunk, index) => {\n\n\t\t\t\t\t// Format chunk\n\t\t\t\t\tif (chunk.type == \"format\") {\n\t\t\t\t\t\tif (chunk.text == \"[/]\") {\n\t\t\t\t\t\t\tif (!styleRestored) {\n\t\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t\t\t\tstyleRestored = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrentFill = undefined;\n\t\t\t\t\t\t\tcurrentStyle = undefined;\n\t\t\t\t\t\t\tcurrentChunkWidth = undefined;\n\t\t\t\t\t\t\tcurrentDecoration = this.style.textDecoration;\n\t\t\t\t\t\t\tcurrentVerticalAlign = undefined\n\t\t\t\t\t\t\tcurrentFormat = chunk.text;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\tif (!styleRestored) {\n\t\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet format = TextFormatter.getTextStyle(chunk.text);\n\t\t\t\t\t\t\tconst fontStyle = this._getFontStyle(format);\n\t\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\t\tghostContext.save();\n\t\t\t\t\t\t\tcontext.font = fontStyle;\n\t\t\t\t\t\t\tcurrentStyle = fontStyle;\n\t\t\t\t\t\t\tcurrentFormat = chunk.text;\n\t\t\t\t\t\t\tif (format.textDecoration) {\n\t\t\t\t\t\t\t\tcurrentDecoration = format.textDecoration;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (format.fill) {\n\t\t\t\t\t\t\t\tcurrentFill = <Color>format.fill;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((<any>format).width) {\n\t\t\t\t\t\t\t\tcurrentChunkWidth = $type.toNumber((<any>format).width);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (format.verticalAlign) {\n\t\t\t\t\t\t\t\tcurrentVerticalAlign = format.verticalAlign;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstyleRestored = false;\n\n\t\t\t\t\t\t\t// Measure reference text after change of format\n\t\t\t\t\t\t\tconst metrics = this._measureText(refText, context);\n\t\t\t\t\t\t\tconst height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\t\t\t\t\t\t\tif (height > lineInfo.height) {\n\t\t\t\t\t\t\t\tlineInfo.height = height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n\t\t\t\t\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Text chunk\n\t\t\t\t\telse if (chunk.type == \"value\" && !skipFurtherText) {\n\n\t\t\t\t\t\t// Measure\n\t\t\t\t\t\tconst metrics = this._measureText(chunk.text, context);\n\t\t\t\t\t\tlet chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n\n\t\t\t\t\t\t// Check for fit\n\t\t\t\t\t\tif (truncate) {\n\n\t\t\t\t\t\t\t// Break words?\n\t\t\t\t\t\t\tlet breakWords = firstTextChunk || this.style.breakWords || false;\n\n\t\t\t\t\t\t\t// Measure ellipsis and check if it fits\n\t\t\t\t\t\t\tconst ellipsis = this.style.ellipsis || \"\";\n\t\t\t\t\t\t\tconst ellipsisMetrics = this._measureText(ellipsis, context);\n\t\t\t\t\t\t\tconst ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n\n\t\t\t\t\t\t\t// Check fit\n\t\t\t\t\t\t\tif ((lineInfo.width + chunkWidth) > maxWidth) {\n\t\t\t\t\t\t\t\tconst excessWidth = maxWidth - lineInfo.width - ellipsisWidth;\n\t\t\t\t\t\t\t\tchunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);\n\t\t\t\t\t\t\t\tchunk.text += ellipsis;\n\t\t\t\t\t\t\t\tskipFurtherText = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (wrap) {\n\t\t\t\t\t\t\t// Check fit\n\t\t\t\t\t\t\tif ((lineInfo.width + chunkWidth) > maxWidth) {\n\t\t\t\t\t\t\t\tconst excessWidth = maxWidth - lineInfo.width;\n\t\t\t\t\t\t\t\tconst tmpText = this._truncateText(\n\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\tchunk.text,\n\t\t\t\t\t\t\t\t\texcessWidth,\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t(firstTextChunk && this.style.oversizedBehavior != \"wrap-no-break\")\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (tmpText == \"\") {\n\t\t\t\t\t\t\t\t\t// Unable to fit a single letter - hide the whole label\n\t\t\t\t\t\t\t\t\tthis.textVisible = true;\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//skipFurtherText = true;\n\n\t\t\t\t\t\t\t\t//Add remaining chunks for the next line\n\t\t\t\t\t\t\t\tleftoverChunks = chunks.slice(index + 1);\n\n\t\t\t\t\t\t\t\t//Add remaining text of current chunk if it was forced-cut\n\t\t\t\t\t\t\t\tif ($utils.trim(tmpText) != $utils.trim(chunk.text)) {\n\t\t\t\t\t\t\t\t\tleftoverChunks.unshift({\n\t\t\t\t\t\t\t\t\t\ttype: \"value\",\n\t\t\t\t\t\t\t\t\t\ttext: chunk.text.substr(tmpText.length)\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (currentFormat) {\n\t\t\t\t\t\t\t\t\t\tleftoverChunks.unshift({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"format\",\n\t\t\t\t\t\t\t\t\t\t\ttext: currentFormat\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set current chunk (truncated)\n\t\t\t\t\t\t\t\tchunk.text = $utils.trim(tmpText);\n\n\t\t\t\t\t\t\t\tchunks = [];\n\t\t\t\t\t\t\t\tskipFurtherText = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Chunk width?\n\t\t\t\t\t\tlet leftBoundMod = 1;\n\t\t\t\t\t\tlet rightBoundMod = 1;\n\t\t\t\t\t\tif (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {\n\t\t\t\t\t\t\t// increase horizontal bounding boxes accordingly\n\t\t\t\t\t\t\tconst boundsMod = chunkWidth / currentChunkWidth\n\t\t\t\t\t\t\tswitch (this.style.textAlign) {\n\t\t\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\t\tleftBoundMod = boundsMod;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\t\t\t\tleftBoundMod = boundsMod;\n\t\t\t\t\t\t\t\t\trightBoundMod = boundsMod;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\trightBoundMod = boundsMod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkWidth = currentChunkWidth;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\n\n\t\t\t\t\t\tif (chunkHeight > lineInfo.height) {\n\t\t\t\t\t\t\tlineInfo.height = chunkHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n\t\t\t\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlineInfo.width += chunkWidth;\n\t\t\t\t\t\tlineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;\n\t\t\t\t\t\tlineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;\n\t\t\t\t\t\tlineInfo.textChunks.push({\n\t\t\t\t\t\t\tstyle: currentStyle,\n\t\t\t\t\t\t\tfill: currentFill,\n\t\t\t\t\t\t\ttext: chunk.text,\n\t\t\t\t\t\t\twidth: chunkWidth,\n\t\t\t\t\t\t\theight: chunkHeight,\n\t\t\t\t\t\t\tleft: metrics.actualBoundingBoxLeft,\n\t\t\t\t\t\t\tright: metrics.actualBoundingBoxRight,\n\t\t\t\t\t\t\tascent: metrics.actualBoundingBoxAscent,\n\t\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\t\toffsetY: 0,\n\t\t\t\t\t\t\ttextDecoration: currentDecoration,\n\t\t\t\t\t\t\tverticalAlign: currentVerticalAlign\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t//offsetX += chunkWidth;\n\n\t\t\t\t\t\tfirstTextChunk = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (leftoverChunks) {\n\t\t\t\t\t\t//return false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t\t//}\n\t\t\t\t});\n\n\t\t\t\tif (this.style.lineHeight instanceof Percent) {\n\t\t\t\t\tlineInfo.height *= this.style.lineHeight.value;\n\t\t\t\t\tlineInfo.ascent *= this.style.lineHeight.value;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlineInfo.height *= this.style.lineHeight || 1.2;\n\t\t\t\t\tlineInfo.ascent *= this.style.lineHeight || 1.2;\n\t\t\t\t}\n\n\t\t\t\tif (minX < lineInfo.left) {\n\t\t\t\t\tminX = lineInfo.left;\n\t\t\t\t}\n\n\t\t\t\tif (maxX < lineInfo.right) {\n\t\t\t\t\tmaxX = lineInfo.right;\n\t\t\t\t}\n\n\t\t\t\tthis._textInfo!.push(lineInfo);\n\n\t\t\t\t//lineInfo.offsetY += lineInfo.ascent;\n\t\t\t\toffsetY += lineInfo.height;\n\n\t\t\t\t// Reset chunks so that it can proceed to the next line\n\t\t\t\tchunks = leftoverChunks || [];\n\t\t\t}\n\n\t\t});\n\n\t\tif (!styleRestored) {\n\t\t\tcontext.restore();\n\t\t\tghostContext.restore();\n\t\t}\n\n\t\t// Adjust chunk internal offsets\n\t\t$array.each(this._textInfo, (lineInfo, _index: number) => {\n\t\t\tlet currentChunkOffset = 0\n\t\t\t$array.each(lineInfo.textChunks, (chunk) => {\n\t\t\t\tchunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;\n\t\t\t\tchunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);\n\t\t\t\tcurrentChunkOffset += chunk.width;\n\n\t\t\t\tif (chunk.verticalAlign) {\n\t\t\t\t\tswitch (chunk.verticalAlign) {\n\t\t\t\t\t\tcase \"super\":\n\t\t\t\t\t\t\tchunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"sub\":\n\t\t\t\t\t\t\tchunk.offsetY += chunk.height / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tconst bounds = {\n\t\t\tleft: rtl ? -maxX : -minX,\n\t\t\ttop: 0,\n\t\t\tright: rtl ? minX : maxX,\n\t\t\tbottom: offsetY,\n\t\t};\n\n\n\t\t// We need to fit?\n\t\tif (oversizedBehavior !== \"none\") {\n\t\t\tconst ratio = this._fitRatio(bounds);\n\t\t\tif (ratio < 1) {\n\t\t\t\tif (oversizedBehavior == \"fit\") {\n\t\t\t\t\tif ($type.isNumber(this.style.minScale) && (ratio < this.style.minScale)) {\n\t\t\t\t\t\tthis.textVisible = false;\n\t\t\t\t\t\tbounds.left = 0;\n\t\t\t\t\t\tbounds.top = 0;\n\t\t\t\t\t\tbounds.right = 0;\n\t\t\t\t\t\tbounds.bottom = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this._originalScale || this._originalScale == 1) {\n\t\t\t\t\t\t\tthis._originalScale = this.scale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.scale = ratio;\n\t\t\t\t\t\tthis.textVisible = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (oversizedBehavior == \"hide\") {\n\t\t\t\t\tthis.textVisible = false;\n\t\t\t\t\tbounds.left = 0;\n\t\t\t\t\tbounds.top = 0;\n\t\t\t\t\tbounds.right = 0;\n\t\t\t\t\tbounds.bottom = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tswitch (this.style.textAlign) {\n\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\tbounds.left = rtl ? maxWidth : -maxWidth;\n\t\t\t\t\t\t\tbounds.right = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\t\tbounds.left = -maxWidth / 2;\n\t\t\t\t\t\t\tbounds.right = maxWidth / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbounds.left = 0;\n\t\t\t\t\t\t\tbounds.right = rtl ? -maxWidth : maxWidth;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.scale = this._originalScale || 1;\n\t\t\t\t\tthis._originalScale = undefined;\n\t\t\t\t\tthis.textVisible = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.scale = this._originalScale || 1;\n\t\t\t\tthis._originalScale = undefined;\n\t\t\t\tthis.textVisible = true;\n\t\t\t}\n\t\t}\n\n\t\tcontext.restore();\n\t\tghostContext.restore();\n\n\t\treturn bounds;\n\t}\n\n\tprotected _fitRatio(bounds: IBounds): number {\n\t\tconst maxW = this.style.maxWidth;\n\t\tconst maxH = this.style.maxHeight;\n\t\tif (!$type.isNumber(maxW) && !$type.isNumber(maxH)) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst w = bounds.right - bounds.left;\n\t\tconst h = bounds.bottom - bounds.top;\n\t\treturn Math.min(maxW! / w || 1, maxH! / h || 1);\n\t}\n\n\tprotected _truncateText(context: CanvasRenderingContext2D, text: string, maxWidth: number, breakWords: boolean = false, fallbackBreakWords: boolean = true): string {\n\t\tlet width: number;\n\t\tdo {\n\t\t\tif (breakWords) {\n\t\t\t\ttext = text.slice(0, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet tmp = text.replace(/[^,;:!?\\\\\\/\\s]+[,;:!?\\\\\\/\\s]*$/g, \"\");\n\t\t\t\tif ((tmp == \"\" || tmp === text) && fallbackBreakWords) {\n\t\t\t\t\tbreakWords = true;\n\t\t\t\t}\n\t\t\t\telse if (tmp == \"\") {\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttext = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst metrics = this._measureText(text, context);\n\t\t\twidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n\t\t} while ((width > maxWidth) && text != \"\");\n\t\treturn text;\n\t}\n\n\tprotected _measureText(text: string, context: CanvasRenderingContext2D): TextMetrics {\n\t\tlet metrics = context.measureText(text);\n\t\tlet fakeMetrics: any = {};\n\t\tif (metrics.actualBoundingBoxAscent == null) {\n\t\t\tconst div = document.createElement(\"div\");\n\t\t\tdiv.innerText = text;\n\t\t\tdiv.style.visibility = \"hidden\";\n\t\t\tdiv.style.position = \"absolute\";\n\t\t\tdiv.style.top = \"-1000000px;\"\n\t\t\tdiv.style.fontFamily = this.style.fontFamily || \"\";\n\t\t\tdiv.style.fontSize = this.style.fontSize + \"\";\n\t\t\tdocument.body.appendChild(div);\n\t\t\tconst bbox = div.getBoundingClientRect();\n\t\t\tdocument.body.removeChild(div);\n\t\t\tconst h = bbox.height;\n\t\t\tconst w = metrics.width;\n\t\t\tlet left = 0;\n\t\t\tlet right = w;\n\n\t\t\tfakeMetrics = {\n\t\t\t\tactualBoundingBoxAscent: h,\n\t\t\t\tactualBoundingBoxDescent: 0,\n\t\t\t\tactualBoundingBoxLeft: left,\n\t\t\t\tactualBoundingBoxRight: right,\n\t\t\t\tfontBoundingBoxAscent: h,\n\t\t\t\tfontBoundingBoxDescent: 0,\n\t\t\t\twidth: w\n\t\t\t}\n\t\t\t//return fake;\n\t\t}\n\t\telse {\n\t\t\tfakeMetrics = {\n\t\t\t\tactualBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n\t\t\t\tactualBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n\t\t\t\tactualBoundingBoxLeft: metrics.actualBoundingBoxLeft,\n\t\t\t\tactualBoundingBoxRight: metrics.actualBoundingBoxRight,\n\t\t\t\tfontBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n\t\t\t\tfontBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n\t\t\t\twidth: metrics.width\n\t\t\t}\n\t\t}\n\n\t\tconst w = metrics.width;\n\t\tswitch (this.style.textAlign) {\n\t\t\tcase \"right\":\n\t\t\tcase \"end\":\n\t\t\t\tfakeMetrics.actualBoundingBoxLeft = w;\n\t\t\t\tfakeMetrics.actualBoundingBoxRight = 0;\n\t\t\t\tbreak;\n\t\t\tcase \"center\":\n\t\t\t\tfakeMetrics.actualBoundingBoxLeft = w / 2;\n\t\t\t\tfakeMetrics.actualBoundingBoxRight = w / 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfakeMetrics.actualBoundingBoxLeft = 0;\n\t\t\t\tfakeMetrics.actualBoundingBoxRight = w;\n\t\t}\n\n\t\treturn fakeMetrics;\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasTextStyle implements ITextStyle {\n\t//public wordWrapWidth: number = 100;\n\tpublic fill?: Color | CanvasGradient | CanvasPattern;\n\tpublic fillOpacity?: number;\n\tpublic textAlign?: \"start\" | \"end\" | \"left\" | \"right\" | \"center\";\n\tpublic fontFamily?: string;\n\tpublic fontSize?: string | number;\n\tpublic fontWeight?: 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'\n\tpublic fontStyle?: 'normal' | 'italic' | 'oblique';\n\tpublic fontVariant?: \"normal\" | \"small-caps\";\n\tpublic textDecoration?: \"underline\" | \"line-through\";\n\tpublic shadowColor?: Color | null;\n\tpublic shadowBlur?: number;\n\tpublic shadowOffsetX?: number;\n\tpublic shadowOffsetY?: number;\n\tpublic shadowOpacity?: number;\n\t// leading?: number;\n\t// letterSpacing?: number;\n\tpublic lineHeight?: number | Percent = percent(120);\n\tpublic baselineRatio?: number = 0.19;\n\t// padding?: number;\n\t// stroke?: number;\n\t// strokeThickness?: number;\n\t// trim?: number;\n\t// wordWrap?: boolean;\n\tpublic direction?: \"ltr\" | \"rtl\";\n\tpublic textBaseline?: \"top\" | \"hanging\" | \"middle\" | \"alphabetic\" | \"ideographic\" | \"bottom\";\n\tpublic oversizedBehavior?: \"none\" | \"hide\" | \"fit\" | \"wrap\" | \"wrap-no-break\" | \"truncate\" = \"none\";\n\tpublic breakWords?: boolean = false;\n\tpublic ellipsis?: string = \"\";\n\tpublic maxWidth?: number;\n\tpublic maxHeight?: number;\n\tpublic minScale?: number;\n\tpublic ignoreFormatting?: boolean = false;\n}\n\n/**\n * @ignore\n */\nexport class CanvasRadialText extends CanvasText implements IRadialText {\n\tpublic textType?: \"regular\" | \"circular\" | \"radial\" | \"aligned\" | \"adjusted\" = \"circular\";\n\tpublic radius?: number;\n\tpublic startAngle?: number;\n\tpublic inside?: boolean = false;\n\tpublic orientation?: \"inward\" | \"outward\" | \"auto\" = \"auto\";\n\tpublic kerning?: number = 0;\n\n\tprivate _textReversed: boolean = false;\n\n\tpublic _render(status: IStatus): void {\n\t\tswitch (this.textType) {\n\t\t\tcase \"circular\":\n\t\t\t\tthis._renderCircular(status);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsuper._render(status);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic _renderCircular(status: IStatus): void {\n\t\tif (this.textVisible) {\n\t\t\tthis._prerender(status);\n\n\t\t\tconst interactive = this._isInteractive(status);\n\t\t\tconst context = status.layer.context;\n\t\t\tconst layerDirty = status.layer.dirty;\n\t\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t\t// Savepoint\n\t\t\tcontext.save();\n\t\t\tif (interactive) {\n\t\t\t\tghostContext.save();\n\t\t\t}\n\n\t\t\t// We need measurements in order to properly position text for alignment\n\t\t\tif (!this._textInfo) {\n\t\t\t\tthis._measure(status);\n\t\t\t}\n\n\t\t\t// Init\n\t\t\tlet radius = (this.radius || 0);\n\t\t\tlet startAngle = (this.startAngle || 0);\n\t\t\tlet deltaAngle = 0;\n\t\t\tlet orientation = this.orientation;\n\t\t\tlet inward = orientation == \"auto\" ? \"auto\" : orientation == \"inward\";\n\t\t\tconst inside = this.inside;\n\t\t\tconst align = this.style.textAlign || \"left\";\n\t\t\tconst kerning = this.kerning || 0;\n\t\t\tlet clockwise = align == \"left\" ? 1 : -1;\n\t\t\tconst shouldReverse = !this._textReversed;\n\n\t\t\t// Check if we need to invert the whole stuff\n\t\t\tif (inward == \"auto\") {\n\t\t\t\t// Calc max angle so we know whether we need to flip it\n\t\t\t\tlet maxAngle = 0;\n\t\t\t\tlet midAngle = 0;\n\t\t\t\t$array.each(this._textInfo!, (line, _index) => {\n\t\t\t\t\tconst deltaAngle = startAngle + (line.width / (radius - line.height)) / 2 * -clockwise;\n\t\t\t\t\tif (deltaAngle > maxAngle) {\n\t\t\t\t\t\tmaxAngle = deltaAngle;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (align == \"left\") {\n\t\t\t\t\tmidAngle = (maxAngle + deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t}\n\t\t\t\telse if (align == \"right\") {\n\t\t\t\t\tmidAngle = (maxAngle - deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmidAngle = startAngle * $math.DEGREES;\n\t\t\t\t}\n\t\t\t\tmidAngle = $math.normalizeAngle(midAngle);\n\t\t\t\tinward = (midAngle >= 270) || (midAngle <= 90);\n\t\t\t}\n\n\t\t\tif (inward == true && shouldReverse) {\n\t\t\t\tthis._textInfo!.reverse();\n\t\t\t\tthis._textReversed = true;\n\t\t\t}\n\n\t\t\t// if ((inward == false && align == \"left\") || (inward == true && align == \"right\")) {\n\t\t\t// \tclockwise *= -1;\n\t\t\t// }\n\n\t\t\t// Process text info produced by _measure()\n\t\t\t$array.each(this._textInfo!, (line, _index) => {\n\n\t\t\t\tconst textHeight = line.height;\n\n\t\t\t\t// Adjust radius (for `inside = false`)\n\t\t\t\t// Radius adjustment for `inside = false` is below the line calculation\n\t\t\t\tif (!inside) {\n\t\t\t\t\tradius += textHeight;\n\t\t\t\t}\n\n\t\t\t\t// Reverse letters if we're painting them counter-clockwise\n\t\t\t\tif (((clockwise == -1 && inward) || (clockwise == 1 && !inward)) && shouldReverse) {\n\t\t\t\t\tline.textChunks.reverse();\n\t\t\t\t}\n\n\t\t\t\t// Init angles\n\t\t\t\tlet lineStartAngle = startAngle;\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t\t// Adjust for center-align\n\t\t\t\tif (align == \"center\") {\n\t\t\t\t\tlineStartAngle += (line.width / (radius - textHeight)) / 2 * -clockwise;\n\t\t\t\t\tdeltaAngle = lineStartAngle - startAngle;\n\t\t\t\t}\n\n\t\t\t\t// if (inward == \"auto\") {\n\t\t\t\t// \tlet midAngle;\n\t\t\t\t// \tif (align == \"left\") {\n\t\t\t\t// \t\tmidAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t// \t}\n\t\t\t\t// \telse if () {\n\t\t\t\t// \t\tmidAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t// \t}\n\t\t\t\t// \tinward = (midAngle >= 270) || (midAngle <= 90);\n\t\t\t\t// }\n\n\t\t\t\t// Rotate letters if they are facing outward\n\t\t\t\tlineStartAngle += (Math.PI * (inward ? 0 : 1)); // Rotate 180 if outward\n\n\t\t\t\t// Savepoint\n\t\t\t\tcontext.save();\n\t\t\t\tif (interactive) {\n\t\t\t\t\tghostContext.save();\n\t\t\t\t}\n\n\t\t\t\t// Assume starting angle\n\t\t\t\tcontext.rotate(lineStartAngle);\n\t\t\t\tif (interactive) {\n\t\t\t\t\tghostContext.rotate(lineStartAngle);\n\t\t\t\t}\n\n\t\t\t\tlet angleShift = 0;\n\t\t\t\t$array.each(line.textChunks, (chunk, _index) => {\n\n\t\t\t\t\t// Draw the letter\n\t\t\t\t\tconst char = chunk.text;\n\t\t\t\t\tconst charWidth = chunk.width;\n\n\t\t\t\t\t// Rotate half a letter\n\t\t\t\t\tangleShift = (charWidth / 2) / (radius - textHeight) * clockwise;\n\t\t\t\t\tcontext.rotate(angleShift);\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.rotate(angleShift);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tghostContext.save();\n\n\t\t\t\t\t\tcontext.font = chunk.style;\n\t\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\t\tghostContext.font = chunk.style;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.fillStyle = chunk.fill.toCSS();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Center letters\n\t\t\t\t\tcontext.textBaseline = \"middle\";\n\t\t\t\t\tcontext.textAlign = \"center\";\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.textBaseline = \"middle\";\n\t\t\t\t\t\tghostContext.textAlign = \"center\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Plop the letter\n\t\t\t\t\tif (layerDirty) {\n\t\t\t\t\t\tcontext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n\t\t\t\t\t}\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Rotate half a letter and add spacing\n\t\t\t\t\tangleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;\n\t\t\t\t\tcontext.rotate(angleShift);\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.rotate(angleShift);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\t// Restore angle\n\t\t\t\tcontext.restore();\n\t\t\t\tif (interactive) {\n\t\t\t\t\tghostContext.restore();\n\t\t\t\t}\n\n\t\t\t\t// Adjust radius (for `inside = true`)\n\t\t\t\tif (inside) {\n\t\t\t\t\tradius -= textHeight;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// Restore\n\t\t\tcontext.restore();\n\t\t\tif (interactive) {\n\t\t\t\tghostContext.restore();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _measure(status: IStatus): IBounds {\n\t\tswitch (this.textType) {\n\t\t\tcase \"circular\":\n\t\t\t\treturn this._measureCircular(status);\n\t\t\tdefault:\n\t\t\t\treturn super._measure(status);\n\t\t}\n\t}\n\n\tpublic _measureCircular(status: IStatus): IBounds {\n\t\tconst context = status.layer.context;\n\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\t\tconst rtl = this.style.direction == \"rtl\";\n\n\t\tconst oversizedBehavior = this.style.oversizedBehavior;\n\t\tconst maxWidth = this.style.maxWidth!;\n\n\t\tconst truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n\t\tconst ellipsis = this.style.ellipsis || \"\";\n\t\tlet ellipsisMetrics: TextMetrics;\n\t\t//const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n\n\n\t\t// Reset text info\n\t\tthis.textVisible = true;\n\t\tthis._textInfo = [];\n\t\tthis._textReversed = false;\n\n\t\t// Pre-render\n\t\tcontext.save();\n\t\tghostContext.save();\n\t\tthis._prerender(status, true);\n\n\t\t// Split up text into lines\n\t\tconst lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n\t\tlet styleRestored = true;\n\t\tlet totalWidth = 0;\n\n\t\t// Iterate through the lines\n\t\tlet offsetY = 0;\n\t\t$array.each(lines, (line, _index) => {\n\n\t\t\t// Split up line into format/value chunks\n\t\t\tlet chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n\n\t\t\t// Init line object\n\t\t\tlet lineInfo: ILine = {\n\t\t\t\toffsetY: offsetY,\n\t\t\t\tascent: 0,\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttextChunks: []\n\t\t\t};\n\n\t\t\tlet currentStyle: string | undefined;\n\t\t\tlet currentFill: Color | undefined;\n\t\t\tlet currentChunkWidth: number | undefined;\n\n\t\t\t//while(chunk = chunks.shift()) {\n\t\t\t$array.each(chunks, (chunk, _index) => {\n\n\t\t\t\t// Format chunk\n\t\t\t\tif (chunk.type == \"format\") {\n\t\t\t\t\tif (chunk.text == \"[/]\") {\n\t\t\t\t\t\tif (!styleRestored) {\n\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t\t\tstyleRestored = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentFill = undefined;\n\t\t\t\t\t\tcurrentStyle = undefined;\n\t\t\t\t\t\tcurrentChunkWidth = undefined;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet format = TextFormatter.getTextStyle(chunk.text);\n\t\t\t\t\t\tconst fontStyle = this._getFontStyle(format);\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tghostContext.save();\n\t\t\t\t\t\tcontext.font = fontStyle;\n\t\t\t\t\t\tcurrentStyle = fontStyle;\n\t\t\t\t\t\tif (format.fill) {\n\t\t\t\t\t\t\tcurrentFill = <Color>format.fill;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((<any>format).width) {\n\t\t\t\t\t\t\tcurrentChunkWidth = $type.toNumber((<any>format).width);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstyleRestored = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (truncate) {\n\t\t\t\t\t\tellipsisMetrics = this._measureText(ellipsis, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Text format\n\t\t\t\telse if (chunk.type == \"value\") {\n\n\t\t\t\t\t// Measure each letter\n\t\t\t\t\tlet chars = chunk.text.match(/./ug) || [];\n\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\tchars = $utils.splitString(chunk.text);\n\t\t\t\t\t\tchars.reverse();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < chars.length; i++) {\n\n\t\t\t\t\t\tconst char = chars[i];\n\n\t\t\t\t\t\t// Measure\n\t\t\t\t\t\tconst metrics = this._measureText(char, context);\n\t\t\t\t\t\tlet chunkWidth = metrics.width;\n\n\t\t\t\t\t\t// Chunk width?\n\t\t\t\t\t\tif (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {\n\t\t\t\t\t\t\tchunkWidth = currentChunkWidth;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\t\t\t\t\t\tif (chunkHeight > lineInfo.height) {\n\t\t\t\t\t\t\tlineInfo.height = chunkHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n\t\t\t\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttotalWidth += chunkWidth;\n\n\t\t\t\t\t\t// Handle oversized behavior\n\t\t\t\t\t\tif (truncate) {\n\t\t\t\t\t\t\t// Measure ellipsis and check if it fits\n\t\t\t\t\t\t\tif (!ellipsisMetrics) {\n\t\t\t\t\t\t\t\tellipsisMetrics = this._measureText(ellipsis, context);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n\t\t\t\t\t\t\t//totalWidth += ellipsisWidth;\n\t\t\t\t\t\t\tif ((totalWidth + ellipsisWidth) > maxWidth) {\n\t\t\t\t\t\t\t\tif (lineInfo.textChunks.length == 1) {\n\t\t\t\t\t\t\t\t\tthis.textVisible = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tlineInfo.width += ellipsisWidth;\n\t\t\t\t\t\t\t\t\tlineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;\n\t\t\t\t\t\t\t\t\tlineInfo.right += ellipsisMetrics.actualBoundingBoxRight;\n\t\t\t\t\t\t\t\t\tlineInfo.textChunks.push({\n\t\t\t\t\t\t\t\t\t\tstyle: currentStyle,\n\t\t\t\t\t\t\t\t\t\tfill: currentFill,\n\t\t\t\t\t\t\t\t\t\ttext: ellipsis,\n\t\t\t\t\t\t\t\t\t\twidth: ellipsisWidth,\n\t\t\t\t\t\t\t\t\t\theight: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,\n\t\t\t\t\t\t\t\t\t\tleft: ellipsisMetrics.actualBoundingBoxLeft,\n\t\t\t\t\t\t\t\t\t\tright: ellipsisMetrics.actualBoundingBoxRight,\n\t\t\t\t\t\t\t\t\t\tascent: ellipsisMetrics.actualBoundingBoxAscent,\n\t\t\t\t\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\t\t\t\t\toffsetY: chunkHeight,\n\t\t\t\t\t\t\t\t\t\ttextDecoration: undefined\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlineInfo.width += chunkWidth;\n\t\t\t\t\t\tlineInfo.left += metrics.actualBoundingBoxLeft;\n\t\t\t\t\t\tlineInfo.right += metrics.actualBoundingBoxRight;\n\t\t\t\t\t\tlineInfo.textChunks.push({\n\t\t\t\t\t\t\tstyle: currentStyle,\n\t\t\t\t\t\t\tfill: currentFill,\n\t\t\t\t\t\t\ttext: char,\n\t\t\t\t\t\t\twidth: chunkWidth,\n\t\t\t\t\t\t\theight: chunkHeight + metrics.actualBoundingBoxDescent,\n\t\t\t\t\t\t\tleft: metrics.actualBoundingBoxLeft,\n\t\t\t\t\t\t\tright: metrics.actualBoundingBoxRight,\n\t\t\t\t\t\t\tascent: metrics.actualBoundingBoxAscent,\n\t\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\t\toffsetY: chunkHeight,\n\t\t\t\t\t\t\ttextDecoration: undefined\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\t\t// @todo still needed?\n\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (this.style.lineHeight instanceof Percent) {\n\t\t\t\tlineInfo.height *= this.style.lineHeight.value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlineInfo.height *= this.style.lineHeight || 1.2;\n\t\t\t}\n\n\t\t\tthis._textInfo!.push(lineInfo);\n\n\t\t\t//lineInfo.offsetY += lineInfo.ascent;\n\t\t\toffsetY += lineInfo.height;\n\n\n\t\t});\n\n\t\tif (!styleRestored) {\n\t\t\tcontext.restore();\n\t\t\tghostContext.restore();\n\t\t}\n\n\n\t\tif (oversizedBehavior == \"hide\" && (totalWidth > maxWidth)) {\n\t\t\tthis.textVisible = false;\n\t\t}\n\n\t\t// Adjust chunk internal offsets\n\t\t$array.each(this._textInfo, (lineInfo) => {\n\t\t\t$array.each(lineInfo.textChunks, (chunk) => {\n\t\t\t\tchunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);\n\t\t\t});\n\t\t});\n\n\t\tcontext.restore();\n\t\tghostContext.restore();\n\n\t\treturn {\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t};\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasImage extends CanvasDisplayObject implements IPicture {\n\tpublic width: number | undefined;\n\tpublic height: number | undefined;\n\tpublic image: HTMLImageElement | undefined;\n\tpublic tainted?: boolean;\n\n\tpublic shadowColor?: Color;\n\tpublic shadowBlur?: number;\n\tpublic shadowOffsetX?: number;\n\tpublic shadowOffsetY?: number;\n\tpublic shadowOpacity?: number;\n\n\tprotected _imageMask: HTMLCanvasElement | undefined;\n\n\tconstructor(renderer: CanvasRenderer, image: HTMLImageElement | undefined) {\n\t\tsuper(renderer);\n\t\tthis.image = image;\n\t}\n\n\tprotected _dispose(): void {\n\t\tsuper._dispose();\n\n\t\tif (this._imageMask) {\n\t\t\tclearCanvas(this._imageMask);\n\t\t}\n\t}\n\n\tgetLocalBounds(): IBounds {\n\t\tif (!this._localBounds) {\n\n\n\t\t\tlet w = 0;\n\t\t\tlet h = 0;\n\n\t\t\tif (this.width) {\n\t\t\t\tw = this.width;\n\t\t\t}\n\t\t\tif (this.height) {\n\t\t\t\th = this.height;\n\t\t\t}\n\n\t\t\tthis._localBounds = {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tright: w,\n\t\t\t\tbottom: h\n\t\t\t};\n\n\t\t\tthis._addBounds(this._localBounds);\n\t\t}\n\t\treturn this._localBounds;\n\t}\n\n\tprotected _render(status: IStatus): void {\n\t\tsuper._render(status);\n\n\t\tif (this.image) {\n\t\t\tif (this.tainted === undefined) {\n\t\t\t\tthis.tainted = isTainted(this.image);\n\t\t\t\tstatus.layer.tainted = true;\n\t\t\t}\n\n\t\t\tif (this.tainted && this._renderer._omitTainted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (status.layer.dirty) {\n\n\t\t\t\tif (this.shadowColor) {\n\t\t\t\t\tstatus.layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);\n\t\t\t\t}\n\t\t\t\tif (this.shadowBlur) {\n\t\t\t\t\tstatus.layer.context.shadowBlur = this.shadowBlur;\n\t\t\t\t}\n\t\t\t\tif (this.shadowOffsetX) {\n\t\t\t\t\tstatus.layer.context.shadowOffsetX = this.shadowOffsetX;\n\t\t\t\t}\n\t\t\t\tif (this.shadowOffsetY) {\n\t\t\t\t\tstatus.layer.context.shadowOffsetY = this.shadowOffsetY;\n\t\t\t\t}\n\n\t\t\t\t// TODO should this round ?\n\t\t\t\tconst width = this.width || this.image.naturalWidth;\n\t\t\t\tconst height = this.height || this.image.naturalHeight;\n\n\t\t\t\tstatus.layer.context.drawImage(this.image, 0, 0, width, height);\n\t\t\t}\n\n\t\t\tif (this.interactive && this._isInteractive(status)) {\n\t\t\t\tconst mask = this._getMask(this.image);\n\n\t\t\t\tthis._renderer._ghostLayer.context.drawImage(mask, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic clear(): void {\n\t\tsuper.clear();\n\t\tthis.image = undefined;\n\t\tthis._imageMask = undefined;\n\t}\n\n\tprotected _getMask(image: HTMLImageElement): HTMLCanvasElement {\n\t\tif (this._imageMask === undefined) {\n\t\t\t// TODO should this round ?\n\t\t\tconst width = this.width || image.naturalWidth;\n\t\t\tconst height = this.height || image.naturalHeight;\n\n\t\t\t// We need to create a second canvas because destination-in clears out the entire canvas\n\t\t\tconst canvas = document.createElement(\"canvas\");\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst context = canvas.getContext(\"2d\")!;\n\n\t\t\tcontext.imageSmoothingEnabled = false;\n\n\t\t\tcontext.fillStyle = this._getColorId();\n\t\t\tcontext.fillRect(0, 0, width, height);\n\n\t\t\tif (!isTainted(image)) {\n\t\t\t\tcontext.globalCompositeOperation = \"destination-in\";\n\t\t\t\tcontext.drawImage(image, 0, 0, width, height);\n\t\t\t}\n\n\t\t\tthis._imageMask = canvas;\n\t\t}\n\n\t\treturn this._imageMask;\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasRendererEvent<A> implements IRendererEvent<A> {\n\tpublic id: Id;\n\tpublic simulated: boolean = false;\n\tpublic native: boolean = true;\n\n\tconstructor(public event: A, public originalPoint: IPoint, public point: IPoint, public bbox: DOMRect) {\n\t\tif ($utils.supports(\"touchevents\") && event instanceof Touch) {\n\t\t\tthis.id = event.identifier;\n\n\t\t} else {\n\t\t\tthis.id = null;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\ninterface IEvent<Key extends keyof IRendererEvents> {\n\tobject: CanvasDisplayObject;\n\tcontext: unknown;\n\tcallback: (event: IRendererEvents[Key]) => void;\n\tdisposed: boolean;\n}\n\n/**\n * @ignore\n */\ninterface IEvents<Key extends keyof IRendererEvents> {\n\tdisposer: IDisposer;\n\tcallbacks: Array<IEvent<Key>>;\n\tdispatching: boolean;\n\tcleanup: boolean;\n}\n\n/**\n * @ignore\n */\nexport class CanvasRenderer extends ArrayDisposer implements IRenderer, IDisposer {\n\tpublic view: HTMLElement = document.createElement(\"div\");\n\tprotected _layerDom: HTMLElement = document.createElement(\"div\");\n\n\tpublic layers: Array<CanvasLayer> = [];\n\tpublic _dirtyLayers: Array<CanvasLayer> = [];\n\tpublic defaultLayer: CanvasLayer = this.getLayer(0);\n\n\tpublic _ghostLayer: GhostLayer = new GhostLayer();\n\n\tprotected _patternCanvas: HTMLCanvasElement = document.createElement(\"canvas\");\n\tprotected _patternContext: CanvasRenderingContext2D = this._patternCanvas.getContext(\"2d\")!;\n\n\tprotected _realWidth: number = 0;\n\tprotected _realHeight: number = 0;\n\n\tprotected _calculatedWidth: number = 0;\n\tprotected _calculatedHeight: number = 0;\n\n\tpublic resolution: number;\n\tpublic interactionsEnabled: boolean = true;\n\n\tprotected _listeners: { [key: string]: CounterDisposer } = {};\n\tprotected _events: { [Key in keyof IRendererEvents]?: IEvents<Key> } = {};\n\n\tprotected _colorId: number = 0;\n\tprotected _colorMap: { [color: string]: CanvasDisplayObject } = {};\n\n\tpublic _forceInteractive: number = 0;\n\tpublic _omitTainted: boolean = false;\n\n\t// TODO this should store the Id as well\n\tpublic _hovering: Set<CanvasDisplayObject> = new Set();\n\tpublic _dragging: Array<{ id: Id, value: CanvasDisplayObject }> = [];\n\tpublic _mousedown: Array<{ id: Id, value: CanvasDisplayObject }> = [];\n\n\tprotected _lastPointerMoveEvent: { events: Array<IPointerEvent>, target: Node | null, native: boolean } | undefined;\n\n\tpublic tapToActivate: boolean = false;\n\tpublic tapToActivateTimeout: number = 3000;\n\tpublic _touchActive: boolean = false;\n\tprotected _touchActiveTimeout?: number;\n\n\t/*protected _mouseMoveThrottler: Throttler = new Throttler(() => {\n\t\tthis._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);\n\t});\n\t*/\n\n\tpublic resetImageArray() {\n\t\tthis._ghostLayer.imageArray = undefined;\n\t}\n\n\tconstructor(resolution?: number) {\n\t\tsuper();\n\n\t\tif (resolution == null) {\n\t\t\tthis.resolution = window.devicePixelRatio;\n\t\t} else {\n\t\t\tthis.resolution = resolution;\n\t\t}\n\n\t\tthis.view.style.position = \"absolute\";\n\t\tthis.view.setAttribute(\"aria-hidden\", \"true\");\n\t\tthis.view.appendChild(this._layerDom);\n\n\t\tthis._disposers.push(new Disposer(() => {\n\t\t\t$object.each(this._events, (_key, events) => {\n\t\t\t\tevents.disposer.dispose();\n\t\t\t});\n\n\t\t\t$array.each(this.layers, (layer) => {\n\t\t\t\tclearCanvas(layer.view);\n\n\t\t\t\tif (layer.exportableView) {\n\t\t\t\t\tclearCanvas(layer.exportableView);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tclearCanvas(this._ghostLayer.view);\n\t\t\tclearCanvas(this._patternCanvas);\n\t\t}));\n\n\t\t/*\n\t\tthis._disposers.push($utils.addEventListener(this._ghostLayer.view, \"click\", (originalEvent: MouseEvent) => {\n\t\t\tconst event = this.getEvent(originalEvent);\n\t\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox);\n\t\t\tconsole.debug(target);\n\t\t}));\n\t\t*/\n\n\t\t// Monitor for possible pixel ratio changes (when page is zoomed)\n\t\tthis._disposers.push($utils.onZoom(() => {\n\t\t\tif (resolution == null) {\n\t\t\t\tthis.resolution = window.devicePixelRatio;\n\t\t\t}\n\t\t}));\n\n\t\t// We need this in order top prevent default touch gestures when dragging\n\t\t// draggable elements\n\t\tif ($utils.supports(\"touchevents\")) {\n\t\t\tconst listener = (ev: any) => {\n\t\t\t\tif (this._dragging.length !== 0) {\n\t\t\t\t\t$array.eachContinue(this._dragging, (item) => {\n\t\t\t\t\t\tif (item.value.shouldCancelTouch()) {\n\t\t\t\t\t\t\tev.preventDefault();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If touch down happends, delay touch out\n\t\t\t\tif (this._touchActiveTimeout) {\n\t\t\t\t\tthis._delayTouchDeactivate();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._disposers.push($utils.addEventListener(window, \"touchstart\", listener, { passive: false }));\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"touchstart\", listener, { passive: false }));\n\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"touchmove\", () => {\n\t\t\t\t// If touch is moving, delay touch out\n\t\t\t\tif (this._touchActiveTimeout) {\n\t\t\t\t\tthis._delayTouchDeactivate();\n\t\t\t\t}\n\t\t\t}, { passive: true }));\n\n\t\t\tthis._disposers.push($utils.addEventListener(window, \"click\", (_ev: any) => {\n\t\t\t\tthis._touchActive = false;\n\t\t\t}, { passive: true }));\n\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"click\", (_ev: any) => {\n\t\t\t\twindow.setTimeout(() => {\n\t\t\t\t\tthis._touchActive = true;\n\t\t\t\t\tthis._delayTouchDeactivate();\n\t\t\t\t}, 100);\n\t\t\t}, { passive: true }));\n\n\t\t}\n\n\t\t// Prevent scrolling of the window when hovering on \"wheelable\" object\n\t\tif ($utils.supports(\"wheelevents\")) {\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"wheel\", (ev) => {\n\t\t\t\tlet prevent = false;\n\t\t\t\tthis._hovering.forEach((obj) => {\n\t\t\t\t\tif (obj.wheelable) {\n\t\t\t\t\t\tprevent = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (prevent) {\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t}\n\t\t\t}, { passive: false }));\n\t\t}\n\n\t}\n\n\tprotected _delayTouchDeactivate(): void {\n\t\tif (this._touchActiveTimeout) {\n\t\t\tclearTimeout(this._touchActiveTimeout);\n\t\t}\n\t\tif (this.tapToActivateTimeout > 0) {\n\t\t\tthis._touchActiveTimeout = window.setTimeout(() => {\n\t\t\t\tthis._touchActive = false;\n\t\t\t}, this.tapToActivateTimeout);\n\t\t}\n\t}\n\n\tpublic get debugGhostView(): boolean {\n\t\treturn !!this._ghostLayer.view.parentNode;\n\t}\n\n\tpublic set debugGhostView(value: boolean) {\n\t\tif (value) {\n\t\t\tif (!this._ghostLayer.view.parentNode) {\n\t\t\t\tthis.view.appendChild(this._ghostLayer.view);\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (this._ghostLayer.view.parentNode) {\n\t\t\t\tthis._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateLinearGradient(x1: number, y1: number, x2: number, y2: number): CanvasGradient {\n\t\treturn this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);\n\t}\n\n\tcreateRadialGradient(x1: number, y1: number, radius1: number, x2: number, y2: number, radius2: number): CanvasGradient {\n\t\treturn this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);\n\t}\n\n\tcreatePattern(graphics: CanvasGraphics, background: CanvasGraphics, repetition: string, width: number, height: number): CanvasPattern {\n\t\t// const patternCanvas = document.createElement(\"canvas\");\n\t\t// const patternContext = patternCanvas.getContext(\"2d\")!;\n\t\t// patternCanvas.width = width;\n\t\t// patternCanvas.height = height;\n\t\t// if (fill) {\n\t\t// \tpatternContext.fillStyle = fill.toCSS();\n\t\t// \tpatternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);\n\t\t// }\n\n\t\t// const layer = {\n\t\t// \tview: patternCanvas,\n\t\t// \tcontext: patternContext,\n\t\t// \tvisible: true,\n\t\t// \torder: 0,\n\t\t// \twidth: width,\n\t\t// \theight: height,\n\t\t// \tdirty: true\n\t\t// };\n\n\t\t// // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);\n\t\t// // patternContext.stroke();\n\n\t\t// image.targetLayer = layer;\n\t\t// image.render(layer);\n\n\t\t//this._layerDom.appendChild(patternCanvas);\n\n\t\tthis._patternCanvas.width = width;\n\t\tthis._patternCanvas.height = height;\n\n\t\tthis._patternContext.clearRect(0, 0, width, height);\n\n\t\t// patternCanvas.style.width = width * this.resolution + \"px\";\n\t\t// patternCanvas.style.height = height * this.resolution + \"px\";\n\n\t\tbackground.renderDetached(this._patternContext);\n\t\tgraphics.renderDetached(this._patternContext);\n\n\t\treturn this._patternContext.createPattern(this._patternCanvas, repetition)!;\n\t}\n\n\n\n\tmakeContainer(): CanvasContainer {\n\t\treturn new CanvasContainer(this);\n\t}\n\n\tmakeGraphics(): CanvasGraphics {\n\t\treturn new CanvasGraphics(this);\n\t}\n\n\tmakeText(text: string, style: CanvasTextStyle): CanvasText {\n\t\treturn new CanvasText(this, text, style);\n\t}\n\n\tmakeTextStyle(): CanvasTextStyle {\n\t\treturn new CanvasTextStyle();\n\t}\n\n\tmakeRadialText(text: string, style: CanvasTextStyle): CanvasRadialText {\n\t\treturn new CanvasRadialText(this, text, style);\n\t}\n\n\tmakePicture(image: HTMLImageElement | undefined): CanvasImage {\n\t\treturn new CanvasImage(this, image);\n\t}\n\n\tresizeLayer(layer: CanvasLayer) {\n\t\tlayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);\n\t}\n\n\tresizeGhost() {\n\t\tthis._ghostLayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);\n\t}\n\n\tresize(realWidth: number, realHeight: number, calculatedWidth: number, calculatedHeight: number): void {\n\t\tthis._realWidth = realWidth;\n\t\tthis._realHeight = realHeight;\n\n\t\tthis._calculatedWidth = calculatedWidth;\n\t\tthis._calculatedHeight = calculatedHeight;\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer) {\n\t\t\t\tlayer.dirty = true;\n\t\t\t\tthis.resizeLayer(layer);\n\t\t\t}\n\t\t});\n\n\t\tthis.resizeGhost();\n\n\t\tthis.view.style.width = calculatedWidth + \"px\";\n\t\tthis.view.style.height = calculatedHeight + \"px\";\n\t}\n\n\tprivate createDetachedLayer(willReadFrequently: boolean = false): CanvasLayer {\n\t\tconst view = document.createElement(\"canvas\");\n\t\tconst context = view.getContext(\"2d\", { willReadFrequently: willReadFrequently })! as CanvasRenderingContext2D;\n\n\t\tconst layer = new CanvasLayer(view, context);\n\n\t\tview.style.position = \"absolute\";\n\t\tview.style.top = \"0px\";\n\t\tview.style.left = \"0px\";\n\n\t\treturn layer;\n\t}\n\n\tgetLayerByOrder(order: number): CanvasLayer | undefined {\n\t\tconst layers = this.layers;\n\t\tconst length = layers.length;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst layer = layers[i];\n\t\t\tif (layer.order == order) {\n\t\t\t\treturn layer;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetLayer(order: number, visible: boolean = true): CanvasLayer {\n\t\tlet existingLayer = this.getLayerByOrder(order);\n\t\tif (existingLayer) {\n\t\t\treturn existingLayer;\n\t\t}\n\n\t\tconst layer = this.createDetachedLayer(order == 99);\n\t\tlayer.order = order;\n\t\tlayer.visible = visible;\n\n\t\tlayer.view.className = \"am5-layer-\" + order;\n\n\t\tif (layer.visible) {\n\t\t\tthis.resizeLayer(layer);\n\t\t}\n\n\t\tconst layers = this.layers;\n\n\t\tlayers.push(layer);\n\n\t\tlayers.sort((a, b) => {\n\t\t\tif (a.order > b.order) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (a.order < b.order) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tconst length = layers.length;\n\t\tconst layerIndex = $array.indexOf(layers, layer);\n\t\tlet next;\n\n\t\tfor (let i = layerIndex + 1; i < length; i++) {\n\t\t\tif (layers[i].visible) {\n\t\t\t\tnext = layers[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (layer.visible) {\n\t\t\tif (next === undefined) {\n\t\t\t\tthis._layerDom.appendChild(layer.view);\n\n\t\t\t} else {\n\t\t\t\tthis._layerDom.insertBefore(layer.view, next.view);\n\t\t\t}\n\t\t}\n\n\t\treturn layer;\n\t}\n\n\trender(root: CanvasDisplayObject): void {\n\n\t\tthis._dirtyLayers.length = 0;\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer) {\n\t\t\t\tif (layer.dirty && layer.visible) {\n\t\t\t\t\tthis._dirtyLayers.push(layer);\n\t\t\t\t\tlayer.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis._ghostLayer.clear();\n\n\t\troot.render({\n\t\t\tinactive: null,\n\t\t\tlayer: this.defaultLayer,\n\t\t});\n\n\t\tthis._ghostLayer.context.restore();\n\n\t\t//setTimeout(() => {\n\n\t\t// Remove this after the Chrome bug is fixed:\n\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=1279394\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer) {\n\t\t\t\tconst context = layer.context;\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(0, 0);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t});\n\n\t\t$array.each(this._dirtyLayers, (layer) => {\n\t\t\tlayer.context.restore();\n\t\t\tlayer.dirty = false;\n\t\t});\n\t\t//}, 100)\n\n\t\tif (this._hovering.size && this._lastPointerMoveEvent) {\n\t\t\tconst { events, target, native } = this._lastPointerMoveEvent;\n\n\t\t\t//this._mouseMoveThrottler.run();\n\n\t\t\t$array.each(events, (event) => {\n\t\t\t\tthis._dispatchGlobalMousemove(event, target, native);\n\t\t\t});\n\t\t}\n\t}\n\n\tpaintId(obj: CanvasDisplayObject): string {\n\t\tconst id = distributeId(++this._colorId);\n\t\tconst color = Color.fromHex(id).toCSS();\n\t\tthis._colorMap[color] = obj;\n\t\treturn color;\n\t}\n\n\t_removeObject(obj: CanvasDisplayObject): void {\n\t\tif (obj._colorId !== undefined) {\n\t\t\tdelete this._colorMap[obj._colorId];\n\t\t}\n\t}\n\n\t// protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {\n\t// \treturn this._colorMap[colorId];\n\t// }\n\n\tprotected _adjustBoundingBox(bbox: DOMRect): DOMRect {\n\t\tconst margin = this._ghostLayer.margin;\n\n\t\treturn new DOMRect(\n\t\t\t-margin.left,\n\t\t\t-margin.top,\n\t\t\tbbox.width + margin.left + margin.right,\n\t\t\tbbox.height + margin.top + margin.bottom,\n\t\t);\n\t}\n\n\tpublic getEvent<A extends IPointerEvent>(originalEvent: A, adjustPoint: boolean = true): CanvasRendererEvent<A> {\n\t\tconst bbox = this.view.getBoundingClientRect();\n\n\t\tconst x = originalEvent.clientX || 0;\n\t\tconst y = originalEvent.clientY || 0;\n\n\t\tconst widthScale = this._calculatedWidth / this._realWidth;\n\t\tconst heightScale = this._calculatedHeight / this._realHeight;\n\n\t\tconst originalPoint: IPoint = {\n\t\t\tx: x - bbox.left,\n\t\t\ty: y - bbox.top,\n\t\t};\n\n\t\tconst point: IPoint = {\n\t\t\tx: (x - (adjustPoint ? bbox.left : 0)) * widthScale,\n\t\t\ty: (y - (adjustPoint ? bbox.top : 0)) * heightScale,\n\t\t};\n\n\t\treturn new CanvasRendererEvent(\n\t\t\toriginalEvent,\n\t\t\toriginalPoint,\n\t\t\tpoint,\n\t\t\tthis._adjustBoundingBox(bbox),\n\t\t);\n\t}\n\n\t_getHitTarget(point: IPoint, bbox: DOMRect, target: Node | null): CanvasDisplayObject | undefined | false {\n\t\tif (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target || !this._layerDom.contains(target)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pixel = this._ghostLayer.getImageData(point, bbox);\n\n\t\tif (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();\n\t\tconst hit = this._colorMap[colorId];\n\n\t\treturn hit;\n\t}\n\n\tgetObjectAtPoint(point: IPoint): CanvasDisplayObject | undefined {\n\t\tconst data = this._ghostLayer.getImageArray(point);\n\n\t\tif (data[0] === 0 && data[1] === 0 && data[2] === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst colorId = Color.fromRGB(data[0], data[1], data[2]).toCSS();\n\t\tconst hit = this._colorMap[colorId];\n\n\t\treturn hit;\n\t}\n\n\t_withEvents<Key extends keyof IRendererEvents>(key: Key, f: (events: IEvents<Key>) => void): void {\n\t\tconst events = this._events[key] as IEvents<Key> | undefined;\n\n\t\tif (events !== undefined) {\n\t\t\tevents.dispatching = true;\n\n\t\t\ttry {\n\t\t\t\tf(events);\n\n\t\t\t} finally {\n\t\t\t\tevents.dispatching = false;\n\n\t\t\t\tif (events.cleanup) {\n\t\t\t\t\tevents.cleanup = false;\n\n\t\t\t\t\t$array.keepIf(events.callbacks, (callback) => {\n\t\t\t\t\t\treturn !callback.disposed;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (events.callbacks.length === 0) {\n\t\t\t\t\t\tevents.disposer.dispose();\n\t\t\t\t\t\tdelete this._events[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_dispatchEventAll<Key extends keyof IRendererEvents>(key: Key, event: IRendererEvents[Key]): void {\n\t\tif (!this.interactionsEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._withEvents(key, (events) => {\n\t\t\t$array.each(events.callbacks, (callback) => {\n\t\t\t\tif (!callback.disposed) {\n\t\t\t\t\tcallback.callback.call(callback.context, event);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t_dispatchEvent<Key extends keyof IRendererEvents>(key: Key, target: CanvasDisplayObject, event: IRendererEvents[Key]): boolean {\n\t\tif (!this.interactionsEnabled) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet dispatched = false;\n\n\t\tthis._withEvents(key, (events) => {\n\t\t\t$array.each(events.callbacks, (callback) => {\n\t\t\t\tif (!callback.disposed && callback.object === target) {\n\t\t\t\t\tcallback.callback.call(callback.context, event);\n\t\t\t\t\tdispatched = true;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn dispatched;\n\t}\n\n\t_dispatchMousedown(originalEvent: IPointerEvent, originalTarget: Node | null): void {\n\t\tconst button = (<PointerEvent>originalEvent).button;\n\t\tif (button != 0 && button != 2 && button != 1 && button !== undefined) {\n\t\t\t// Ignore non-primary mouse buttons\n\t\t\treturn;\n\t\t}\n\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\n\t\tif (target) {\n\t\t\tconst id = event.id;\n\n\t\t\tlet dragged = false;\n\n\t\t\teachTargets(target, (obj) => {\n\t\t\t\tconst info = { id: id, value: obj };\n\n\t\t\t\tthis._mousedown.push(info);\n\n\t\t\t\tif (!dragged && this._dispatchEvent(\"pointerdown\", obj, event)) {\n\t\t\t\t\t// Only dispatch the first element which matches\n\t\t\t\t\tdragged = true;\n\n\t\t\t\t\tconst has = this._dragging.some((x) => {\n\t\t\t\t\t\treturn x.value === obj && x.id === id;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!has) {\n\t\t\t\t\t\tthis._dragging.push(info);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\t_dispatchGlobalMousemove(originalEvent: IPointerEvent, originalTarget: Node | null, native: boolean): void {\n\t\tconst event = this.getEvent(originalEvent);\n\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\t\tevent.native = native;\n\n\t\tif (target) {\n\t\t\tthis._hovering.forEach((obj) => {\n\t\t\t\tif (!obj.contains(target)) {\n\t\t\t\t\tthis._hovering.delete(obj);\n\t\t\t\t\tif (obj.cursorOverStyle) {\n\t\t\t\t\t\t$utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle!);\n\t\t\t\t\t}\n\t\t\t\t\tthis._dispatchEvent(\"pointerout\", obj, event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (event.native) {\n\t\t\t\teachTargets(target, (obj) => {\n\t\t\t\t\tif (!this._hovering.has(obj)) {\n\t\t\t\t\t\tthis._hovering.add(obj);\n\t\t\t\t\t\tif (obj.cursorOverStyle) {\n\t\t\t\t\t\t\tobj._replacedCursorStyle = $utils.getStyle(document.body, \"cursor\");\n\t\t\t\t\t\t\t$utils.setStyle(document.body, \"cursor\", obj.cursorOverStyle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._dispatchEvent(\"pointerover\", obj, event);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t//} else if (target === false) {\n\t\t} else {\n\t\t\tthis._hovering.forEach((obj) => {\n\t\t\t\tif (obj.cursorOverStyle) {\n\t\t\t\t\t$utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle!);\n\t\t\t\t}\n\t\t\t\tthis._dispatchEvent(\"pointerout\", obj, event);\n\t\t\t});\n\n\t\t\tthis._hovering.clear();\n\t\t}\n\t\tthis._dispatchEventAll(\"globalpointermove\", event);\n\t}\n\n\tremoveHovering(graphics: CanvasGraphics) {\n\t\tthis._hovering.delete(graphics);\n\t\tif (graphics.cursorOverStyle) {\n\t\t\t$utils.setStyle(document.body, \"cursor\", graphics._replacedCursorStyle!);\n\t\t}\n\t}\n\n\t_dispatchGlobalMouseup(originalEvent: IPointerEvent, native: boolean): void {\n\t\tconst event = this.getEvent(originalEvent);\n\t\tevent.native = native;\n\t\t//const target = this._getHitTarget(event.originalPoint);\n\t\tthis._dispatchEventAll(\"globalpointerup\", event);\n\t}\n\n\t_dispatchDragMove(originalEvent: IPointerEvent): void {\n\t\tif (this._dragging.length !== 0) {\n\t\t\tconst event = this.getEvent(originalEvent);\n\t\t\tconst id = event.id;\n\n\t\t\tthis._dragging.forEach((obj) => {\n\t\t\t\tif (obj.id === id) {\n\t\t\t\t\tthis._dispatchEvent(\"pointermove\", obj.value, event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t_dispatchDragEnd(originalEvent: IPointerEvent, originalTarget: Node | null): void {\n\t\tconst button = (<PointerEvent>originalEvent).button;\n\t\tlet clickevent: \"click\" | \"rightclick\" | \"middleclick\";\n\t\tif (button == 0 || button === undefined) {\n\t\t\tclickevent = \"click\";\n\t\t}\n\t\telse if (button == 2) {\n\t\t\tclickevent = \"rightclick\";\n\t\t}\n\t\telse if (button == 1) {\n\t\t\tclickevent = \"middleclick\";\n\t\t}\n\t\telse {\n\t\t\t// Ignore non-primary mouse buttons\n\t\t\treturn;\n\t\t}\n\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst id = event.id;\n\n\t\tif (this._mousedown.length !== 0) {\n\t\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\t\t\tif (target) {\n\t\t\t\tthis._mousedown.forEach((obj) => {\n\t\t\t\t\tif (obj.id === id && obj.value.contains(target)) {\n\t\t\t\t\t\tthis._dispatchEvent(clickevent, obj.value, event);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mousedown.length = 0;\n\t\t}\n\n\t\tif (this._dragging.length !== 0) {\n\t\t\tthis._dragging.forEach((obj) => {\n\t\t\t\tif (obj.id === id) {\n\t\t\t\t\tthis._dispatchEvent(\"pointerup\", obj.value, event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._dragging.length = 0;\n\t\t}\n\t}\n\n\t_dispatchDoubleClick(originalEvent: IPointerEvent, originalTarget: Node | null): void {\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\t\tif (target) {\n\t\t\teachTargets(target, (obj) => {\n\t\t\t\tif (this._dispatchEvent(\"dblclick\", obj, event)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t_dispatchWheel(originalEvent: WheelEvent, originalTarget: Node | null): void {\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\t\tif (target) {\n\t\t\teachTargets(target, (obj) => {\n\t\t\t\tif (this._dispatchEvent(\"wheel\", obj, event)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t_makeSharedEvent(key: string, f: () => IDisposer): IDisposer {\n\t\tif (this._listeners[key] === undefined) {\n\t\t\tconst listener = f();\n\n\t\t\tthis._listeners[key] = new CounterDisposer(() => {\n\t\t\t\tdelete this._listeners[key];\n\t\t\t\tlistener.dispose();\n\t\t\t});\n\t\t}\n\n\t\treturn this._listeners[key].increment();\n\t}\n\n\t_onPointerEvent(name: string, f: (event: Array<IPointerEvent>, target: Node | null, native: boolean) => void): IDisposer {\n\t\tlet native = false;\n\t\tlet timer: number | null = null;\n\n\t\tfunction clear() {\n\t\t\ttimer = null;\n\t\t\tnative = false;\n\t\t}\n\n\t\treturn new MultiDisposer([\n\t\t\tnew Disposer(() => {\n\t\t\t\tif (timer !== null) {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t}\n\n\t\t\t\tclear();\n\t\t\t}),\n\n\t\t\t$utils.addEventListener(this.view, $utils.getRendererEvent(name), (_) => {\n\t\t\t\tnative = true;\n\n\t\t\t\tif (timer !== null) {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t}\n\n\t\t\t\ttimer = window.setTimeout(clear, 0);\n\t\t\t}),\n\n\t\t\tonPointerEvent(window, name, (ev, target) => {\n\t\t\t\tif (timer !== null) {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\n\t\t\t\tf(ev, target, native);\n\n\t\t\t\tnative = false;\n\t\t\t}),\n\t\t]);\n\t}\n\n\t// This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)\n\t_initEvent(key: keyof IRendererEvents): IDisposer | undefined {\n\t\tswitch (key) {\n\t\t\tcase \"globalpointermove\":\n\t\t\tcase \"pointerover\":\n\t\t\tcase \"pointerout\":\n\t\t\t\treturn this._makeSharedEvent(\"pointermove\", () => {\n\t\t\t\t\tconst listener = (events: Array<IPointerEvent>, target: Node | null, native: boolean) => {\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { events, target, native };\n\n\t\t\t\t\t\t$array.each(events, (event) => {\n\t\t\t\t\t\t\tthis._dispatchGlobalMousemove(event, target, native);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\treturn new MultiDisposer([\n\t\t\t\t\t\tthis._onPointerEvent(\"pointerdown\", listener),\n\t\t\t\t\t\tthis._onPointerEvent(\"pointermove\", listener),\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\tcase \"globalpointerup\":\n\t\t\t\treturn this._makeSharedEvent(\"pointerup\", () => {\n\t\t\t\t\tconst mouseup = this._onPointerEvent(\"pointerup\", (events, target, native) => {\n\t\t\t\t\t\t$array.each(events, (event) => {\n\t\t\t\t\t\t\tthis._dispatchGlobalMouseup(event, native);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { events, target, native };\n\t\t\t\t\t});\n\n\t\t\t\t\tconst pointercancel = this._onPointerEvent(\"pointercancel\", (events, target, native) => {\n\t\t\t\t\t\t$array.each(events, (event) => {\n\t\t\t\t\t\t\tthis._dispatchGlobalMouseup(event, native);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { events, target, native };\n\t\t\t\t\t});\n\n\t\t\t\t\treturn new Disposer(() => {\n\t\t\t\t\t\tmouseup.dispose();\n\t\t\t\t\t\tpointercancel.dispose();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tcase \"click\":\n\t\t\tcase \"rightclick\":\n\t\t\tcase \"middleclick\":\n\t\t\tcase \"pointerdown\":\n\t\t\t/*\n\t\t\t\treturn this._makeSharedEvent(\"pointerdown\", () => {\n\t\t\t\t\treturn this._onPointerEvent(\"pointerdown\", (event, target, native) => {\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { event, target, native };\n\t\t\t\t\t\tthis._dispatchMousedown(event)\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t*/\n\t\t\tcase \"pointermove\":\n\t\t\tcase \"pointerup\":\n\t\t\t\treturn this._makeSharedEvent(\"pointerdown\", () => {\n\t\t\t\t\t//const throttler = new Throttler();\n\n\t\t\t\t\tconst mousedown = this._onPointerEvent(\"pointerdown\", (events, target) => {\n\t\t\t\t\t\t$array.each(events, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchMousedown(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// TODO handle throttling properly for multitouch\n\t\t\t\t\tconst mousemove = this._onPointerEvent(\"pointermove\", (ev: Array<IPointerEvent>) => {\n\t\t\t\t\t\t//throttler.throttle(() => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDragMove(ev);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t//});\n\t\t\t\t\t});\n\n\t\t\t\t\tconst mouseup = this._onPointerEvent(\"pointerup\", (ev: Array<IPointerEvent>, target) => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDragEnd(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tconst pointercancel = this._onPointerEvent(\"pointercancel\", (ev: Array<IPointerEvent>, target) => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDragEnd(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\treturn new Disposer(() => {\n\t\t\t\t\t\tmousedown.dispose();\n\t\t\t\t\t\tmousemove.dispose();\n\t\t\t\t\t\tmouseup.dispose();\n\t\t\t\t\t\tpointercancel.dispose();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tcase \"dblclick\":\n\t\t\t\treturn this._makeSharedEvent(\"dblclick\", () => {\n\t\t\t\t\treturn this._onPointerEvent(\"dblclick\", (ev, target) => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDoubleClick(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tcase \"wheel\":\n\t\t\t\treturn this._makeSharedEvent(\"wheel\", () => {\n\t\t\t\t\treturn $utils.addEventListener(this.view, $utils.getRendererEvent(\"wheel\"), (event: WheelEvent) => {\n\t\t\t\t\t\tthis._dispatchWheel(event, $utils.getEventTarget(event));\n\t\t\t\t\t}, { passive: false });\n\t\t\t\t});\n\t\t}\n\t}\n\n\t_addEvent<C, Key extends keyof IRendererEvents>(object: CanvasDisplayObject, key: Key, callback: (this: C, event: IRendererEvents[Key]) => void, context?: C): IDisposer {\n\t\tlet events: IEvents<Key> | undefined = this._events[key] as any;\n\n\t\tif (events === undefined) {\n\t\t\tevents = this._events[key] = {\n\t\t\t\tdisposer: this._initEvent(key)!,\n\t\t\t\tcallbacks: [],\n\t\t\t\tdispatching: false,\n\t\t\t\tcleanup: false,\n\t\t\t};\n\t\t}\n\n\t\tconst listener = { object, context, callback, disposed: false };\n\n\t\tevents!.callbacks.push(listener);\n\n\t\treturn new Disposer(() => {\n\t\t\tlistener.disposed = true;\n\n\t\t\tif (events!.dispatching) {\n\t\t\t\tevents!.cleanup = true;\n\n\t\t\t} else {\n\t\t\t\t$array.removeFirst(events!.callbacks, listener);\n\n\t\t\t\tif (events!.callbacks.length === 0) {\n\t\t\t\t\tevents!.disposer.dispose();\n\t\t\t\t\tdelete this._events[key];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getCanvas(root: CanvasDisplayObject, options?: ICanvasOptions): HTMLCanvasElement {\n\n\t\t// Make sure everything is rendered\n\t\tthis.render(root);\n\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\n\t\tlet scale: number = this.resolution;\n\n\t\tlet canvasWidth = Math.floor(this._calculatedWidth * this.resolution);\n\t\tlet canvasHeight = Math.floor(this._calculatedHeight * this.resolution);\n\n\t\t// Check if we need to scale\n\t\tif (options.minWidth && (options.minWidth > canvasWidth)) {\n\t\t\tlet minScale = options.minWidth / canvasWidth;\n\t\t\tif (minScale > scale) {\n\t\t\t\tscale = minScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\tif (options.minHeight && (options.minHeight > canvasHeight)) {\n\t\t\tlet minScale = options.minHeight / canvasHeight;\n\t\t\tif (minScale > scale) {\n\t\t\t\tscale = minScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\tif (options.maxWidth && (options.maxWidth < canvasWidth)) {\n\t\t\tlet maxScale = options.maxWidth / canvasWidth;\n\t\t\tif (maxScale < scale) {\n\t\t\t\tscale = maxScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\tif (options.maxHeight && (options.maxHeight > canvasHeight)) {\n\t\t\tlet maxScale = options.maxHeight / canvasHeight;\n\t\t\tif (maxScale < scale) {\n\t\t\t\tscale = maxScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\t// Check if we need to compensate for pixel ratio\n\t\tif (options.maintainPixelRatio) {\n\t\t\tscale /= this.resolution;\n\t\t}\n\n\t\t// Init list canvases to remove from DOM after export\n\t\tconst canvases: HTMLCanvasElement[] = [];\n\n\t\t// Set up new canvas for export\n\t\tlet forceRender = false;\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tif (scale != this.resolution) {\n\t\t\tforceRender = true;\n\t\t\tcanvasWidth = canvasWidth * scale / this.resolution;\n\t\t\tcanvasHeight = canvasHeight * scale / this.resolution;\n\t\t}\n\n\t\tcanvas.width = canvasWidth;\n\t\tcanvas.height = canvasHeight;\n\n\t\t// Add to DOM so it inherits CSS\n\t\tcanvas.style.position = \"fixed\";\n\t\tcanvas.style.top = \"-10000px\";\n\t\tthis.view.appendChild(canvas);\n\t\tcanvases.push(canvas);\n\n\t\t// Context\n\t\tconst context = canvas.getContext(\"2d\")!;\n\n\t\tlet width = 0;\n\t\tlet height = 0;\n\t\tlet needRerender = false;\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer && layer.visible) {\n\t\t\t\tif (layer.tainted || forceRender) {\n\t\t\t\t\tneedRerender = true;\n\n\t\t\t\t\tlayer.exportableView = layer.view;\n\t\t\t\t\tlayer.exportableContext = layer.context;\n\n\t\t\t\t\tlayer.view = document.createElement(\"canvas\");\n\n\t\t\t\t\t// Add to DOM so it inherits CSS\n\t\t\t\t\tlayer.view.style.position = \"fixed\";\n\t\t\t\t\tlayer.view.style.top = \"-10000px\";\n\t\t\t\t\tthis.view.appendChild(layer.view);\n\t\t\t\t\tcanvases.push(layer.view);\n\n\t\t\t\t\tlet extraX = 0;\n\t\t\t\t\tlet extraY = 0;\n\t\t\t\t\tif (layer.margin) {\n\t\t\t\t\t\textraX += layer.margin.left || 0 + layer.margin.right || 0;\n\t\t\t\t\t\textraY += layer.margin.top || 0 + layer.margin.bottom || 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer.view.width = canvasWidth + extraX;\n\t\t\t\t\tlayer.view.height = canvasHeight + extraY;\n\n\t\t\t\t\tlayer.context = layer.view.getContext(\"2d\")!;\n\n\t\t\t\t\tlayer.dirty = true;\n\t\t\t\t\tlayer.scale = scale;\n\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (needRerender) {\n\t\t\tthis._omitTainted = true;\n\t\t\tthis.render(root);\n\t\t\tthis._omitTainted = false;\n\t\t}\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer && layer.visible) {\n\n\t\t\t\t// Layer is fine. Just plop it into our target canvas\n\t\t\t\tlet x = 0;\n\t\t\t\tlet y = 0;\n\t\t\t\tif (layer.margin) {\n\t\t\t\t\tx = -(layer.margin.left || 0) * this.resolution;\n\t\t\t\t\ty = -(layer.margin.top || 0) * this.resolution;\n\t\t\t\t}\n\t\t\t\tcontext.drawImage(layer.view, x, y);\n\n\t\t\t\t// Restore layer original canvas\n\t\t\t\tif (layer.exportableView) {\n\t\t\t\t\tlayer.view = layer.exportableView;\n\t\t\t\t\tlayer.exportableView = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (layer.exportableContext) {\n\t\t\t\t\tlayer.context = layer.exportableContext;\n\t\t\t\t\tlayer.exportableContext = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (width < layer.view.clientWidth) {\n\t\t\t\t\twidth = layer.view.clientWidth;\n\t\t\t\t}\n\t\t\t\tif (height < layer.view.clientHeight) {\n\t\t\t\t\theight = layer.view.clientHeight;\n\t\t\t\t}\n\n\t\t\t\tlayer.scale = undefined;\n\t\t\t}\n\t\t});\n\n\t\tcanvas.style.width = width + \"px\";\n\t\tcanvas.style.height = height + \"px\";\n\n\t\t$array.each(canvases, (canvas) => {\n\t\t\tcanvas.style.position = \"\";\n\t\t\tcanvas.style.top = \"\";\n\t\t\tthis.view.removeChild(canvas);\n\t\t})\n\t\treturn canvas;\n\t}\n}\n\n\nclass GhostLayer {\n\tpublic view: HTMLCanvasElement;\n\tpublic context: CanvasRenderingContext2D;\n\tpublic margin: IMargin = {\n\t\tleft: 0,\n\t\tright: 0,\n\t\ttop: 0,\n\t\tbottom: 0,\n\t};\n\n\tprivate _resolution: number = 1;\n\tprivate _width: number = 0;\n\tprivate _height: number = 0;\n\n\tpublic imageArray?: Uint8ClampedArray;\n\n\tconstructor() {\n\t\tthis.view = document.createElement(\"canvas\");\n\t\tthis.context = this.view.getContext(\"2d\", { alpha: false, willReadFrequently: true })! as CanvasRenderingContext2D;\n\t\tthis.context.imageSmoothingEnabled = false;\n\n\t\tthis.view.style.position = \"absolute\";\n\t\tthis.view.style.top = \"0px\";\n\t\tthis.view.style.left = \"0px\";\n\t}\n\n\tresize(canvasWidth: number, canvasHeight: number, domWidth: number, domHeight: number, resolution: number) {\n\t\tthis._resolution = resolution;\n\n\t\tcanvasWidth += (this.margin.left + this.margin.right);\n\t\tcanvasHeight += (this.margin.top + this.margin.bottom);\n\n\t\t// TODO this should take into account calculateSize\n\t\tdomWidth += (this.margin.left + this.margin.right);\n\t\tdomHeight += (this.margin.top + this.margin.bottom);\n\n\t\tthis.view.style.left = -this.margin.left + \"px\";\n\t\tthis.view.style.top = -this.margin.top + \"px\";\n\n\t\tthis._width = Math.floor(canvasWidth * resolution);\n\t\tthis._height = Math.floor(canvasHeight * resolution);\n\n\t\tthis.view.width = this._width;\n\t\tthis.view.style.width = domWidth + \"px\";\n\n\t\tthis.view.height = this._height;\n\t\tthis.view.style.height = domHeight + \"px\";\n\t}\n\n\tgetImageData(point: IPoint, bbox: DOMRect): ImageData {\n\t\treturn this.context.getImageData(\n\t\t\t// TODO should this round ?\n\t\t\tMath.round(((point.x - bbox.left) / bbox.width) * this._width),\n\t\t\tMath.round(((point.y - bbox.top) / bbox.height) * this._height),\n\t\t\t1,\n\t\t\t1,\n\t\t);\n\t}\n\n\tgetImageArray(point: IPoint): Array<number> {\n\n\t\tif (!this.imageArray) {\n\t\t\tthis.imageArray = this.context.getImageData(0, 0, this._width, this._height).data;\n\t\t}\n\n\t\tconst data = this.imageArray;\n\n\t\tconst x = Math.round(point.x * this._resolution);\n\t\tconst y = Math.round(point.y * this._resolution);\n\n\t\tconst i = (y * this._width + x) * 4;\n\t\treturn [data[i], data[i + 1], data[i + 2], data[i + 3]];\n\t}\n\n\tsetMargin(layers: Array<CanvasLayer>): void {\n\t\tthis.margin.left = 0;\n\t\tthis.margin.right = 0;\n\t\tthis.margin.top = 0;\n\t\tthis.margin.bottom = 0;\n\n\t\t$array.each(layers, (layer) => {\n\t\t\tif (layer.margin) {\n\t\t\t\tthis.margin.left = Math.max(this.margin.left, layer.margin.left);\n\t\t\t\tthis.margin.right = Math.max(this.margin.right, layer.margin.right);\n\t\t\t\tthis.margin.top = Math.max(this.margin.top, layer.margin.top);\n\t\t\t\tthis.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);\n\t\t\t}\n\t\t});\n\t}\n\n\tclear() {\n\t\tthis.context.save();\n\t\tthis.context.fillStyle = '#000';\n\t\tthis.context.fillRect(0, 0, this._width, this._height);\n\t}\n}\n\n\n/**\n * @ignore\n */\nexport class CanvasLayer implements ILayer {\n\tpublic view: HTMLCanvasElement;\n\tpublic context: CanvasRenderingContext2D;\n\tpublic tainted: boolean = true;\n\tpublic margin: IMargin | undefined;\n\tpublic order: number = 0;\n\tpublic visible: boolean = true;\n\tpublic width: number | undefined;\n\tpublic height: number | undefined;\n\tpublic scale: number | undefined;\n\tpublic dirty: boolean = true;\n\tpublic exportableView: HTMLCanvasElement | undefined;\n\tpublic exportableContext: CanvasRenderingContext2D | undefined;\n\n\tprivate _width: number = 0;\n\tprivate _height: number = 0;\n\n\tconstructor(view: HTMLCanvasElement, context: CanvasRenderingContext2D) {\n\t\tthis.view = view;\n\t\tthis.context = context;\n\t}\n\n\tresize(canvasWidth: number, canvasHeight: number, domWidth: number, domHeight: number, resolution: number) {\n\t\t// TODO should this take into account calculateSize ?\n\t\tif (this.width != null) {\n\t\t\tcanvasWidth = this.width;\n\t\t\tdomWidth = this.width;\n\t\t}\n\n\t\t// TODO should this take into account calculateSize ?\n\t\tif (this.height != null) {\n\t\t\tcanvasHeight = this.height;\n\t\t\tdomHeight = this.height;\n\t\t}\n\n\t\tif (this.margin) {\n\t\t\tcanvasWidth += (this.margin.left + this.margin.right);\n\t\t\tcanvasHeight += (this.margin.top + this.margin.bottom);\n\n\t\t\t// TODO this should take into account calculateSize\n\t\t\tdomWidth += (this.margin.left + this.margin.right);\n\t\t\tdomHeight += (this.margin.top + this.margin.bottom);\n\n\t\t\tthis.view.style.left = -this.margin.left + \"px\";\n\t\t\tthis.view.style.top = -this.margin.top + \"px\";\n\n\t\t} else {\n\t\t\tthis.view.style.left = \"0px\";\n\t\t\tthis.view.style.top = \"0px\";\n\t\t}\n\n\t\tthis._width = Math.floor(canvasWidth * resolution);\n\t\tthis._height = Math.floor(canvasHeight * resolution);\n\n\t\tthis.view.width = this._width;\n\t\tthis.view.style.width = domWidth + \"px\";\n\n\t\tthis.view.height = this._height;\n\t\tthis.view.style.height = domHeight + \"px\";\n\t}\n\n\tclear() {\n\t\tthis.context.save();\n\t\tthis.context.clearRect(0, 0, this._width, this._height);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}