{"ast":null,"code":"import { DataItem } from \"../../../core/render/Component\";\nimport { Axis } from \"./Axis\";\nimport { MultiDisposer } from \"../../../core/util/Disposer\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Creates a value axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info\r\n * @important\r\n */\nexport class ValueAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_dirtyExtremes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_dirtySelectionExtremes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_dseHandled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_deltaMinMax\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"_minReal\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_maxReal\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_minRealLog\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_baseValue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_syncDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_minLogAdjusted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtyExtremes() {\n    this._dirtyExtremes = true;\n    this.markDirty();\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtySelectionExtremes() {\n    this._dirtySelectionExtremes = true;\n    this.markDirty();\n  }\n  _afterNew() {\n    this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n    this.setPrivateRaw(\"name\", \"value\");\n    this.addTag(\"value\");\n    super._afterNew();\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    if (this.isDirty(\"syncWithAxis\")) {\n      let previousValue = this._prevSettings.syncWithAxis;\n      if (previousValue) {\n        if (this._syncDp) {\n          this._syncDp.dispose();\n        }\n      }\n      let syncWithAxis = this.get(\"syncWithAxis\");\n      if (syncWithAxis) {\n        this._syncDp = new MultiDisposer([syncWithAxis.onPrivate(\"selectionMinFinal\", () => {\n          this._dirtySelectionExtremes = true;\n        }), syncWithAxis.onPrivate(\"selectionMaxFinal\", () => {\n          this._dirtySelectionExtremes = true;\n        })]);\n      }\n    }\n    let someDirty = false;\n    if (this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"maxPrecision\") || this.isDirty(\"numberFormat\")) {\n      someDirty = true;\n      this.ghostLabel.set(\"text\", \"\");\n    }\n    //if (this._dirtyExtremes || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"maxPrecision\")) {\n    if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || someDirty || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"strictMinMaxSelection\")) {\n      this._getMinMax();\n      this._dirtyExtremes = false;\n    }\n    this._handleSizeDirty();\n    if (this._dirtySelectionExtremes && !this._isPanning && this.get(\"autoZoom\", true)) {\n      const chart = this.chart;\n      let getMM = false;\n      // #1563\n      if (chart) {\n        const letter = this.get(\"renderer\").getPrivate(\"letter\");\n        if (letter == \"Y\") {\n          chart.xAxes.each(axis => {\n            if (axis.className != \"ValueAxis\") {\n              getMM = true;\n            }\n          });\n        } else if (letter == \"X\") {\n          chart.yAxes.each(axis => {\n            if (axis.className != \"ValueAxis\") {\n              getMM = true;\n            }\n          });\n        }\n      }\n      if (getMM) {\n        this._getSelectionMinMax();\n      }\n      this._dirtySelectionExtremes = false;\n    }\n    this._groupData();\n    if (this._sizeDirty || this._valuesDirty || this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"min\") || this.isPrivateDirty(\"selectionMax\") || this.isPrivateDirty(\"selectionMin\") || this.isPrivateDirty(\"max\") || this.isPrivateDirty(\"step\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"logarithmic\")) {\n      this._handleRangeChange();\n      this._prepareAxisItems();\n      this._updateAxisRanges();\n    }\n    this._baseValue = this.baseValue();\n  }\n  _handleSizeDirty() {\n    if (this._sizeDirty && !this._dseHandled) {\n      this._dirtySelectionExtremes = true;\n      this._dseHandled = true;\n    }\n  }\n  _clearDirty() {\n    super._clearDirty();\n    this._dseHandled = false;\n  }\n  _groupData() {}\n  _formatText(value) {\n    const numberFormat = this.get(\"numberFormat\");\n    const formatter = this.getNumberFormatter();\n    let text = \"\";\n    if (numberFormat) {\n      text = formatter.format(value, numberFormat);\n    } else {\n      text = formatter.format(value, undefined, this.getPrivate(\"stepDecimalPlaces\"));\n    }\n    return text;\n  }\n  _prepareAxisItems() {\n    const min = this.getPrivate(\"min\");\n    const max = this.getPrivate(\"max\");\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      const logarithmic = this.get(\"logarithmic\");\n      const step = this.getPrivate(\"step\");\n      const selectionMin = this.getPrivate(\"selectionMin\");\n      const selectionMax = this.getPrivate(\"selectionMax\") + step;\n      let value = selectionMin - step;\n      let differencePower = 1;\n      let minLog = min;\n      if (logarithmic) {\n        value = this._minLogAdjusted;\n        if (value < selectionMin) {\n          while (value < selectionMin) {\n            value += step;\n          }\n        }\n        minLog = value;\n        if (minLog <= 0) {\n          minLog = 1;\n          if (step < 1) {\n            if ($type.isNumber(this._minRealLog)) {\n              minLog = this._minRealLog;\n            } else {\n              minLog = Math.pow(10, -50);\n            }\n          }\n        }\n        differencePower = Math.log(selectionMax - step) * Math.LOG10E - Math.log(minLog) * Math.LOG10E;\n        if (differencePower > 2) {\n          value = Math.pow(10, Math.log(minLog) * Math.LOG10E - 50);\n        }\n      }\n      /// minor grid\n      const renderer = this.get(\"renderer\");\n      const minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\n      const minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\n      let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n      const stepAdjusted = Math.round(step / stepPower);\n      let minorGridCount = 2;\n      if ($math.round(stepAdjusted / 5, 10) % 1 == 0) {\n        minorGridCount = 5;\n      }\n      if ($math.round(stepAdjusted / 10, 10) % 1 == 0) {\n        minorGridCount = 10;\n      }\n      let minorStep = step / minorGridCount;\n      // end of minor grid\n      let i = 0;\n      let m = 0;\n      let previous = -Infinity;\n      while (value < selectionMax) {\n        let dataItem;\n        if (this.dataItems.length < i + 1) {\n          dataItem = new DataItem(this, undefined, {});\n          this._dataItems.push(dataItem);\n          this.processDataItem(dataItem);\n        } else {\n          dataItem = this.dataItems[i];\n        }\n        this._createAssets(dataItem, []);\n        this._toggleDataItem(dataItem, true);\n        dataItem.setRaw(\"value\", value);\n        const label = dataItem.get(\"label\");\n        if (label) {\n          label.set(\"text\", this._formatText(value));\n        }\n        this._prepareDataItem(dataItem);\n        let nextValue = value;\n        if (!logarithmic) {\n          nextValue += step;\n        } else {\n          if (differencePower > 2) {\n            nextValue = Math.pow(10, Math.log(minLog) * Math.LOG10E + i - 50);\n          } else {\n            nextValue += step;\n          }\n        }\n        // minor grid\n        if (minorGridEnabled) {\n          let minorValue = value + minorStep;\n          if (logarithmic) {\n            if (differencePower > 2) {\n              let minorMinMaxStep = this._adjustMinMax(value, nextValue, 10);\n              minorStep = minorMinMaxStep.step;\n            }\n            minorValue = value + minorStep;\n          }\n          while (minorValue < nextValue - step * 0.00000000001) {\n            let minorDataItem;\n            if (this.minorDataItems.length < m + 1) {\n              minorDataItem = new DataItem(this, undefined, {});\n              this.minorDataItems.push(minorDataItem);\n              this.processDataItem(minorDataItem);\n            } else {\n              minorDataItem = this.minorDataItems[m];\n            }\n            this._createAssets(minorDataItem, [\"minor\"], true);\n            this._toggleDataItem(minorDataItem, true);\n            minorDataItem.setRaw(\"value\", minorValue);\n            const minorLabel = minorDataItem.get(\"label\");\n            if (minorLabel) {\n              if (minorLabelsEnabled) {\n                minorLabel.set(\"text\", this._formatText(minorValue));\n              } else {\n                minorLabel.setPrivate(\"visible\", false);\n              }\n            }\n            this._prepareDataItem(minorDataItem);\n            minorValue += minorStep;\n            m++;\n          }\n        }\n        value = nextValue;\n        if (previous == value) {\n          break;\n        }\n        let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n        if (stepPower < 1 && !logarithmic) {\n          // exponent is less then 1 too. Count decimals of exponent\n          let decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;\n          // round value to avoid floating point issues\n          value = $math.round(value, decCount);\n        }\n        i++;\n        previous = value;\n      }\n      for (let j = i; j < this.dataItems.length; j++) {\n        this._toggleDataItem(this.dataItems[j], false);\n      }\n      for (let j = m; j < this.minorDataItems.length; j++) {\n        this._toggleDataItem(this.minorDataItems[j], false);\n      }\n      $array.each(this.series, series => {\n        if (series.inited) {\n          series._markDirtyAxes();\n        }\n      });\n      this._updateGhost();\n    }\n  }\n  _prepareDataItem(dataItem, count) {\n    let renderer = this.get(\"renderer\");\n    let value = dataItem.get(\"value\");\n    let endValue = dataItem.get(\"endValue\");\n    let position = this.valueToPosition(value);\n    let endPosition = position;\n    let fillEndPosition = this.valueToPosition(value + this.getPrivate(\"step\"));\n    if ($type.isNumber(endValue)) {\n      endPosition = this.valueToPosition(endValue);\n      fillEndPosition = endPosition;\n    }\n    if (dataItem.get(\"isRange\")) {\n      if (endValue == null) {\n        fillEndPosition = position;\n      }\n    }\n    let labelEndPosition = endPosition;\n    let labelEndValue = dataItem.get(\"labelEndValue\");\n    if (labelEndValue != null) {\n      labelEndPosition = this.valueToPosition(labelEndValue);\n    }\n    renderer.updateLabel(dataItem.get(\"label\"), position, labelEndPosition, count);\n    const grid = dataItem.get(\"grid\");\n    renderer.updateGrid(grid, position, endPosition);\n    if (grid) {\n      if (value == this.get(\"baseValue\", 0)) {\n        grid.addTag(\"base\");\n        grid._applyThemes();\n      } else if (grid.hasTag(\"base\")) {\n        grid.removeTag(\"base\");\n        grid._applyThemes();\n      }\n    }\n    renderer.updateTick(dataItem.get(\"tick\"), position, labelEndPosition, count);\n    renderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n    this._processBullet(dataItem);\n    renderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n    if (!dataItem.get(\"isRange\")) {\n      const fillRule = this.get(\"fillRule\");\n      if (fillRule) {\n        fillRule(dataItem);\n      }\n    }\n  }\n  _handleRangeChange() {\n    let selectionMin = this.positionToValue(this.get(\"start\", 0));\n    let selectionMax = this.positionToValue(this.get(\"end\", 1));\n    const gridCount = this.get(\"renderer\").gridCount();\n    let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n    let stepDecimalPlaces = $utils.decimalPlaces(minMaxStep.step);\n    this.setPrivateRaw(\"stepDecimalPlaces\", stepDecimalPlaces);\n    selectionMin = $math.round(selectionMin, stepDecimalPlaces);\n    selectionMax = $math.round(selectionMax, stepDecimalPlaces);\n    minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n    let step = minMaxStep.step;\n    selectionMin = minMaxStep.min;\n    selectionMax = minMaxStep.max;\n    if (this.getPrivate(\"selectionMin\") !== selectionMin || this.getPrivate(\"selectionMax\") !== selectionMax || this.getPrivate(\"step\") !== step) {\n      // do not change to setPrivate, will cause SO\n      this.setPrivateRaw(\"selectionMin\", selectionMin);\n      this.setPrivateRaw(\"selectionMax\", selectionMax);\n      this.setPrivateRaw(\"step\", step);\n    }\n  }\n  /**\r\n   * Converts a relative position to a corresponding numeric value from axis\r\n   * scale.\r\n   *\r\n   * @param   position  Relative position\r\n   * @return            Value\r\n   */\n  positionToValue(position) {\n    const min = this.getPrivate(\"min\");\n    const max = this.getPrivate(\"max\");\n    if (!this.get(\"logarithmic\")) {\n      return position * (max - min) + min;\n    } else {\n      return Math.pow(Math.E, (position * (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E) + Math.log(min) * Math.LOG10E) / Math.LOG10E);\n    }\n  }\n  /**\r\n   * Convers value to a relative position on axis.\r\n   *\r\n   * @param   value  Value\r\n   * @return         Relative position\r\n   */\n  valueToPosition(value) {\n    const min = this.getPrivate(\"min\");\n    const max = this.getPrivate(\"max\");\n    if (!this.get(\"logarithmic\")) {\n      return (value - min) / (max - min);\n    } else {\n      if (value <= 0) {\n        let treatZeroAs = this.get(\"treatZeroAs\");\n        if ($type.isNumber(treatZeroAs)) {\n          value = treatZeroAs;\n        }\n      }\n      return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  valueToFinalPosition(value) {\n    const min = this.getPrivate(\"minFinal\");\n    const max = this.getPrivate(\"maxFinal\");\n    if (!this.get(\"logarithmic\")) {\n      return (value - min) / (max - min);\n    } else {\n      if (value <= 0) {\n        let treatZeroAs = this.get(\"treatZeroAs\");\n        if ($type.isNumber(treatZeroAs)) {\n          value = treatZeroAs;\n        }\n      }\n      return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n    }\n  }\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n  getX(value, location, baseValue) {\n    value = baseValue + (value - baseValue) * location;\n    const position = this.valueToPosition(value);\n    return this._settings.renderer.positionToCoordinate(position);\n  }\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n  getY(value, location, baseValue) {\n    value = baseValue + (value - baseValue) * location;\n    const position = this.valueToPosition(value);\n    return this._settings.renderer.positionToCoordinate(position);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateX(dataItem, field, _cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionX(dataItem, field, _cellLocation, axisLocation) {\n    let value = dataItem.get(field);\n    const stackToItem = dataItem.get(\"stackToItemX\");\n    if (stackToItem) {\n      const series = dataItem.component;\n      value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);\n    } else {\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n    }\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateY(dataItem, field, _cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionY(dataItem, field, _cellLocation, axisLocation) {\n    let value = dataItem.get(field);\n    const stackToItem = dataItem.get(\"stackToItemY\");\n    if (stackToItem) {\n      const series = dataItem.component;\n      value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);\n    } else {\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n    }\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * Returns relative position of axis' `baseValue`.\r\n   *\r\n   * @return  Base value position\r\n   */\n  basePosition() {\n    return this.valueToPosition(this.baseValue());\n  }\n  /**\r\n   * Base value of the [[ValueAxis]], which determines positive and negative\r\n   * values.\r\n   *\r\n   * @return Base value\r\n   */\n  baseValue() {\n    const min = Math.min(this.getPrivate(\"minFinal\", -Infinity), this.getPrivate(\"selectionMin\", -Infinity));\n    const max = Math.max(this.getPrivate(\"maxFinal\", Infinity), this.getPrivate(\"selectionMax\", Infinity));\n    let baseValue = this.get(\"baseValue\", 0);\n    if (baseValue < min) {\n      baseValue = min;\n    }\n    if (baseValue > max) {\n      baseValue = max;\n    }\n    return baseValue;\n  }\n  /**\r\n   * @ignore\r\n   */\n  cellEndValue(value) {\n    return value;\n  }\n  fixSmallStep(step) {\n    // happens because of floating point error\n    if (1 + step === 1) {\n      step *= 2;\n      return this.fixSmallStep(step);\n    }\n    return step;\n  }\n  _fixMin(min) {\n    return min;\n  }\n  _fixMax(max) {\n    return max;\n  }\n  _calculateTotals() {\n    if (this.get(\"calculateTotals\")) {\n      let series = this.series[0];\n      if (series) {\n        let startIndex = series.startIndex();\n        if (series.dataItems.length > 0) {\n          if (startIndex > 0) {\n            startIndex--;\n          }\n          let endIndex = series.endIndex();\n          if (endIndex < series.dataItems.length) {\n            endIndex++;\n          }\n          let field;\n          let vc;\n          if (series.get(\"yAxis\") == this) {\n            field = \"valueY\";\n            vc = \"vcy\";\n          } else if (series.get(\"xAxis\") == this) {\n            field = \"valueX\";\n            vc = \"vcx\";\n          }\n          let fieldWorking = field + \"Working\";\n          if (field) {\n            for (let i = startIndex; i < endIndex; i++) {\n              let sum = 0;\n              let total = 0;\n              $array.each(this.series, series => {\n                if (!series.get(\"excludeFromTotal\")) {\n                  let dataItem = series.dataItems[i];\n                  if (dataItem) {\n                    let value = dataItem.get(fieldWorking) * series.get(vc);\n                    if (!$type.isNaN(value)) {\n                      sum += value;\n                      total += Math.abs(value);\n                    }\n                  }\n                }\n              });\n              $array.each(this.series, series => {\n                if (!series.get(\"excludeFromTotal\")) {\n                  let dataItem = series.dataItems[i];\n                  if (dataItem) {\n                    let value = dataItem.get(fieldWorking) * series.get(vc);\n                    if (!$type.isNaN(value)) {\n                      dataItem.set(field + \"Total\", total);\n                      dataItem.set(field + \"Sum\", sum);\n                      dataItem.set(field + \"TotalPercent\", value / total * 100);\n                    }\n                  }\n                }\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  _getSelectionMinMax() {\n    const min = this.getPrivate(\"minFinal\");\n    const max = this.getPrivate(\"maxFinal\");\n    const minDefined = this.get(\"min\");\n    const maxDefined = this.get(\"max\");\n    let extraMin = this.get(\"extraMin\", 0);\n    let extraMax = this.get(\"extraMax\", 0);\n    if (this.get(\"logarithmic\")) {\n      if (this.get(\"extraMin\") == null) {\n        extraMin = 0.1;\n      }\n      if (this.get(\"extraMax\") == null) {\n        extraMax = 0.2;\n      }\n    }\n    const gridCount = this.get(\"renderer\").gridCount();\n    const selectionStrictMinMax = this.get(\"strictMinMaxSelection\");\n    let strictMinMax = this.get(\"strictMinMax\");\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      let selectionMin = max;\n      let selectionMax = min;\n      $array.each(this.series, series => {\n        if (!series.get(\"ignoreMinMax\")) {\n          let seriesMin;\n          let seriesMax;\n          const outOfSelection = series.getPrivate(\"outOfSelection\");\n          if (series.get(\"xAxis\") === this) {\n            if (!outOfSelection) {\n              let minX = series.getPrivate(\"minX\");\n              let maxX = series.getPrivate(\"maxX\");\n              // solves #90085\n              if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {\n                minX = undefined;\n                maxX = undefined;\n              }\n              seriesMin = series.getPrivate(\"selectionMinX\", minX);\n              seriesMax = series.getPrivate(\"selectionMaxX\", maxX);\n            }\n          } else if (series.get(\"yAxis\") === this) {\n            if (!outOfSelection) {\n              let minY = series.getPrivate(\"minY\");\n              let maxY = series.getPrivate(\"maxY\");\n              // solves #90085\n              if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {\n                minY = undefined;\n                maxY = undefined;\n              }\n              seriesMin = series.getPrivate(\"selectionMinY\", minY);\n              seriesMax = series.getPrivate(\"selectionMaxY\", maxY);\n            }\n          }\n          if (!series.isHidden() && !series.isShowing()) {\n            if ($type.isNumber(seriesMin)) {\n              selectionMin = Math.min(selectionMin, seriesMin);\n            }\n            if ($type.isNumber(seriesMax)) {\n              selectionMax = Math.max(selectionMax, seriesMax);\n            }\n          }\n        }\n      });\n      this.axisRanges.each(range => {\n        if (range.get(\"affectsMinMax\")) {\n          let value = range.get(\"value\");\n          if (value != null) {\n            selectionMin = Math.min(selectionMin, value);\n            selectionMax = Math.max(selectionMax, value);\n          }\n          value = range.get(\"endValue\");\n          if (value != null) {\n            selectionMin = Math.min(selectionMin, value);\n            selectionMax = Math.max(selectionMax, value);\n          }\n        }\n      });\n      if (selectionMin > selectionMax) {\n        [selectionMin, selectionMax] = [selectionMax, selectionMin];\n      }\n      if ($type.isNumber(minDefined)) {\n        if (strictMinMax) {\n          selectionMin = minDefined;\n        } else {\n          selectionMin = min;\n        }\n      } else if (strictMinMax) {\n        if ($type.isNumber(this._minReal)) {\n          selectionMin = this._minReal;\n        }\n      }\n      if ($type.isNumber(maxDefined)) {\n        if (strictMinMax) {\n          selectionMax = maxDefined;\n        } else {\n          selectionMax = max;\n        }\n      } else if (strictMinMax) {\n        if ($type.isNumber(this._maxReal)) {\n          selectionMax = this._maxReal;\n        }\n      }\n      if (selectionMin === selectionMax) {\n        let smin = selectionMin;\n        selectionMin -= this._deltaMinMax;\n        selectionMax += this._deltaMinMax;\n        if (selectionMin < min) {\n          let d = smin - min;\n          if (d == 0) {\n            d = this._deltaMinMax;\n          }\n          selectionMin = smin - d;\n          selectionMax = smin + d;\n          strictMinMax = true;\n        }\n        let minMaxStep2 = this._adjustMinMax(selectionMin, selectionMax, gridCount, strictMinMax);\n        selectionMin = minMaxStep2.min;\n        selectionMax = minMaxStep2.max;\n      }\n      let selectionMinReal = selectionMin;\n      let selectionMaxReal = selectionMax;\n      let delta = selectionMax - selectionMin;\n      selectionMin -= delta * extraMin;\n      selectionMax += delta * extraMax;\n      let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount);\n      selectionMin = minMaxStep.min;\n      selectionMax = minMaxStep.max;\n      selectionMin = $math.fitToRange(selectionMin, min, max);\n      selectionMax = $math.fitToRange(selectionMax, min, max);\n      // do it for the second time !important\t\t\t\n      minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n      if (!strictMinMax) {\n        selectionMin = minMaxStep.min;\n        selectionMax = minMaxStep.max;\n      }\n      const syncWithAxis = this.get(\"syncWithAxis\");\n      if (syncWithAxis) {\n        minMaxStep = this._syncAxes(selectionMin, selectionMax, minMaxStep.step, syncWithAxis.getPrivate(\"selectionMinFinal\", syncWithAxis.getPrivate(\"minFinal\", 0)), syncWithAxis.getPrivate(\"selectionMaxFinal\", syncWithAxis.getPrivate(\"maxFinal\", 1)), syncWithAxis.getPrivate(\"selectionStepFinal\", syncWithAxis.getPrivate(\"step\", 1)));\n        if (minMaxStep.min < min) {\n          minMaxStep.min = min;\n        }\n        if (minMaxStep.max > max) {\n          minMaxStep.max = max;\n        }\n        selectionMin = minMaxStep.min;\n        selectionMax = minMaxStep.max;\n      }\n      if (strictMinMax) {\n        if ($type.isNumber(minDefined)) {\n          selectionMin = Math.max(selectionMin, minDefined);\n        }\n        if ($type.isNumber(maxDefined)) {\n          selectionMax = Math.min(selectionMax, maxDefined);\n        }\n      }\n      if (selectionStrictMinMax) {\n        selectionMin = selectionMinReal - (selectionMaxReal - selectionMinReal) * extraMin;\n        selectionMax = selectionMaxReal + (selectionMaxReal - selectionMinReal) * extraMax;\n      }\n      if (strictMinMax) {\n        if ($type.isNumber(minDefined)) {\n          selectionMin = minDefined;\n        } else {\n          selectionMin = selectionMinReal;\n        }\n        if ($type.isNumber(maxDefined)) {\n          selectionMax = maxDefined;\n        } else {\n          selectionMax = selectionMaxReal;\n        }\n        if (selectionMax - selectionMin <= 0.00000001) {\n          selectionMin -= this._deltaMinMax;\n          selectionMax += this._deltaMinMax;\n        }\n        let delta = selectionMax - selectionMin;\n        selectionMin -= delta * extraMin;\n        selectionMax += delta * extraMax;\n      }\n      if (this.get(\"logarithmic\")) {\n        if (selectionMin <= 0) {\n          selectionMin = selectionMinReal * (1 - Math.min(extraMin, 0.99));\n        }\n        if (selectionMin < min) {\n          selectionMin = min;\n        }\n        if (selectionMax > max) {\n          selectionMax = max;\n        }\n      }\n      let len = Math.min(20, Math.ceil(Math.log(this.getPrivate(\"maxZoomFactor\", 100) + 1) / Math.LN10) + 2);\n      let start = $math.round(this.valueToFinalPosition(selectionMin), len);\n      let end = $math.round(this.valueToFinalPosition(selectionMax), len);\n      this.setPrivateRaw(\"selectionMinFinal\", selectionMin);\n      this.setPrivateRaw(\"selectionMaxFinal\", selectionMax);\n      this.setPrivateRaw(\"selectionStepFinal\", minMaxStep.step);\n      this.zoom(start, end);\n    }\n  }\n  _getMinMax() {\n    let minDefined = this.get(\"min\");\n    let maxDefined = this.get(\"max\");\n    let min = Infinity;\n    let max = -Infinity;\n    let extraMin = this.get(\"extraMin\", 0);\n    let extraMax = this.get(\"extraMax\", 0);\n    if (this.get(\"logarithmic\")) {\n      if (this.get(\"extraMin\") == null) {\n        extraMin = 0.1;\n      }\n      if (this.get(\"extraMax\") == null) {\n        extraMax = 0.2;\n      }\n    }\n    let minDiff = Infinity;\n    $array.each(this.series, series => {\n      if (!series.get(\"ignoreMinMax\")) {\n        let seriesMin;\n        let seriesMax;\n        if (series.get(\"xAxis\") === this) {\n          seriesMin = series.getPrivate(\"minX\");\n          seriesMax = series.getPrivate(\"maxX\");\n        } else if (series.get(\"yAxis\") === this) {\n          seriesMin = series.getPrivate(\"minY\");\n          seriesMax = series.getPrivate(\"maxY\");\n        }\n        if ($type.isNumber(seriesMin) && $type.isNumber(seriesMax)) {\n          min = Math.min(min, seriesMin);\n          max = Math.max(max, seriesMax);\n          let diff = seriesMax - seriesMin;\n          if (diff <= 0) {\n            diff = Math.abs(seriesMax / 100);\n          }\n          if (diff < minDiff) {\n            minDiff = diff;\n          }\n        }\n      }\n    });\n    this.axisRanges.each(range => {\n      if (range.get(\"affectsMinMax\")) {\n        let value = range.get(\"value\");\n        if (value != null) {\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n        value = range.get(\"endValue\");\n        if (value != null) {\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    });\n    if (this.get(\"logarithmic\")) {\n      let treatZeroAs = this.get(\"treatZeroAs\");\n      if ($type.isNumber(treatZeroAs)) {\n        if (min <= 0) {\n          min = treatZeroAs;\n        }\n      }\n      if (min <= 0) {\n        new Error(\"Logarithmic value axis can not have values <= 0.\");\n      }\n    }\n    if (min === 0 && max === 0) {\n      max = 0.9;\n      min = -0.9;\n    }\n    if ($type.isNumber(minDefined)) {\n      min = minDefined;\n    }\n    if ($type.isNumber(maxDefined)) {\n      max = maxDefined;\n    }\n    // meaning no min/max found on series/ranges and no min/max was defined\n    if (min === Infinity || max === -Infinity) {\n      this.setPrivate(\"minFinal\", undefined);\n      this.setPrivate(\"maxFinal\", undefined);\n      return;\n    }\n    if (min > max) {\n      [min, max] = [max, min];\n    }\n    const initialMin = min;\n    const initialMax = max;\n    // adapter\n    let minAdapted = this.adapters.fold(\"min\", min);\n    let maxAdapted = this.adapters.fold(\"max\", max);\n    this._minRealLog = min;\n    if ($type.isNumber(minAdapted)) {\n      min = minAdapted;\n    }\n    if ($type.isNumber(maxAdapted)) {\n      max = maxAdapted;\n    }\n    // DateAxis does some magic here\n    min = this._fixMin(min);\n    max = this._fixMax(max);\n    // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date\t\t\n    if (max - min <= 1 / Math.pow(10, 15)) {\n      if (max - min !== 0) {\n        this._deltaMinMax = (max - min) / 2;\n      } else {\n        this._getDelta(max);\n      }\n      min -= this._deltaMinMax;\n      max += this._deltaMinMax;\n    }\n    // add extras\n    min -= (max - min) * extraMin;\n    max += (max - min) * extraMax;\n    if (this.get(\"logarithmic\")) {\n      // don't let min go below 0 if real min is >= 0\n      if (min < 0 && initialMin >= 0) {\n        min = 0;\n      }\n      // don't let max go above 0 if real max is <= 0\n      if (max > 0 && initialMax <= 0) {\n        max = 0;\n      }\n    }\n    this._minReal = min;\n    this._maxReal = max;\n    let strictMinMax = this.get(\"strictMinMax\");\n    let strictMinMaxSelection = this.get(\"strictMinMaxSelection\", false);\n    if (strictMinMaxSelection) {\n      strictMinMax = strictMinMaxSelection;\n    }\n    let strict = strictMinMax;\n    if ($type.isNumber(maxDefined)) {\n      strict = true;\n    }\n    let gridCount = this.get(\"renderer\").gridCount();\n    let minMaxStep = this._adjustMinMax(min, max, gridCount, strict);\n    min = minMaxStep.min;\n    max = minMaxStep.max;\n    // do it for the second time with strict true (importat!)\n    minMaxStep = this._adjustMinMax(min, max, gridCount, true);\n    min = minMaxStep.min;\n    max = minMaxStep.max;\n    // return min max if strict\n    if (strictMinMax) {\n      if ($type.isNumber(minDefined)) {\n        min = minDefined;\n      } else {\n        min = this._minReal;\n      }\n      if ($type.isNumber(maxDefined)) {\n        max = maxDefined;\n      } else {\n        max = this._maxReal;\n      }\n      if (max - min <= 0.00000001) {\n        min -= this._deltaMinMax;\n        max += this._deltaMinMax;\n      }\n      let delta = max - min;\n      min -= delta * extraMin;\n      max += delta * extraMax;\n    }\n    minAdapted = this.adapters.fold(\"min\", min);\n    maxAdapted = this.adapters.fold(\"max\", max);\n    if ($type.isNumber(minAdapted)) {\n      min = minAdapted;\n    }\n    if ($type.isNumber(maxAdapted)) {\n      max = maxAdapted;\n    }\n    if (minDiff == Infinity) {\n      minDiff = max - min;\n    }\n    // this is to avoid floating point number error\n    let decCount = Math.round(Math.abs(Math.log(Math.abs(max - min)) * Math.LOG10E)) + 5;\n    min = $math.round(min, decCount);\n    max = $math.round(max, decCount);\n    const syncWithAxis = this.get(\"syncWithAxis\");\n    if (syncWithAxis) {\n      minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate(\"minFinal\", syncWithAxis.getPrivate(\"min\", 0)), syncWithAxis.getPrivate(\"maxFinal\", syncWithAxis.getPrivate(\"max\", 1)), syncWithAxis.getPrivate(\"step\", 1));\n      min = minMaxStep.min;\n      max = minMaxStep.max;\n    }\n    this.setPrivateRaw(\"maxZoomFactor\", Math.max(1, Math.ceil((max - min) / minDiff * this.get(\"maxZoomFactor\", 100))));\n    this._fixZoomFactor();\n    if (this.get(\"logarithmic\")) {\n      this._minLogAdjusted = min;\n      min = this._minReal;\n      max = this._maxReal;\n      if (min <= 0) {\n        min = initialMin * (1 - Math.min(extraMin, 0.99));\n      }\n    }\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      if (this.getPrivate(\"minFinal\") !== min || this.getPrivate(\"maxFinal\") !== max) {\n        this.setPrivate(\"minFinal\", min);\n        this.setPrivate(\"maxFinal\", max);\n        this._saveMinMax(min, max);\n        const duration = this.get(\"interpolationDuration\", 0);\n        const easing = this.get(\"interpolationEasing\");\n        this.animatePrivate({\n          key: \"min\",\n          to: min,\n          duration,\n          easing\n        });\n        this.animatePrivate({\n          key: \"max\",\n          to: max,\n          duration,\n          easing\n        });\n      }\n    }\n  }\n  _fixZoomFactor() {}\n  _getDelta(max) {\n    // the number by which we need to raise 10 to get difference\n    let exponent = Math.log(Math.abs(max)) * Math.LOG10E;\n    // here we find a number which is power of 10 and has the same count of numbers as difference has\n    let power = Math.pow(10, Math.floor(exponent));\n    // reduce this number by 10 times\n    power = power / 10;\n    this._deltaMinMax = power;\n  }\n  _saveMinMax(_min, _max) {}\n  _adjustMinMax(min, max, gridCount, strictMode) {\n    // will fail if 0\n    if (gridCount <= 1) {\n      gridCount = 1;\n    }\n    gridCount = Math.round(gridCount);\n    let initialMin = min;\n    let initialMax = max;\n    let difference = max - min;\n    // in case min and max is the same, use max\n    if (difference === 0) {\n      difference = Math.abs(max);\n    }\n    // the number by which we need to raise 10 to get difference\n    let exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n    // here we find a number which is power of 10 and has the same count of numbers as difference has\n    let power = Math.pow(10, Math.floor(exponent));\n    // reduce this number by 10 times\n    power = power / 10;\n    let extra = power;\n    if (strictMode) {\n      extra = 0;\n    }\n    // round down min\n    if (strictMode) {\n      min = Math.floor(min / power) * power;\n      // round up max\n      max = Math.ceil(max / power) * power;\n    } else {\n      min = Math.ceil(min / power) * power - extra;\n      // round up max\n      max = Math.floor(max / power) * power + extra;\n    }\n    // don't let min go below 0 if real min is >= 0\n    if (min < 0 && initialMin >= 0) {\n      min = 0;\n    }\n    // don't let max go above 0 if real max is <= 0\n    if (max > 0 && initialMax <= 0) {\n      max = 0;\n    }\n    exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n    power = Math.pow(10, Math.floor(exponent));\n    power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance\n    // approximate difference between two grid lines\n    let step = Math.ceil(difference / gridCount / power) * power;\n    let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n    // the step should divide by  2, 5, and 10.\n    let stepDivisor = Math.ceil(step / stepPower); // number 0 - 10\n    if (stepDivisor > 5) {\n      stepDivisor = 10;\n    } else if (stepDivisor <= 5 && stepDivisor > 2) {\n      stepDivisor = 5;\n    }\n    // now get real step\n    step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;\n    let maxPrecision = this.get(\"maxPrecision\");\n    if ($type.isNumber(maxPrecision)) {\n      let ceiledStep = $math.ceil(step, maxPrecision);\n      if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {\n        step = ceiledStep;\n        if (step == 0) {\n          step = 1;\n        }\n      }\n    }\n    let decCount = 0;\n    // in case numbers are smaller than 1\n    if (stepPower < 1) {\n      // exponent is less then 1 too. Count decimals of exponent\n      decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;\n      // round step\n      step = $math.round(step, decCount);\n    }\n    // final min and max\n    let minCount = Math.floor(min / step);\n    min = $math.round(step * minCount, decCount);\n    let maxCount;\n    if (!strictMode) {\n      maxCount = Math.ceil(max / step);\n    } else {\n      maxCount = Math.floor(max / step);\n    }\n    if (maxCount === minCount) {\n      maxCount++;\n    }\n    max = $math.round(step * maxCount, decCount);\n    if (max < initialMax) {\n      max = max + step;\n    }\n    if (min > initialMin) {\n      min = min - step;\n    }\n    step = this.fixSmallStep(step);\n    return {\n      min: min,\n      max: max,\n      step: step\n    };\n  }\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  getTooltipText(position, _adjustPosition) {\n    const numberFormat = this.get(\"tooltipNumberFormat\", this.get(\"numberFormat\"));\n    const formatter = this.getNumberFormatter();\n    const extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n    const decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n    const value = $math.round(this.positionToValue(position), decimals);\n    if (numberFormat) {\n      return formatter.format(value, numberFormat);\n    } else {\n      return formatter.format(value, undefined, decimals);\n    }\n  }\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  getSeriesItem(series, position) {\n    let fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n    let value = this.positionToValue(position);\n    let index = undefined;\n    let oldDiff;\n    $array.each(series.dataItems, (dataItem, i) => {\n      const diff = Math.abs(dataItem.get(fieldName) - value);\n      if (index === undefined || diff < oldDiff) {\n        index = i;\n        oldDiff = diff;\n      }\n    });\n    if (index != null) {\n      return series.dataItems[index];\n    }\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` values.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start value\r\n   * @param  end       End value\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToValues(start, end, duration) {\n    const min = this.getPrivate(\"minFinal\", 0);\n    const max = this.getPrivate(\"maxFinal\", 0);\n    if (this.getPrivate(\"min\") != null && this.getPrivate(\"max\") != null) {\n      this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n    }\n  }\n  /**\r\n   * Syncs with a target axis.\r\n   *\r\n   * @param  min  Min\r\n   * @param  max  Max\r\n   * @param  step Step\r\n   */\n  _syncAxes(min, max, step, syncMin, syncMax, syncStep) {\n    let axis = this.get(\"syncWithAxis\");\n    if (axis) {\n      let count = Math.round(syncMax - syncMin) / syncStep;\n      let currentCount = Math.round((max - min) / step);\n      let gridCount = this.get(\"renderer\").gridCount();\n      if ($type.isNumber(count) && $type.isNumber(currentCount)) {\n        let synced = false;\n        let c = 0;\n        let diff = (max - min) * 0.01;\n        let omin = min;\n        let omax = max;\n        let ostep = step;\n        while (synced != true) {\n          synced = this._checkSync(omin, omax, ostep, count);\n          c++;\n          if (c > 500) {\n            synced = true;\n          }\n          if (!synced) {\n            if (c / 3 == Math.round(c / 3)) {\n              omin = min - diff * c;\n              if (min >= 0 && omin < 0) {\n                omin = 0;\n              }\n            } else {\n              omax = max + diff * c;\n              if (omax <= 0 && omax > 0) {\n                omax = 0;\n              }\n            }\n            let minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);\n            omin = minMaxStep.min;\n            omax = minMaxStep.max;\n            ostep = minMaxStep.step;\n          } else {\n            min = omin;\n            max = omax;\n            step = ostep;\n          }\n        }\n      }\n    }\n    return {\n      min: min,\n      max: max,\n      step: step\n    };\n  }\n  /**\r\n   * Returns `true` if axis needs to be resunced with some other axis.\r\n   */\n  _checkSync(min, max, step, count) {\n    let currentCount = (max - min) / step;\n    for (let i = 1; i < count; i++) {\n      if ($math.round(currentCount / i, 1) == count || currentCount * i == count) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\r\n   * Returns relative position between two grid lines of the axis.\r\n   *\r\n   * @return Position\r\n   */\n  getCellWidthPosition() {\n    let max = this.getPrivate(\"selectionMax\", this.getPrivate(\"max\"));\n    let min = this.getPrivate(\"selectionMin\", this.getPrivate(\"min\"));\n    if ($type.isNumber(max) && $type.isNumber(min)) {\n      return this.getPrivate(\"step\", 1) / (max - min);\n    }\n    return 0.05;\n  }\n  /**\r\n   * @ignore\r\n   */\n  nextPosition(count) {\n    if (count == null) {\n      count = 1;\n    }\n    if (this.get(\"renderer\").getPrivate(\"letter\") == \"Y\") {\n      count *= -1;\n    }\n    let value = this.positionToValue(this.getPrivate(\"tooltipPosition\", 0));\n    value += this.getPrivate(\"step\", 1) * count;\n    value = $math.fitToRange(value, this.getPrivate(\"selectionMin\", 0), this.getPrivate(\"selectionMax\", 1));\n    return this.toGlobalPosition(this.valueToPosition(value));\n  }\n}\nObject.defineProperty(ValueAxis, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"ValueAxis\"\n});\nObject.defineProperty(ValueAxis, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Axis.classNames.concat([ValueAxis.className])\n});","map":{"version":3,"names":["DataItem","Axis","MultiDisposer","$type","$array","$math","$utils","ValueAxis","constructor","Object","defineProperty","markDirtyExtremes","_dirtyExtremes","markDirty","markDirtySelectionExtremes","_dirtySelectionExtremes","_afterNew","_settings","themeTags","mergeTags","setPrivateRaw","addTag","_prepareChildren","isDirty","previousValue","_prevSettings","syncWithAxis","_syncDp","dispose","get","onPrivate","someDirty","ghostLabel","set","_sizeDirty","_valuesDirty","isPrivateDirty","_getMinMax","_handleSizeDirty","_isPanning","chart","getMM","letter","getPrivate","xAxes","each","axis","className","yAxes","_getSelectionMinMax","_groupData","_handleRangeChange","_prepareAxisItems","_updateAxisRanges","_baseValue","baseValue","_dseHandled","_clearDirty","_formatText","value","numberFormat","formatter","getNumberFormatter","text","format","undefined","min","max","isNumber","logarithmic","step","selectionMin","selectionMax","differencePower","minLog","_minLogAdjusted","_minRealLog","Math","pow","log","LOG10E","renderer","minorLabelsEnabled","minorGridEnabled","stepPower","floor","abs","stepAdjusted","round","minorGridCount","minorStep","i","m","previous","Infinity","dataItem","dataItems","length","_dataItems","push","processDataItem","_createAssets","_toggleDataItem","setRaw","label","_prepareDataItem","nextValue","minorValue","minorMinMaxStep","_adjustMinMax","minorDataItem","minorDataItems","minorLabel","setPrivate","decCount","j","series","inited","_markDirtyAxes","_updateGhost","count","endValue","position","valueToPosition","endPosition","fillEndPosition","labelEndPosition","labelEndValue","updateLabel","grid","updateGrid","_applyThemes","hasTag","removeTag","updateTick","updateFill","_processBullet","updateBullet","fillRule","positionToValue","gridCount","minMaxStep","stepDecimalPlaces","decimalPlaces","E","treatZeroAs","valueToFinalPosition","getX","location","positionToCoordinate","getY","getDataItemCoordinateX","field","_cellLocation","axisLocation","getDataItemPositionX","stackToItem","component","getStackedXValueWorking","getDataItemCoordinateY","getDataItemPositionY","getStackedYValueWorking","basePosition","cellEndValue","fixSmallStep","_fixMin","_fixMax","_calculateTotals","startIndex","endIndex","vc","fieldWorking","sum","total","isNaN","minDefined","maxDefined","extraMin","extraMax","selectionStrictMinMax","strictMinMax","seriesMin","seriesMax","outOfSelection","minX","maxX","minY","maxY","isHidden","isShowing","axisRanges","range","_minReal","_maxReal","smin","_deltaMinMax","d","minMaxStep2","selectionMinReal","selectionMaxReal","delta","fitToRange","_syncAxes","len","ceil","LN10","start","end","zoom","minDiff","diff","Error","initialMin","initialMax","minAdapted","adapters","fold","maxAdapted","_getDelta","strictMinMaxSelection","strict","_fixZoomFactor","_saveMinMax","duration","easing","animatePrivate","key","to","exponent","power","_min","_max","strictMode","difference","extra","stepDivisor","maxPrecision","ceiledStep","Number","MAX_VALUE","minCount","maxCount","getTooltipText","_adjustPosition","extraDecimals","decimals","getSeriesItem","fieldName","index","oldDiff","zoomToValues","syncMin","syncMax","syncStep","currentCount","synced","c","omin","omax","ostep","_checkSync","getCellWidthPosition","nextPosition","toGlobalPosition","classNames","concat"],"sources":["C:\\Users\\Moham\\Downloads\\Github projects\\Digital-Portfolio-main\\Frontend\\node_modules\\src\\.internal\\charts\\xy\\axes\\ValueAxis.ts"],"sourcesContent":["import type { AxisRenderer } from \"./AxisRenderer\";\nimport type { IXYSeriesDataItem, XYSeries } from \"../series/XYSeries\";\n\nimport { DataItem } from \"../../../core/render/Component\";\nimport { Axis, IAxisSettings, IAxisPrivate, IAxisDataItem, IAxisEvents } from \"./Axis\";\nimport { MultiDisposer } from \"../../../core/util/Disposer\";\n\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\n\nexport interface IValueAxisSettings<R extends AxisRenderer> extends IAxisSettings<R> {\n\n\t/**\n\t * Override minimum value for the axis scale.\n\t *\n\t * NOTE: the axis might modify the minimum value to fit into its scale better,\n\t * unless `strictMinMax` is set to `true`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Custom_scope} for more info\n\t */\n\tmin?: number;\n\n\t/**\n\t * Override maximum value for the axis scale.\n\t *\n\t * NOTE: the axis might modify the maximum value to fit into its scale better,\n\t * unless `strictMinMax` is set to `true`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Custom_scope} for more info\n\t */\n\tmax?: number;\n\n\t/**\n\t * Force axis scale to be precisely at values as set in `min` and/or `max`.\n\t *\n\t * In case `min` and/or `max` is not set, the axis will fix its scale to\n\t * precise lowest and highest values available through all of the series\n\t * attached to it.\n\t *\n\t * This effectively locks the axis from auto-zooming itself when chart\n\t * is zoomed in.\n\t *\n\t * If you need to zoom to actual low/high values within currently visible\n\t * scope, use `strictMinMaxSelection` instead.\n\t *\n\t * Use `extraMin` and `extraMax` to add extra \"padding\".\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Custom_scope} for more info\n\t */\n\tstrictMinMax?: boolean;\n\n\t/**\n\t * Force axis to auto-zoom to exact lowest and highest values from attached\n\t * series' data items within currently visible range.\n\t * \n\t * This is a good feature when your series is plotted from derivative values,\n\t * like `valueYChangeSelection` as it helps to avoid frequent jumping of\n\t * series to adjusted min and max of the axis.\n\t * \n\t * This will not work if strictMinMax is set to true (the axis will not zoom at all in this case).\n\t * \n\t * Use `extraMin` and `extraMax` to add extra \"padding\".\n\t *\n\t * @since 5.1.11\n\t */\n\tstrictMinMaxSelection?: boolean;\n\n\t/**\n\t * If set to `true` axis will use logarithmic scale.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Logarithmic_scale} for more info\n\t */\n\tlogarithmic?: boolean;\n\n\t/**\n\t * Treat zero values as some other value.\n\t *\n\t * Useful in situations where zero would result in error, i.e. logarithmic\n\t * scale.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Logarithmic_scale} for more info\n\t */\n\ttreatZeroAs?: number;\n\n\t/**\n\t * Relative extension to the automatically-calculated minimum value of the\n\t * axis scale.\n\t *\n\t * E..g. `0.1` will extend the scale by 10%, so if max value is `1000` and\n\t * minimum value is `0`, the new minimum value will be `-100`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Relative_scope_extension} for more info\n\t */\n\textraMin?: number;\n\n\t/**\n\t * Relative extension to the automatically-calculated maximum value of the\n\t * axis scale.\n\t *\n\t * E..g. `0.1` will extend the scale by 10%, so if max value is `1000`, the\n\t * axis will now show maximum value of `1100`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Relative_scope_extension} for more info\n\t */\n\textraMax?: number;\n\n\t/**\n\t * Base value, which indicates the threshold between \"positive\" and \"negative\"\n\t * values.\n\t *\n\t * @default 0\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Base_value} for more info\n\t */\n\tbaseValue?: number;\n\n\t/**\n\t * Maximum number of decimals to allow in axis labels.\n\t *\n\t * This setting not only affects formatting of the labels, but also where and\n\t * how many grid/labels are placed on the axis.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Label_format} for more info\n\t */\n\tmaxPrecision?: number;\n\n\t/**\n\t * A function that can be used to specify how to configure axis fills.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Axis_fills} for more info\n\t */\n\tfillRule?: (dataItem: DataItem<IValueAxisDataItem>) => void;\n\n\t/**\n\t * Number format to use for axis labels.\n\t *\n\t * If not set, will use format set in global number formatter.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Label_format} for more info\n\t */\n\tnumberFormat?: string;\n\n\t/**\n\t * A numeric format used for numbers displayed in axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Tooltip_number_format} for more info\n\t */\n\ttooltipNumberFormat?: string | Intl.NumberFormatOptions;\n\n\t/**\n\t * If set, will use greater precision for the axis tooltip than the one for\n\t * axis' actual labels.\n\t *\n\t * E.g. if axis displays labels with one decimal (`1.0`, `1.1`, `1.2`) setting\n\t * this setting to `1` would allow two decimals in axis tooltip, e.g. `1.15`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Tooltip_number_format} for more info\n\t */\n\textraTooltipPrecision?: number;\n\n\t/**\n\t * If your series relies on dynamically calculated values, like value\n\t * changes, percents, or total sums, set this to `true`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Calculated_values} for more info\n\t */\n\tcalculateTotals?: boolean;\n\n\t/**\n\t * This setting can be set to an instance of another [[ValueAxis]].\n\t *\n\t * If set the grid of this axis will be synced with grid of the target axis.\n\t *\n\t * NOTE: this is not 100% guaranteed to work. In some rare cases perfect\n\t * sync might not be possible.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Syncing_grid} for more info\n\t */\n\tsyncWithAxis?: ValueAxis<AxisRenderer>;\n\n\t/**\n\t * If set to `false`, the axis won't be auto-zoomed to a selection (this\n\t * works only if the other axis is a `DateAxis` or a `CategoryAxis`).\n\t * \n\t * IMPORTANT: This setting will be ignored if both X and Y axes are\n\t * a `ValueAxis`.\n\t *\n\t * @since 5.2.20\n\t * @default true\n\t */\n\tautoZoom?: boolean;\n\n}\n\nexport interface IValueAxisDataItem extends IAxisDataItem {\n\n\t/**\n\t * Value of the data item.\n\t */\n\tvalue?: number;\n\n\t/**\n\t * End value for axis items that span multiple values, like axis ranges.\n\t */\n\tendValue?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tlabelEndValue?: number;\n\n\t/**\n\t * If set to `true` the values fo this data item will be factored in when\n\t * calculating scale of the [[ValueAxis]]. Useful for axis ranges.\n\t * \n\t * @since 5.1.4\n\t */\n\taffectsMinMax?: boolean;\n\n}\n\nexport interface IMinMaxStep {\n\tmin: number;\n\tmax: number;\n\tstep: number;\n}\n\nexport interface IValueAxisPrivate extends IAxisPrivate {\n\n\t/**\n\t * Calculated current minimum value of the axis scale.\n\t * \n\t * @readonly\n\t */\n\tmin?: number;\n\n\t/**\n\t * Calculated current maximum value of the axis scale.\n\t * \n\t * @readonly\n\t */\n\tmax?: number;\n\n\t/**\n\t * A minimum value of the axis scale.\n\t *\n\t * Can be useful in cases where axis zoom is currently being animated, and\n\t * `min` is reflecting current intermediate value, whereas `minFinal` will\n\t * show target value.\n\t * \n\t * @readonly\n\t */\n\tminFinal?: number;\n\n\t/**\n\t * A maximum value of the axis scale.\n\t *\n\t * Can be useful in cases where axis zoom is currently being animated, and\n\t * `max` is reflecting current intermediate value, whereas `maxFinal` will\n\t * show target value.\n\t * \n\t * @readonly\n\t */\n\tmaxFinal?: number;\n\n\t/**\n\t * Calculated minimum value of the currently viewable (zoomed) scope.\n\t * \n\t * @readonly\n\t */\n\tselectionMin?: number;\n\n\t/**\n\t * Calculated maximum value of the currently viewable (zoomed) scope.\n\t * \n\t * @readonly\n\t */\n\tselectionMax?: number;\n\n\t/**\n\t * A target minimum value of the viewable value scope.\n\t *\n\t * Can be useful in cases where axis zoom is currently being animated, and\n\t * `selectionMin` is reflecting current intermediate value,\n\t * whereas `selectionMinFinal` will show target value.\n\t * \n\t * @readonly\n\t */\n\tselectionMinFinal?: number;\n\n\t/**\n\t * A target maximum value of the viewable value scope.\n\t *\n\t * Can be useful in cases where axis zoom is currently being animated, and\n\t * `selectionMax` is reflecting current intermediate value,\n\t * whereas `selectionMaxFinal` will show target value.\n\t * \n\t * @readonly\n\t */\n\tselectionMaxFinal?: number;\n\n\t/**\n\t * When selection step changes, it might change during axis zoom animation.\n\t *\n\t * `selectionStepFinal` will show what step will be when animation is\n\t * finished.\n\t * \n\t * @readonly\n\t */\n\tselectionStepFinal?: number;\n\n\t/**\n\t * Value step between grid lines.\n\t * \n\t * @readonly\n\t */\n\tstep?: number;\n\n\t/**\n\t * Decimal places used when formatting axis labels.\n\t * \n\t * @readonly\n\t */\n\tstepDecimalPlaces?: number;\n\n}\n\nexport interface IValueAxisEvents extends IAxisEvents {\n\n}\n\n/**\n * Creates a value axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info\n * @important\n */\nexport class ValueAxis<R extends AxisRenderer> extends Axis<R> {\n\tpublic static className: string = \"ValueAxis\";\n\tpublic static classNames: Array<string> = Axis.classNames.concat([ValueAxis.className]);\n\n\tdeclare public _settings: IValueAxisSettings<R>;\n\tdeclare public _privateSettings: IValueAxisPrivate;\n\tdeclare public _dataItemSettings: IValueAxisDataItem;\n\tdeclare public _events: IValueAxisEvents;\n\n\tprotected _dirtyExtremes: boolean = false;\n\tprotected _dirtySelectionExtremes: boolean = false;\n\tprotected _dseHandled = false;\n\tprotected _deltaMinMax: number = 1;\n\tprotected _minReal: number | undefined;\n\tprotected _maxReal: number | undefined;\n\n\tprotected _minRealLog: number | undefined;\n\n\tprotected _baseValue: number = 0;\n\tprotected _syncDp?: MultiDisposer;\n\tprotected _minLogAdjusted: number = 1;\n\t/**\n\t * @ignore\n\t */\n\tpublic markDirtyExtremes() {\n\t\tthis._dirtyExtremes = true;\n\t\tthis.markDirty();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic markDirtySelectionExtremes() {\n\t\tthis._dirtySelectionExtremes = true;\n\t\tthis.markDirty();\n\t}\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.setPrivateRaw(\"name\", \"value\");\n\t\tthis.addTag(\"value\");\n\t\tsuper._afterNew();\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tif (this.isDirty(\"syncWithAxis\")) {\n\t\t\tlet previousValue = this._prevSettings.syncWithAxis;\n\t\t\tif (previousValue) {\n\t\t\t\tif (this._syncDp) {\n\t\t\t\t\tthis._syncDp.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet syncWithAxis = this.get(\"syncWithAxis\");\n\t\t\tif (syncWithAxis) {\n\t\t\t\tthis._syncDp = new MultiDisposer([\n\t\t\t\t\tsyncWithAxis.onPrivate(\"selectionMinFinal\", () => {\n\t\t\t\t\t\tthis._dirtySelectionExtremes = true;\n\t\t\t\t\t}),\n\t\t\t\t\tsyncWithAxis.onPrivate(\"selectionMaxFinal\", () => {\n\t\t\t\t\t\tthis._dirtySelectionExtremes = true;\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t}\n\t\t}\n\n\t\tlet someDirty = false;\n\t\tif (this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"maxPrecision\") || this.isDirty(\"numberFormat\")) {\n\t\t\tsomeDirty = true;\n\t\t\tthis.ghostLabel.set(\"text\", \"\");\n\t\t}\n\n\t\t//if (this._dirtyExtremes || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"maxPrecision\")) {\n\t\tif (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || someDirty || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"strictMinMaxSelection\")) {\n\t\t\tthis._getMinMax();\n\t\t\tthis._dirtyExtremes = false;\n\t\t}\n\t\t\n\t\tthis._handleSizeDirty();\n\n\t\tif (this._dirtySelectionExtremes && !this._isPanning && this.get(\"autoZoom\", true)) {\n\n\t\t\tconst chart = this.chart;\n\t\t\tlet getMM = false;\n\t\t\t// #1563\n\t\t\tif (chart) {\n\t\t\t\tconst letter = this.get(\"renderer\").getPrivate(\"letter\");\n\t\t\t\tif (letter == \"Y\") {\n\t\t\t\t\tchart.xAxes.each((axis) => {\n\t\t\t\t\t\tif (axis.className != \"ValueAxis\") {\n\t\t\t\t\t\t\tgetMM = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\telse if (letter == \"X\") {\n\t\t\t\t\tchart.yAxes.each((axis) => {\n\t\t\t\t\t\tif (axis.className != \"ValueAxis\") {\n\t\t\t\t\t\t\tgetMM = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getMM) {\n\t\t\t\tthis._getSelectionMinMax();\n\t\t\t}\n\t\t\tthis._dirtySelectionExtremes = false;\n\t\t}\n\n\t\tthis._groupData();\n\n\t\tif (this._sizeDirty || this._valuesDirty || this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"min\") || this.isPrivateDirty(\"selectionMax\") || this.isPrivateDirty(\"selectionMin\") || this.isPrivateDirty(\"max\") || this.isPrivateDirty(\"step\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"logarithmic\")) {\n\t\t\tthis._handleRangeChange();\n\t\t\tthis._prepareAxisItems();\n\t\t\tthis._updateAxisRanges();\n\t\t}\n\n\t\tthis._baseValue = this.baseValue();\n\n\t}\n\n\tprotected _handleSizeDirty() {\n\t\tif (this._sizeDirty && !this._dseHandled) {\n\t\t\tthis._dirtySelectionExtremes = true;\n\t\t\tthis._dseHandled = true;\n\t\t}\n\t}\n\n\tpublic _clearDirty(): void {\n\t\tsuper._clearDirty();\n\t\tthis._dseHandled = false;\n\t}\n\n\tprotected _groupData() {\n\n\t}\n\n\tprotected _formatText(value: number) {\n\t\tconst numberFormat = this.get(\"numberFormat\");\n\t\tconst formatter = this.getNumberFormatter();\n\n\t\tlet text = \"\";\n\n\t\tif (numberFormat) {\n\t\t\ttext = formatter.format(value, numberFormat);\n\t\t}\n\t\telse {\n\t\t\ttext = formatter.format(value, undefined, this.getPrivate(\"stepDecimalPlaces\"));\n\t\t}\n\t\treturn text;\n\t}\n\n\tprotected _prepareAxisItems() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\n\t\t\tconst logarithmic = this.get(\"logarithmic\");\n\t\t\tconst step = this.getPrivate(\"step\")!;\n\t\t\tconst selectionMin = this.getPrivate(\"selectionMin\")!;\n\t\t\tconst selectionMax = this.getPrivate(\"selectionMax\")! + step;\n\n\t\t\tlet value = selectionMin - step;\n\t\t\tlet differencePower = 1;\n\t\t\tlet minLog: number = min;\n\n\t\t\tif (logarithmic) {\n\t\t\t\tvalue = this._minLogAdjusted;\n\n\t\t\t\tif (value < selectionMin) {\n\t\t\t\t\twhile (value < selectionMin) {\n\t\t\t\t\t\tvalue += step;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tminLog = value;\n\n\t\t\t\tif (minLog <= 0) {\n\t\t\t\t\tminLog = 1;\n\t\t\t\t\tif (step < 1) {\n\t\t\t\t\t\tif ($type.isNumber(this._minRealLog)) {\n\t\t\t\t\t\t\tminLog = this._minRealLog;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tminLog = Math.pow(10, -50);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdifferencePower = Math.log(selectionMax - step) * Math.LOG10E - Math.log(minLog) * Math.LOG10E;\n\n\t\t\t\tif (differencePower > 2) {\n\t\t\t\t\tvalue = Math.pow(10, Math.log(minLog) * Math.LOG10E - 50);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// minor grid\n\t\t\tconst renderer = this.get(\"renderer\");\n\t\t\tconst minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\n\t\t\tconst minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\n\n\t\t\tlet stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n\n\t\t\tconst stepAdjusted = Math.round(step / stepPower);\n\n\t\t\tlet minorGridCount = 2;\n\n\t\t\tif ($math.round(stepAdjusted / 5, 10) % 1 == 0) {\n\t\t\t\tminorGridCount = 5;\n\t\t\t}\n\n\t\t\tif ($math.round(stepAdjusted / 10, 10) % 1 == 0) {\n\t\t\t\tminorGridCount = 10;\n\t\t\t}\n\n\t\t\tlet minorStep = step / minorGridCount;\n\n\t\t\t// end of minor grid\n\t\t\tlet i = 0;\n\t\t\tlet m = 0;\n\t\t\tlet previous = -Infinity;\n\n\t\t\twhile (value < selectionMax) {\n\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\tif (this.dataItems.length < i + 1) {\n\t\t\t\t\tdataItem = new DataItem(this, undefined, {});\n\t\t\t\t\tthis._dataItems.push(dataItem);\n\t\t\t\t\tthis.processDataItem(dataItem);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdataItem = this.dataItems[i];\n\t\t\t\t}\n\n\t\t\t\tthis._createAssets(dataItem, []);\n\t\t\t\tthis._toggleDataItem(dataItem, true);\n\n\t\t\t\tdataItem.setRaw(\"value\", value);\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._formatText(value));\n\t\t\t\t}\n\n\t\t\t\tthis._prepareDataItem(dataItem);\n\n\t\t\t\tlet nextValue = value;\n\t\t\t\tif (!logarithmic) {\n\t\t\t\t\tnextValue += step;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (differencePower > 2) {\n\t\t\t\t\t\tnextValue = Math.pow(10, Math.log(minLog) * Math.LOG10E + i - 50);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnextValue += step;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// minor grid\n\t\t\t\tif (minorGridEnabled) {\n\t\t\t\t\tlet minorValue = value + minorStep;\n\n\t\t\t\t\tif (logarithmic) {\n\t\t\t\t\t\tif (differencePower > 2) {\n\t\t\t\t\t\t\tlet minorMinMaxStep = this._adjustMinMax(value, nextValue, 10);\n\t\t\t\t\t\t\tminorStep = minorMinMaxStep.step;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminorValue = value + minorStep;\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (minorValue < nextValue - step * 0.00000000001) {\n\t\t\t\t\t\tlet minorDataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\t\t\tif (this.minorDataItems.length < m + 1) {\n\t\t\t\t\t\t\tminorDataItem = new DataItem(this, undefined, {});\n\t\t\t\t\t\t\tthis.minorDataItems.push(minorDataItem);\n\t\t\t\t\t\t\tthis.processDataItem(minorDataItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tminorDataItem = this.minorDataItems[m];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._createAssets(minorDataItem, [\"minor\"], true);\n\t\t\t\t\t\tthis._toggleDataItem(minorDataItem, true);\n\t\t\t\t\t\tminorDataItem.setRaw(\"value\", minorValue);\n\n\t\t\t\t\t\tconst minorLabel = minorDataItem.get(\"label\");\n\t\t\t\t\t\tif (minorLabel) {\n\t\t\t\t\t\t\tif (minorLabelsEnabled) {\n\t\t\t\t\t\t\t\tminorLabel.set(\"text\", this._formatText(minorValue));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tminorLabel.setPrivate(\"visible\", false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._prepareDataItem(minorDataItem);\n\t\t\t\t\t\tminorValue += minorStep;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalue = nextValue;\n\n\t\t\t\tif (previous == value) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n\t\t\t\tif (stepPower < 1 && !logarithmic) {\n\t\t\t\t\t// exponent is less then 1 too. Count decimals of exponent\n\t\t\t\t\tlet decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;\n\t\t\t\t\t// round value to avoid floating point issues\n\t\t\t\t\tvalue = $math.round(value, decCount);\n\t\t\t\t}\n\t\t\t\ti++;\n\n\t\t\t\tprevious = value;\n\t\t\t}\n\n\t\t\tfor (let j = i; j < this.dataItems.length; j++) {\n\t\t\t\tthis._toggleDataItem(this.dataItems[j], false);\n\t\t\t}\n\n\t\t\tfor (let j = m; j < this.minorDataItems.length; j++) {\n\t\t\t\tthis._toggleDataItem(this.minorDataItems[j], false);\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.inited) {\n\t\t\t\t\tseries._markDirtyAxes();\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis._updateGhost();\n\t\t}\n\t}\n\n\n\tpublic _prepareDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, count?: number) {\n\t\tlet renderer = this.get(\"renderer\");\n\t\tlet value = dataItem.get(\"value\")!;\n\t\tlet endValue = dataItem.get(\"endValue\");\n\n\t\tlet position = this.valueToPosition(value);\n\n\t\tlet endPosition = position;\n\t\tlet fillEndPosition = this.valueToPosition(value + this.getPrivate(\"step\")!);\n\n\t\tif ($type.isNumber(endValue)) {\n\t\t\tendPosition = this.valueToPosition(endValue);\n\t\t\tfillEndPosition = endPosition;\n\t\t}\n\n\t\tif (dataItem.get(\"isRange\")) {\n\t\t\tif (endValue == null) {\n\t\t\t\tfillEndPosition = position;\n\t\t\t}\n\t\t}\n\n\t\tlet labelEndPosition = endPosition;\n\n\t\tlet labelEndValue = dataItem.get(\"labelEndValue\");\n\t\tif (labelEndValue != null) {\n\t\t\tlabelEndPosition = this.valueToPosition(labelEndValue);\n\t\t}\n\n\t\trenderer.updateLabel(dataItem.get(\"label\"), position, labelEndPosition, count);\n\n\t\tconst grid = dataItem.get(\"grid\");\n\t\trenderer.updateGrid(grid, position, endPosition);\n\t\tif (grid) {\n\t\t\tif (value == this.get(\"baseValue\", 0)) {\n\t\t\t\tgrid.addTag(\"base\");\n\t\t\t\tgrid._applyThemes();\n\t\t\t}\n\t\t\telse if (grid.hasTag(\"base\")) {\n\t\t\t\tgrid.removeTag(\"base\");\n\t\t\t\tgrid._applyThemes();\n\t\t\t}\n\t\t}\n\n\t\trenderer.updateTick(dataItem.get(\"tick\"), position, labelEndPosition, count);\n\t\trenderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n\n\t\tthis._processBullet(dataItem);\n\t\trenderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n\n\t\tif (!dataItem.get(\"isRange\")) {\n\t\t\tconst fillRule = this.get(\"fillRule\");\n\t\t\tif (fillRule) {\n\t\t\t\tfillRule(dataItem)\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprotected _handleRangeChange() {\n\t\tlet selectionMin: number = this.positionToValue(this.get(\"start\", 0));\n\t\tlet selectionMax: number = this.positionToValue(this.get(\"end\", 1));\n\n\t\tconst gridCount = this.get(\"renderer\").gridCount();\n\t\tlet minMaxStep: IMinMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n\n\t\tlet stepDecimalPlaces = $utils.decimalPlaces(minMaxStep.step);\n\t\tthis.setPrivateRaw(\"stepDecimalPlaces\", stepDecimalPlaces);\n\n\t\tselectionMin = $math.round(selectionMin, stepDecimalPlaces);\n\t\tselectionMax = $math.round(selectionMax, stepDecimalPlaces);\n\n\t\tminMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n\n\t\tlet step = minMaxStep.step;\n\t\tselectionMin = minMaxStep.min;\n\t\tselectionMax = minMaxStep.max;\n\n\t\tif (this.getPrivate(\"selectionMin\") !== selectionMin || this.getPrivate(\"selectionMax\") !== selectionMax || this.getPrivate(\"step\") !== step) {\n\t\t\t// do not change to setPrivate, will cause SO\n\t\t\tthis.setPrivateRaw(\"selectionMin\", selectionMin);\n\t\t\tthis.setPrivateRaw(\"selectionMax\", selectionMax);\n\n\t\t\tthis.setPrivateRaw(\"step\", step);\n\t\t}\n\t}\n\n\t/**\n\t * Converts a relative position to a corresponding numeric value from axis\n\t * scale.\n\t *\n\t * @param   position  Relative position\n\t * @return            Value\n\t */\n\tpublic positionToValue(position: number): number {\n\t\tconst min = this.getPrivate(\"min\")!;\n\t\tconst max = this.getPrivate(\"max\")!;\n\n\t\tif (!this.get(\"logarithmic\")) {\n\t\t\treturn position * (max - min) + min;\n\t\t}\n\t\telse {\n\t\t\treturn Math.pow(Math.E, (position * ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E)) + Math.log(min) * Math.LOG10E) / Math.LOG10E);\n\t\t}\n\t}\n\n\t/**\n\t * Convers value to a relative position on axis.\n\t *\n\t * @param   value  Value\n\t * @return         Relative position\n\t */\n\tpublic valueToPosition(value: number): number {\n\n\t\tconst min = this.getPrivate(\"min\")!;\n\t\tconst max = this.getPrivate(\"max\")!;\n\n\t\tif (!this.get(\"logarithmic\")) {\n\t\t\treturn (value - min) / (max - min);\n\t\t}\n\t\telse {\n\t\t\tif (value <= 0) {\n\t\t\t\tlet treatZeroAs = this.get(\"treatZeroAs\");\n\t\t\t\tif ($type.isNumber(treatZeroAs)) {\n\t\t\t\t\tvalue = treatZeroAs;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic valueToFinalPosition(value: number): number {\n\n\t\tconst min = this.getPrivate(\"minFinal\")!;\n\t\tconst max = this.getPrivate(\"maxFinal\")!;\n\n\t\tif (!this.get(\"logarithmic\")) {\n\t\t\treturn (value - min) / (max - min);\n\t\t}\n\t\telse {\n\t\t\tif (value <= 0) {\n\t\t\t\tlet treatZeroAs = this.get(\"treatZeroAs\");\n\t\t\t\tif ($type.isNumber(treatZeroAs)) {\n\t\t\t\t\tvalue = treatZeroAs;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));\n\t\t}\n\t}\n\n\t/**\n\t * Returns X coordinate in pixels corresponding to specific value.\n\t *\n\t * @param   value     Numeric value\n\t * @param   location  Location\n\t * @param   baseValue Base value\n\t * @return            X coordinate\n\t */\n\tpublic getX(value: number, location: number, baseValue: number) {\n\t\tvalue = baseValue + (value - baseValue) * location;\n\n\t\tconst position = this.valueToPosition(value);\n\t\treturn this._settings.renderer.positionToCoordinate(position);\n\t}\n\n\t/**\n\t * Returns X coordinate in pixels corresponding to specific value.\n\t *\n\t * @param   value     Numeric value\n\t * @param   location  Location\n\t * @param   baseValue Base value\n\t * @return            X coordinate\n\t */\n\tpublic getY(value: number, location: number, baseValue: number) {\n\t\tvalue = baseValue + (value - baseValue) * location;\n\n\t\tconst position = this.valueToPosition(value)\n\t\treturn this._settings.renderer.positionToCoordinate(position);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number) {\n\t\tlet value = dataItem.get(field as any);\n\n\t\tconst stackToItem = dataItem.get(\"stackToItemX\");\n\t\tif (stackToItem) {\n\t\t\tconst series = dataItem.component as XYSeries;\n\t\t\tvalue = value * axisLocation + series.getStackedXValueWorking(dataItem, field);\n\t\t}\n\t\telse {\n\t\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\t}\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number): number {\n\t\tlet value = dataItem.get(field as any);\n\n\t\tconst stackToItem = dataItem.get(\"stackToItemY\");\n\t\tif (stackToItem) {\n\t\t\tconst series = dataItem.component as XYSeries;\n\t\t\tvalue = value * axisLocation + series.getStackedYValueWorking(dataItem, field);\n\t\t}\n\t\telse {\n\t\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\t}\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * Returns relative position of axis' `baseValue`.\n\t *\n\t * @return  Base value position\n\t */\n\tpublic basePosition(): number {\n\t\treturn this.valueToPosition(this.baseValue());\n\t}\n\n\t/**\n\t * Base value of the [[ValueAxis]], which determines positive and negative\n\t * values.\n\t *\n\t * @return Base value\n\t */\n\tpublic baseValue(): number {\n\t\tconst min = Math.min(this.getPrivate(\"minFinal\", -Infinity), this.getPrivate(\"selectionMin\", -Infinity));\n\t\tconst max = Math.max(this.getPrivate(\"maxFinal\", Infinity), this.getPrivate(\"selectionMax\", Infinity));\n\t\tlet baseValue = this.get(\"baseValue\", 0);\n\n\t\tif (baseValue < min) {\n\t\t\tbaseValue = min;\n\t\t}\n\n\t\tif (baseValue > max) {\n\t\t\tbaseValue = max\n\t\t}\n\n\t\treturn baseValue;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic cellEndValue(value: number): number {\n\t\treturn value;\n\t}\n\n\tprotected fixSmallStep(step: number): number {\n\t\t// happens because of floating point error\n\t\tif (1 + step === 1) {\n\t\t\tstep *= 2;\n\t\t\treturn this.fixSmallStep(step);\n\t\t}\n\t\treturn step;\n\t}\n\n\tprotected _fixMin(min: number) {\n\t\treturn min;\n\t}\n\n\tprotected _fixMax(max: number) {\n\t\treturn max;\n\t}\n\n\tpublic _calculateTotals() {\n\t\tif (this.get(\"calculateTotals\")) {\n\t\t\tlet series = this.series[0];\n\t\t\tif (series) {\n\t\t\t\tlet startIndex = series.startIndex();\n\n\t\t\t\tif (series.dataItems.length > 0) {\n\n\t\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t\tstartIndex--;\n\t\t\t\t\t}\n\t\t\t\t\tlet endIndex = series.endIndex();\n\t\t\t\t\tif (endIndex < series.dataItems.length) {\n\t\t\t\t\t\tendIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet field: string | undefined;\n\t\t\t\t\tlet vc: string | undefined;\n\n\t\t\t\t\tif (series.get(\"yAxis\") == this) {\n\t\t\t\t\t\tfield = \"valueY\";\n\t\t\t\t\t\tvc = \"vcy\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (series.get(\"xAxis\") == this) {\n\t\t\t\t\t\tfield = \"valueX\";\n\t\t\t\t\t\tvc = \"vcx\";\n\t\t\t\t\t}\n\n\t\t\t\t\tlet fieldWorking = field + \"Working\";\n\n\t\t\t\t\tif (field) {\n\t\t\t\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet total = 0;\n\n\t\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\t\tif (!series.get(\"excludeFromTotal\")) {\n\t\t\t\t\t\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\t\t\t\t\t\tif (dataItem) {\n\t\t\t\t\t\t\t\t\t\tlet value = dataItem.get(fieldWorking as any) * series.get(vc as any);\n\n\t\t\t\t\t\t\t\t\t\tif (!$type.isNaN(value)) {\n\t\t\t\t\t\t\t\t\t\t\tsum += value;\n\t\t\t\t\t\t\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\t\tif (!series.get(\"excludeFromTotal\")) {\n\t\t\t\t\t\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\t\t\t\t\t\tif (dataItem) {\n\t\t\t\t\t\t\t\t\t\tlet value = dataItem.get(fieldWorking as any) * series.get(vc as any);\n\n\t\t\t\t\t\t\t\t\t\tif (!$type.isNaN(value)) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem.set((field + \"Total\") as any, total);\n\t\t\t\t\t\t\t\t\t\t\tdataItem.set((field + \"Sum\") as any, sum);\n\t\t\t\t\t\t\t\t\t\t\tdataItem.set((field + \"TotalPercent\") as any, value / total * 100);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _getSelectionMinMax() {\n\t\tconst min = this.getPrivate(\"minFinal\");\n\t\tconst max = this.getPrivate(\"maxFinal\");\n\n\t\tconst minDefined = this.get(\"min\");\n\t\tconst maxDefined = this.get(\"max\");\n\n\t\tlet extraMin = this.get(\"extraMin\", 0);\n\t\tlet extraMax = this.get(\"extraMax\", 0);\n\n\t\tif (this.get(\"logarithmic\")) {\n\t\t\tif (this.get(\"extraMin\") == null) {\n\t\t\t\textraMin = 0.1;\n\t\t\t}\n\t\t\tif (this.get(\"extraMax\") == null) {\n\t\t\t\textraMax = 0.2;\n\t\t\t}\n\t\t}\n\n\t\tconst gridCount = this.get(\"renderer\").gridCount();\n\t\tconst selectionStrictMinMax = this.get(\"strictMinMaxSelection\");\n\t\tlet strictMinMax = this.get(\"strictMinMax\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tlet selectionMin = max;\n\t\t\tlet selectionMax = min;\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (!series.get(\"ignoreMinMax\")) {\n\t\t\t\t\tlet seriesMin: number | undefined;\n\t\t\t\t\tlet seriesMax: number | undefined;\n\t\t\t\t\tconst outOfSelection = series.getPrivate(\"outOfSelection\");\n\n\t\t\t\t\tif (series.get(\"xAxis\") === this) {\n\t\t\t\t\t\tif (!outOfSelection) {\n\t\t\t\t\t\t\tlet minX = series.getPrivate(\"minX\");\n\t\t\t\t\t\t\tlet maxX = series.getPrivate(\"maxX\");\n\n\t\t\t\t\t\t\t// solves #90085\n\t\t\t\t\t\t\tif (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {\n\t\t\t\t\t\t\t\tminX = undefined;\n\t\t\t\t\t\t\t\tmaxX = undefined;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tseriesMin = series.getPrivate(\"selectionMinX\", minX);\n\t\t\t\t\t\t\tseriesMax = series.getPrivate(\"selectionMaxX\", maxX);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (series.get(\"yAxis\") === this) {\n\t\t\t\t\t\tif (!outOfSelection) {\n\n\t\t\t\t\t\t\tlet minY = series.getPrivate(\"minY\");\n\t\t\t\t\t\t\tlet maxY = series.getPrivate(\"maxY\");\n\n\t\t\t\t\t\t\t// solves #90085\n\t\t\t\t\t\t\tif (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {\n\t\t\t\t\t\t\t\tminY = undefined;\n\t\t\t\t\t\t\t\tmaxY = undefined;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tseriesMin = series.getPrivate(\"selectionMinY\", minY);\n\t\t\t\t\t\t\tseriesMax = series.getPrivate(\"selectionMaxY\", maxY);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!series.isHidden() && !series.isShowing()) {\n\t\t\t\t\t\tif ($type.isNumber(seriesMin)) {\n\t\t\t\t\t\t\tselectionMin = Math.min(selectionMin, seriesMin);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ($type.isNumber(seriesMax)) {\n\t\t\t\t\t\t\tselectionMax = Math.max(selectionMax, seriesMax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis.axisRanges.each((range) => {\n\t\t\t\tif (range.get(\"affectsMinMax\")) {\n\t\t\t\t\tlet value = range.get(\"value\");\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tselectionMin = Math.min(selectionMin, value);\n\t\t\t\t\t\tselectionMax = Math.max(selectionMax, value);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = range.get(\"endValue\");\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tselectionMin = Math.min(selectionMin, value);\n\t\t\t\t\t\tselectionMax = Math.max(selectionMax, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (selectionMin > selectionMax) {\n\t\t\t\t[selectionMin, selectionMax] = [selectionMax, selectionMin]\n\t\t\t}\n\n\t\t\tif ($type.isNumber(minDefined)) {\n\t\t\t\tif (strictMinMax) {\n\t\t\t\t\tselectionMin = minDefined;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tselectionMin = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strictMinMax) {\n\t\t\t\tif ($type.isNumber(this._minReal)) {\n\t\t\t\t\tselectionMin = this._minReal;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($type.isNumber(maxDefined)) {\n\t\t\t\tif (strictMinMax) {\n\t\t\t\t\tselectionMax = maxDefined;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tselectionMax = max;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strictMinMax) {\n\t\t\t\tif ($type.isNumber(this._maxReal)) {\n\t\t\t\t\tselectionMax = this._maxReal;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (selectionMin === selectionMax) {\n\t\t\t\tlet smin = selectionMin;\n\t\t\t\tselectionMin -= this._deltaMinMax;\n\t\t\t\tselectionMax += this._deltaMinMax;\n\n\t\t\t\tif (selectionMin < min) {\n\t\t\t\t\tlet d = smin - min;\n\t\t\t\t\tif (d == 0) {\n\t\t\t\t\t\td = this._deltaMinMax;\n\t\t\t\t\t}\n\n\t\t\t\t\tselectionMin = smin - d;\n\t\t\t\t\tselectionMax = smin + d;\n\n\t\t\t\t\tstrictMinMax = true;\n\t\t\t\t}\n\n\t\t\t\tlet minMaxStep2 = this._adjustMinMax(selectionMin, selectionMax, gridCount, strictMinMax);\n\t\t\t\tselectionMin = minMaxStep2.min;\n\t\t\t\tselectionMax = minMaxStep2.max;\n\t\t\t}\n\n\t\t\tlet selectionMinReal = selectionMin;\n\t\t\tlet selectionMaxReal = selectionMax;\n\n\t\t\tlet delta = selectionMax - selectionMin;\n\n\t\t\tselectionMin -= delta * extraMin;\n\t\t\tselectionMax += delta * extraMax;\t\t\t\n\n\t\t\tlet minMaxStep: IMinMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount);\n\n\t\t\tselectionMin = minMaxStep.min;\n\t\t\tselectionMax = minMaxStep.max;\n\n\t\t\tselectionMin = $math.fitToRange(selectionMin, min, max);\n\t\t\tselectionMax = $math.fitToRange(selectionMax, min, max);\n\n\t\t\t// do it for the second time !important\t\t\t\n\t\t\tminMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n\n\t\t\tif (!strictMinMax) {\n\t\t\t\tselectionMin = minMaxStep.min;\n\t\t\t\tselectionMax = minMaxStep.max;\n\t\t\t}\n\n\t\t\tconst syncWithAxis = this.get(\"syncWithAxis\");\n\t\t\tif (syncWithAxis) {\n\t\t\t\tminMaxStep = this._syncAxes(selectionMin, selectionMax, minMaxStep.step, syncWithAxis.getPrivate(\"selectionMinFinal\", syncWithAxis.getPrivate(\"minFinal\", 0)), syncWithAxis.getPrivate(\"selectionMaxFinal\", syncWithAxis.getPrivate(\"maxFinal\", 1)), syncWithAxis.getPrivate(\"selectionStepFinal\", syncWithAxis.getPrivate(\"step\", 1)));\n\n\t\t\t\tif (minMaxStep.min < min) {\n\t\t\t\t\tminMaxStep.min = min;\n\t\t\t\t}\n\n\t\t\t\tif (minMaxStep.max > max) {\n\t\t\t\t\tminMaxStep.max = max;\n\t\t\t\t}\n\n\t\t\t\tselectionMin = minMaxStep.min;\n\t\t\t\tselectionMax = minMaxStep.max;\n\t\t\t}\n\t\n\t\t\tif (strictMinMax) {\n\t\t\t\tif ($type.isNumber(minDefined)) {\n\t\t\t\t\tselectionMin = Math.max(selectionMin, minDefined);\n\t\t\t\t}\n\n\t\t\t\tif ($type.isNumber(maxDefined)) {\n\t\t\t\t\tselectionMax = Math.min(selectionMax, maxDefined);\n\t\t\t\t}\t\t\t\n\t\t\t}\n\n\t\t\tif (selectionStrictMinMax) {\n\t\t\t\tselectionMin = selectionMinReal - (selectionMaxReal - selectionMinReal) * extraMin;\n\t\t\t\tselectionMax = selectionMaxReal + (selectionMaxReal - selectionMinReal) * extraMax;\n\t\t\t}\n\n\t\t\tif (strictMinMax) {\n\t\t\t\tif ($type.isNumber(minDefined)) {\n\t\t\t\t\tselectionMin = minDefined;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tselectionMin = selectionMinReal;\n\t\t\t\t}\n\t\n\t\t\t\tif ($type.isNumber(maxDefined)) {\n\t\t\t\t\tselectionMax = maxDefined;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tselectionMax = selectionMaxReal;\n\t\t\t\t}\n\t\n\t\t\t\tif (selectionMax - selectionMin <= 0.00000001) {\n\t\t\t\t\tselectionMin -= this._deltaMinMax;\n\t\t\t\t\tselectionMax += this._deltaMinMax;\n\t\t\t\t}\n\t\n\t\t\t\tlet delta = selectionMax - selectionMin;\n\n\t\t\t\tselectionMin -= delta * extraMin;\n\t\t\t\tselectionMax += delta * extraMax;\n\t\t\t}\t\t\n\n\t\t\tif (this.get(\"logarithmic\")) {\n\n\t\t\t\tif (selectionMin <= 0) {\n\t\t\t\t\tselectionMin = selectionMinReal * (1 - Math.min(extraMin, 0.99));\n\t\t\t\t}\n\n\t\t\t\tif (selectionMin < min) {\n\t\t\t\t\tselectionMin = min;\n\t\t\t\t}\n\t\t\t\tif (selectionMax > max) {\n\t\t\t\t\tselectionMax = max;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet len = Math.min(20, Math.ceil(Math.log(this.getPrivate(\"maxZoomFactor\", 100) + 1) / Math.LN10) + 2);\n\n\t\t\tlet start = $math.round(this.valueToFinalPosition(selectionMin), len);\n\t\t\tlet end = $math.round(this.valueToFinalPosition(selectionMax), len);\n\n\t\t\tthis.setPrivateRaw(\"selectionMinFinal\", selectionMin);\n\t\t\tthis.setPrivateRaw(\"selectionMaxFinal\", selectionMax);\n\t\t\tthis.setPrivateRaw(\"selectionStepFinal\", minMaxStep.step);\n\n\t\t\tthis.zoom(start, end);\n\t\t}\n\t}\n\n\n\tprotected _getMinMax() {\n\t\tlet minDefined = this.get(\"min\");\n\t\tlet maxDefined = this.get(\"max\");\n\n\t\tlet min = Infinity;\n\t\tlet max = -Infinity;\n\n\t\tlet extraMin = this.get(\"extraMin\", 0);\n\t\tlet extraMax = this.get(\"extraMax\", 0);\n\n\t\tif (this.get(\"logarithmic\")) {\n\t\t\tif (this.get(\"extraMin\") == null) {\n\t\t\t\textraMin = 0.1;\n\t\t\t}\n\t\t\tif (this.get(\"extraMax\") == null) {\n\t\t\t\textraMax = 0.2;\n\t\t\t}\n\t\t}\n\n\t\tlet minDiff = Infinity;\n\n\t\t$array.each(this.series, (series) => {\n\t\t\tif (!series.get(\"ignoreMinMax\")) {\n\t\t\t\tlet seriesMin: number | undefined;\n\t\t\t\tlet seriesMax: number | undefined;\n\t\t\t\tif (series.get(\"xAxis\") === this) {\n\t\t\t\t\tseriesMin = series.getPrivate(\"minX\");\n\t\t\t\t\tseriesMax = series.getPrivate(\"maxX\");\n\t\t\t\t}\n\t\t\t\telse if (series.get(\"yAxis\") === this) {\n\t\t\t\t\tseriesMin = series.getPrivate(\"minY\");\n\t\t\t\t\tseriesMax = series.getPrivate(\"maxY\");\n\t\t\t\t}\n\n\t\t\t\tif ($type.isNumber(seriesMin) && $type.isNumber(seriesMax)) {\n\t\t\t\t\tmin = Math.min(min, seriesMin);\n\t\t\t\t\tmax = Math.max(max, seriesMax);\n\n\t\t\t\t\tlet diff = seriesMax - seriesMin;\n\n\t\t\t\t\tif (diff <= 0) {\n\t\t\t\t\t\tdiff = Math.abs(seriesMax / 100);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (diff < minDiff) {\n\t\t\t\t\t\tminDiff = diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.axisRanges.each((range) => {\n\t\t\tif (range.get(\"affectsMinMax\")) {\n\t\t\t\tlet value = range.get(\"value\");\n\t\t\t\tif (value != null) {\n\t\t\t\t\tmin = Math.min(min, value);\n\t\t\t\t\tmax = Math.max(max, value);\n\t\t\t\t}\n\t\t\t\tvalue = range.get(\"endValue\");\n\t\t\t\tif (value != null) {\n\t\t\t\t\tmin = Math.min(min, value);\n\t\t\t\t\tmax = Math.max(max, value);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (this.get(\"logarithmic\")) {\n\t\t\tlet treatZeroAs = this.get(\"treatZeroAs\");\n\t\t\tif ($type.isNumber(treatZeroAs)) {\n\t\t\t\tif (min <= 0) {\n\t\t\t\t\tmin = treatZeroAs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min <= 0) {\n\t\t\t\tnew Error(\"Logarithmic value axis can not have values <= 0.\");\n\t\t\t}\n\t\t}\n\n\t\tif (min === 0 && max === 0) {\n\t\t\tmax = 0.9;\n\t\t\tmin = -0.9;\n\t\t}\n\n\t\tif ($type.isNumber(minDefined)) {\n\t\t\tmin = minDefined;\n\t\t}\n\t\tif ($type.isNumber(maxDefined)) {\n\t\t\tmax = maxDefined;\n\t\t}\n\n\t\t// meaning no min/max found on series/ranges and no min/max was defined\n\t\tif (min === Infinity || max === -Infinity) {\n\t\t\tthis.setPrivate(\"minFinal\", undefined);\n\t\t\tthis.setPrivate(\"maxFinal\", undefined);\n\t\t\treturn;\n\t\t}\n\n\t\tif (min > max) {\n\t\t\t[min, max] = [max, min];\n\t\t}\n\n\t\tconst initialMin = min;\n\t\tconst initialMax = max;\n\n\t\t// adapter\n\t\tlet minAdapted = this.adapters.fold(\"min\", min);\n\t\tlet maxAdapted = this.adapters.fold(\"max\", max);\n\n\t\tthis._minRealLog = min;\n\n\t\tif ($type.isNumber(minAdapted)) {\n\t\t\tmin = minAdapted;\n\t\t}\n\n\t\tif ($type.isNumber(maxAdapted)) {\n\t\t\tmax = maxAdapted;\n\t\t}\n\n\t\t// DateAxis does some magic here\n\t\tmin = this._fixMin(min);\n\t\tmax = this._fixMax(max);\n\n\t\t// this happens if starLocation and endLocation are 0.5 and DateAxis has only one date\t\t\n\t\tif (max - min <= 1 / Math.pow(10, 15)) {\n\t\t\tif (max - min !== 0) {\n\t\t\t\tthis._deltaMinMax = (max - min) / 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._getDelta(max);\n\t\t\t}\n\n\t\t\tmin -= this._deltaMinMax;\n\t\t\tmax += this._deltaMinMax;\n\t\t}\n\n\t\t// add extras\n\t\tmin -= (max - min) * extraMin;\n\t\tmax += (max - min) * extraMax;\n\n\t\tif (this.get(\"logarithmic\")) {\n\t\t\t// don't let min go below 0 if real min is >= 0\n\t\t\tif (min < 0 && initialMin >= 0) {\n\t\t\t\tmin = 0;\n\t\t\t}\n\t\t\t// don't let max go above 0 if real max is <= 0\n\t\t\tif (max > 0 && initialMax <= 0) {\n\t\t\t\tmax = 0;\n\t\t\t}\n\t\t}\n\n\t\tthis._minReal = min;\n\t\tthis._maxReal = max;\n\n\t\tlet strictMinMax = this.get(\"strictMinMax\");\n\t\tlet strictMinMaxSelection = this.get(\"strictMinMaxSelection\", false);\n\t\tif (strictMinMaxSelection) {\n\t\t\tstrictMinMax = strictMinMaxSelection;\n\t\t}\n\n\t\tlet strict = strictMinMax;\n\t\tif ($type.isNumber(maxDefined)) {\n\t\t\tstrict = true;\n\t\t}\n\n\t\tlet gridCount = this.get(\"renderer\").gridCount();\n\n\t\tlet minMaxStep: IMinMaxStep = this._adjustMinMax(min, max, gridCount, strict);\n\n\t\tmin = minMaxStep.min;\n\t\tmax = minMaxStep.max;\n\n\t\t// do it for the second time with strict true (importat!)\n\t\tminMaxStep = this._adjustMinMax(min, max, gridCount, true);\n\n\t\tmin = minMaxStep.min;\n\t\tmax = minMaxStep.max;\n\n\t\t// return min max if strict\n\t\tif (strictMinMax) {\n\t\t\tif ($type.isNumber(minDefined)) {\n\t\t\t\tmin = minDefined;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin = this._minReal;\n\t\t\t}\n\n\t\t\tif ($type.isNumber(maxDefined)) {\n\t\t\t\tmax = maxDefined;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax = this._maxReal;\n\t\t\t}\n\n\t\t\tif (max - min <= 0.00000001) {\n\t\t\t\tmin -= this._deltaMinMax;\n\t\t\t\tmax += this._deltaMinMax;\n\t\t\t}\n\n\t\t\tlet delta = max - min;\n\t\t\tmin -= delta * extraMin;\n\t\t\tmax += delta * extraMax;\n\t\t}\n\n\t\tminAdapted = this.adapters.fold(\"min\", min);\n\t\tmaxAdapted = this.adapters.fold(\"max\", max);\n\n\t\tif ($type.isNumber(minAdapted)) {\n\t\t\tmin = minAdapted;\n\t\t}\n\n\t\tif ($type.isNumber(maxAdapted)) {\n\t\t\tmax = maxAdapted;\n\t\t}\n\n\t\tif (minDiff == Infinity) {\n\t\t\tminDiff = (max - min)\n\t\t}\n\n\t\t// this is to avoid floating point number error\n\t\tlet decCount = Math.round(Math.abs(Math.log(Math.abs(max - min)) * Math.LOG10E)) + 5;\n\n\t\tmin = $math.round(min, decCount);\n\t\tmax = $math.round(max, decCount);\n\n\t\t\n\n\t\tconst syncWithAxis = this.get(\"syncWithAxis\");\n\t\tif (syncWithAxis) {\n\t\t\tminMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate(\"minFinal\", syncWithAxis.getPrivate(\"min\", 0)), syncWithAxis.getPrivate(\"maxFinal\", syncWithAxis.getPrivate(\"max\", 1)), syncWithAxis.getPrivate(\"step\", 1));\n\t\t\tmin = minMaxStep.min;\n\t\t\tmax = minMaxStep.max;\n\t\t}\n\n\n\t\tthis.setPrivateRaw(\"maxZoomFactor\", Math.max(1, Math.ceil((max - min) / minDiff * this.get(\"maxZoomFactor\", 100))));\n\t\tthis._fixZoomFactor();\n\n\t\tif (this.get(\"logarithmic\")) {\n\t\t\tthis._minLogAdjusted = min;\n\t\t\tmin = this._minReal;\n\t\t\tmax = this._maxReal;\n\n\t\t\tif (min <= 0) {\n\t\t\t\tmin = initialMin * (1 - Math.min(extraMin, 0.99));\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tif (this.getPrivate(\"minFinal\") !== min || this.getPrivate(\"maxFinal\") !== max) {\n\n\t\t\t\tthis.setPrivate(\"minFinal\", min);\n\t\t\t\tthis.setPrivate(\"maxFinal\", max);\n\t\t\t\tthis._saveMinMax(min, max);\n\n\t\t\t\tconst duration = this.get(\"interpolationDuration\", 0);\n\t\t\t\tconst easing = this.get(\"interpolationEasing\");\n\n\t\t\t\tthis.animatePrivate({ key: \"min\", to: min, duration, easing });\n\t\t\t\tthis.animatePrivate({ key: \"max\", to: max, duration, easing });\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _fixZoomFactor() {\n\t}\n\n\tprotected _getDelta(max: number) {\n\t\t// the number by which we need to raise 10 to get difference\n\t\tlet exponent: number = Math.log(Math.abs(max)) * Math.LOG10E;\n\n\t\t// here we find a number which is power of 10 and has the same count of numbers as difference has\n\t\tlet power = Math.pow(10, Math.floor(exponent));\n\n\t\t// reduce this number by 10 times\n\t\tpower = power / 10;\n\n\t\tthis._deltaMinMax = power;\n\t}\n\n\tprotected _saveMinMax(_min: number, _max: number) {\n\n\t}\n\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, strictMode?: boolean): IMinMaxStep {\n\t\t// will fail if 0\n\t\tif (gridCount <= 1) {\n\t\t\tgridCount = 1;\n\t\t}\n\n\t\tgridCount = Math.round(gridCount);\n\n\t\tlet initialMin: number = min;\n\t\tlet initialMax: number = max;\n\n\t\tlet difference = max - min;\n\n\t\t// in case min and max is the same, use max\n\t\tif (difference === 0) {\n\t\t\tdifference = Math.abs(max);\n\t\t}\n\n\t\t// the number by which we need to raise 10 to get difference\n\t\tlet exponent: number = Math.log(Math.abs(difference)) * Math.LOG10E;\n\n\t\t// here we find a number which is power of 10 and has the same count of numbers as difference has\n\t\tlet power = Math.pow(10, Math.floor(exponent));\n\n\t\t// reduce this number by 10 times\n\t\tpower = power / 10;\n\n\t\tlet extra: number = power;\n\t\tif (strictMode) {\n\t\t\textra = 0;\n\t\t}\n\n\t\t// round down min\n\t\tif (strictMode) {\n\t\t\tmin = Math.floor(min / power) * power;\n\t\t\t// round up max\n\t\t\tmax = Math.ceil(max / power) * power;\n\t\t}\n\t\telse {\n\t\t\tmin = Math.ceil(min / power) * power - extra;\n\t\t\t// round up max\n\t\t\tmax = Math.floor(max / power) * power + extra;\n\t\t}\n\n\t\t// don't let min go below 0 if real min is >= 0\n\t\tif (min < 0 && initialMin >= 0) {\n\t\t\tmin = 0;\n\t\t}\n\t\t// don't let max go above 0 if real max is <= 0\n\t\tif (max > 0 && initialMax <= 0) {\n\t\t\tmax = 0;\n\t\t}\n\n\t\texponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n\t\tpower = Math.pow(10, Math.floor(exponent));\n\t\tpower = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance\n\n\t\t// approximate difference between two grid lines\n\t\tlet step = Math.ceil((difference / gridCount) / power) * power;\n\t\tlet stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n\n\t\t// the step should divide by  2, 5, and 10.\n\t\tlet stepDivisor: number = Math.ceil(step / stepPower); // number 0 - 10\n\n\n\t\tif (stepDivisor > 5) {\n\t\t\tstepDivisor = 10;\n\t\t}\n\t\telse if (stepDivisor <= 5 && stepDivisor > 2) {\n\t\t\tstepDivisor = 5;\n\t\t}\n\n\t\t// now get real step\n\t\tstep = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;\n\n\n\t\tlet maxPrecision = this.get(\"maxPrecision\");\n\t\tif ($type.isNumber(maxPrecision)) {\n\n\t\t\tlet ceiledStep = $math.ceil(step, maxPrecision);\n\t\t\tif (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {\n\t\t\t\tstep = ceiledStep;\n\t\t\t\tif (step == 0) {\n\t\t\t\t\tstep = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet decCount: number = 0;\n\t\t// in case numbers are smaller than 1\n\t\tif (stepPower < 1) {\n\t\t\t// exponent is less then 1 too. Count decimals of exponent\n\t\t\tdecCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;\n\t\t\t// round step\n\t\t\tstep = $math.round(step, decCount);\n\t\t}\n\n\t\t// final min and max\n\t\tlet minCount = Math.floor(min / step);\n\n\t\tmin = $math.round(step * minCount, decCount);\n\n\t\tlet maxCount: number;\n\n\t\tif (!strictMode) {\n\t\t\tmaxCount = Math.ceil(max / step);\n\t\t}\n\t\telse {\n\t\t\tmaxCount = Math.floor(max / step);\n\t\t}\n\n\t\tif (maxCount === minCount) {\n\t\t\tmaxCount++;\n\t\t}\n\n\t\tmax = $math.round(step * maxCount, decCount);\n\n\t\tif (max < initialMax) {\n\t\t\tmax = max + step;\n\t\t}\n\n\t\tif (min > initialMin) {\n\t\t\tmin = min - step;\n\t\t}\n\n\n\t\tstep = this.fixSmallStep(step);\n\n\t\treturn { min: min, max: max, step: step };\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number, _adjustPosition?: boolean): string | undefined {\n\t\tconst numberFormat = this.get(\"tooltipNumberFormat\", this.get(\"numberFormat\"));\n\t\tconst formatter = this.getNumberFormatter();\n\t\tconst extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n\t\tconst decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n\t\tconst value = $math.round(this.positionToValue(position), decimals);\n\n\t\tif (numberFormat) {\n\t\t\treturn formatter.format(value, numberFormat);\n\t\t}\n\t\telse {\n\t\t\treturn formatter.format(value, undefined, decimals);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\tlet value = this.positionToValue(position);\n\n\t\tlet index: number | undefined = undefined;\n\t\tlet oldDiff: number;\n\t\t$array.each(series.dataItems, (dataItem, i) => {\n\t\t\tconst diff = Math.abs(dataItem.get(fieldName) - value);\n\t\t\tif (index === undefined || diff < oldDiff) {\n\t\t\t\tindex = i;\n\t\t\t\toldDiff = diff;\n\t\t\t}\n\t\t});\n\n\t\tif (index != null) {\n\t\t\treturn series.dataItems[index];\n\t\t}\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` values.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start value\n\t * @param  end       End value\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToValues(start: number, end: number, duration?: number) {\n\t\tconst min = this.getPrivate(\"minFinal\", 0);\n\t\tconst max = this.getPrivate(\"maxFinal\", 0);\n\t\tif (this.getPrivate(\"min\") != null && this.getPrivate(\"max\") != null) {\n\t\t\tthis.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n\t\t}\n\t}\n\n\n\t/**\n\t * Syncs with a target axis.\n\t *\n\t * @param  min  Min\n\t * @param  max  Max\n\t * @param  step Step\n\t */\n\tprotected _syncAxes(min: number, max: number, step: number, syncMin: number, syncMax: number, syncStep: number) {\n\t\tlet axis = this.get(\"syncWithAxis\");\n\t\tif (axis) {\n\t\t\tlet count: number = Math.round(syncMax - syncMin) / syncStep;\n\t\t\tlet currentCount = Math.round((max - min) / step);\n\n\t\t\tlet gridCount = this.get(\"renderer\").gridCount();\n\n\t\t\tif ($type.isNumber(count) && $type.isNumber(currentCount)) {\n\t\t\t\tlet synced = false;\n\t\t\t\tlet c = 0\n\t\t\t\tlet diff = (max - min) * 0.01;\n\t\t\t\tlet omin = min;\n\t\t\t\tlet omax = max;\n\t\t\t\tlet ostep = step;\n\n\t\t\t\twhile (synced != true) {\n\t\t\t\t\tsynced = this._checkSync(omin, omax, ostep, count);\n\t\t\t\t\tc++;\n\t\t\t\t\tif (c > 500) {\n\t\t\t\t\t\tsynced = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!synced) {\n\t\t\t\t\t\tif (c / 3 == Math.round(c / 3)) {\n\t\t\t\t\t\t\tomin = min - diff * c;\n\t\t\t\t\t\t\tif (min >= 0 && omin < 0) {\n\t\t\t\t\t\t\t\tomin = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tomax = max + diff * c;\n\t\t\t\t\t\t\tif (omax <= 0 && omax > 0) {\n\t\t\t\t\t\t\t\tomax = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);\n\t\t\t\t\t\tomin = minMaxStep.min;\n\t\t\t\t\t\tomax = minMaxStep.max;\n\t\t\t\t\t\tostep = minMaxStep.step;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmin = omin;\n\t\t\t\t\t\tmax = omax;\n\t\t\t\t\t\tstep = ostep;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { min: min, max: max, step: step };\n\t}\n\n\t/**\n\t * Returns `true` if axis needs to be resunced with some other axis.\n\t */\n\tprotected _checkSync(min: number, max: number, step: number, count: number): boolean {\n\t\tlet currentCount = (max - min) / step;\n\t\tfor (let i = 1; i < count; i++) {\n\t\t\tif ($math.round(currentCount / i, 1) == count || currentCount * i == count) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns relative position between two grid lines of the axis.\n\t *\n\t * @return Position\n\t */\n\tpublic getCellWidthPosition(): number {\n\t\tlet max = this.getPrivate(\"selectionMax\", this.getPrivate(\"max\"));\n\t\tlet min = this.getPrivate(\"selectionMin\", this.getPrivate(\"min\"));\n\n\t\tif ($type.isNumber(max) && $type.isNumber(min)) {\n\t\t\treturn this.getPrivate(\"step\", 1) / (max - min);\n\t\t}\n\t\treturn 0.05;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic nextPosition(count?: number) {\n\t\tif (count == null) {\n\t\t\tcount = 1;\n\t\t}\n\n\t\tif (this.get(\"renderer\").getPrivate(\"letter\") == \"Y\") {\n\t\t\tcount *= -1;\n\t\t}\n\n\t\tlet value = this.positionToValue(this.getPrivate(\"tooltipPosition\", 0));\n\t\tvalue += this.getPrivate(\"step\", 1) * count;\n\t\tvalue = $math.fitToRange(value, this.getPrivate(\"selectionMin\", 0), this.getPrivate(\"selectionMax\", 1));\n\n\t\treturn this.toGlobalPosition(this.valueToPosition(value));\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}