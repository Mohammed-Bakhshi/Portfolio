{"ast":null,"code":"import { Pattern } from \"./Pattern\";\nimport { Color } from \"../../util/Color\";\n/**\r\n * Grain pattern.\r\n *\r\n * Allows to add grain (noise) effect to your [[Graphics]] objects.\r\n *\r\n * Note, grain pattern does not support `fill` and `color` setting.\r\n * Use `colors` setting to define colors of a grain pixels.\r\n *\r\n * Note, rotation setting is not supported by this pattern.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/#Grain_patterns} for more info\r\n * @since 5.5.0\r\n */\nexport class GrainPattern extends Pattern {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"canvas\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"canvas\")\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.canvas.getContext(\"2d\")\n    });\n    Object.defineProperty(this, \"_clearGrain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _beforeChanged() {\n    //document.body.appendChild(this.canvas); // temp\n    this.canvas.width = this.get(\"width\", 200);\n    this.canvas.height = this.get(\"height\", 200);\n    if (this.isDirty(\"size\") || this.isDirty(\"density\") || this.isDirty(\"minOpacity\") || this.isDirty(\"maxOpacity\") || this.isDirty(\"colors\") || this.isDirty(\"horizontalGap\") || this.isDirty(\"verticalGap\")) {\n      this._clearGrain = true;\n    }\n    super._beforeChanged();\n  }\n  _changed() {\n    super._changed();\n    if (this._clearGrain) {\n      const width = this.get(\"width\", 200);\n      const height = this.get(\"height\", 200);\n      const patternData = this.context.getImageData(0, 0, width, height);\n      const size = Math.max(1, this.get(\"size\", 1));\n      const minOpacity = this.get(\"minOpacity\", 0);\n      const maxOpacity = this.get(\"maxOpacity\", 0.3);\n      const colors = this.get(\"colors\", [this.get(\"color\", Color.fromHex(0x000000))]);\n      const cols = width / size;\n      const rows = height / size;\n      const density = this.get(\"density\", 1);\n      const horizontalGap = this.get(\"horizontalGap\", 0) + 1;\n      const verticalGap = this.get(\"verticalGap\", 0) + 1;\n      for (let r = 0; r < rows; r++) {\n        if (verticalGap > 0) {\n          if (r / verticalGap != Math.round(r / verticalGap)) {\n            continue;\n          }\n        }\n        for (let c = 0; c < cols; c++) {\n          const color = colors[Math.floor(Math.random() * colors.length)];\n          const alpha = (minOpacity + Math.random() * (maxOpacity - minOpacity)) * 255;\n          const rnd = Math.random();\n          if (horizontalGap > 0) {\n            if (c / horizontalGap != Math.round(c / horizontalGap)) {\n              continue;\n            }\n          }\n          if (rnd < density) {\n            this._setRectData(c, r, size, width, patternData.data, color.r, color.g, color.b, alpha);\n          }\n        }\n      }\n      this.context.putImageData(patternData, 0, 0);\n      this._pattern = this.context.createPattern(this.canvas, \"repeat\");\n    }\n    this._clearGrain = false;\n  }\n  _checkDirtyFill() {\n    return false;\n  }\n  _setRectData(col, row, size, width, data, rc, gc, bc, ac) {\n    for (var c = col * size; c < col * size + size; c++) {\n      for (var r = row * size; r < row * size + size; r++) {\n        var i = (r * width + c) * 4;\n        data[i] = rc;\n        data[i + 1] = gc;\n        data[i + 2] = bc;\n        data[i + 3] = ac;\n      }\n    }\n  }\n}\nObject.defineProperty(GrainPattern, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"GrainPattern\"\n});\nObject.defineProperty(GrainPattern, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Pattern.classNames.concat([GrainPattern.className])\n});","map":{"version":3,"names":["Pattern","Color","GrainPattern","constructor","Object","defineProperty","document","createElement","canvas","getContext","_beforeChanged","width","get","height","isDirty","_clearGrain","_changed","patternData","context","getImageData","size","Math","max","minOpacity","maxOpacity","colors","fromHex","cols","rows","density","horizontalGap","verticalGap","r","round","c","color","floor","random","length","alpha","rnd","_setRectData","data","g","b","putImageData","_pattern","createPattern","_checkDirtyFill","col","row","rc","gc","bc","ac","i","classNames","concat","className"],"sources":["C:\\Users\\Moham\\Downloads\\Github projects\\Digital-Portfolio-main\\Frontend\\node_modules\\src\\.internal\\core\\render\\patterns\\GrainPattern.ts"],"sourcesContent":["import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\r\nimport { Color } from \"../../util/Color\";\r\n\r\nexport interface IGrainPatternSettings extends IPatternSettings {\r\n\r\n\t/**\r\n\t * Size of a grain in pixels.\r\n\t *\r\n\t * @default 1\r\n\t */\r\n\tsize?: number;\r\n\r\n\t/**\r\n\t * Density of noise.\r\n\t *\r\n\t * Value range: `0` (no noise applied) to `1` (noise is applied to every\r\n\t * pixel).\r\n\t *\r\n\t * The bigger the value, the higher chance that pixel will have another pixel\r\n\t * painted over with random opacity from `minOpacity` to `maxOpacity`.\r\n\t *\r\n\t * @default 1\r\n\t */\r\n\tdensity?: number;\r\n\r\n\t/**\r\n\t * Minimum opacity of a noise pixel.\r\n\t *\r\n\t * @default 0\r\n\t */\r\n\tminOpacity?: number;\r\n\r\n\t/**\r\n\t * Maximum opacity of a noise pixel.\r\n\t *\r\n\t * @default 0.3\r\n\t */\r\n\tmaxOpacity?: number;\r\n\r\n\t/**\r\n\t * An array of colors to randomly use for pixels.\r\n\t *\r\n\t * @default [color(0x000000)]\r\n\t */\r\n\tcolors?: Array<Color>;\r\n\r\n\t/**\r\n\t * Horizontal gap between noise pixels measured in `size`.\r\n\t *\r\n\t * @default 0\r\n\t */\r\n\thorizontalGap?: number;\r\n\r\n\t/**\r\n\t * Vertical gap between noise pixels measured in `size`.\r\n\t *\r\n\t * @default 0\r\n\t */\r\n\tverticalGap?: number;\r\n\r\n}\r\n\r\nexport interface IGrainPatternPrivate extends IPatternPrivate {\r\n}\r\n\r\n/**\r\n * Grain pattern.\r\n * \r\n * Allows to add grain (noise) effect to your [[Graphics]] objects.\r\n * \r\n * Note, grain pattern does not support `fill` and `color` setting.\r\n * Use `colors` setting to define colors of a grain pixels.\r\n * \r\n * Note, rotation setting is not supported by this pattern.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/#Grain_patterns} for more info\r\n * @since 5.5.0\r\n */\r\nexport class GrainPattern extends Pattern {\r\n\tdeclare public _settings: IGrainPatternSettings;\r\n\tdeclare public _privateSettings: IGrainPatternPrivate;\r\n\r\n\tpublic static className: string = \"GrainPattern\";\r\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([GrainPattern.className]);\r\n\r\n\tpublic canvas: HTMLCanvasElement = document.createElement(\"canvas\");\r\n\tpublic context: CanvasRenderingContext2D = this.canvas.getContext(\"2d\")!;\r\n\r\n\tprotected _clearGrain: boolean = false;\r\n\r\n\tpublic _beforeChanged() {\r\n\t\t//document.body.appendChild(this.canvas); // temp\r\n\t\tthis.canvas.width = this.get(\"width\", 200);\r\n\t\tthis.canvas.height = this.get(\"height\", 200);\r\n\r\n\t\tif (this.isDirty(\"size\") || this.isDirty(\"density\") || this.isDirty(\"minOpacity\") || this.isDirty(\"maxOpacity\") || this.isDirty(\"colors\") || this.isDirty(\"horizontalGap\") || this.isDirty(\"verticalGap\")) {\r\n\t\t\tthis._clearGrain = true;\r\n\t\t}\r\n\t\tsuper._beforeChanged();\r\n\t}\r\n\r\n\r\n\tpublic _changed() {\r\n\t\tsuper._changed();\r\n\r\n\t\tif (this._clearGrain) {\r\n\t\t\tconst width = this.get(\"width\", 200);\r\n\t\t\tconst height = this.get(\"height\", 200);\r\n\r\n\t\t\tconst patternData = this.context.getImageData(0, 0, width, height);\r\n\r\n\t\t\tconst size = Math.max(1, this.get(\"size\", 1));\r\n\t\t\tconst minOpacity = this.get(\"minOpacity\", 0);\r\n\t\t\tconst maxOpacity = this.get(\"maxOpacity\", 0.3);\r\n\r\n\t\t\tconst colors = this.get(\"colors\", [this.get(\"color\", Color.fromHex(0x000000))])\r\n\r\n\t\t\tconst cols = width / size;\r\n\t\t\tconst rows = height / size;\r\n\t\t\tconst density = this.get(\"density\", 1);\r\n\t\t\tconst horizontalGap = this.get(\"horizontalGap\", 0) + 1;\r\n\t\t\tconst verticalGap = this.get(\"verticalGap\", 0) + 1;\r\n\r\n\t\t\tfor (let r = 0; r < rows; r++) {\r\n\r\n\t\t\t\tif (verticalGap > 0) {\r\n\t\t\t\t\tif (r / verticalGap != Math.round(r / verticalGap)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let c = 0; c < cols; c++) {\r\n\t\t\t\t\tconst color = colors[Math.floor(Math.random() * colors.length)];\r\n\t\t\t\t\tconst alpha = (minOpacity + Math.random() * (maxOpacity - minOpacity)) * 255;\r\n\t\t\t\t\tconst rnd = Math.random();\r\n\r\n\t\t\t\t\tif (horizontalGap > 0) {\r\n\t\t\t\t\t\tif (c / horizontalGap != Math.round(c / horizontalGap)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rnd < density) {\r\n\t\t\t\t\t\tthis._setRectData(c, r, size, width, patternData.data, color.r, color.g, color.b, alpha);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.context.putImageData(patternData, 0, 0);\r\n\t\t\tthis._pattern = this.context.createPattern(this.canvas, \"repeat\");\r\n\t\t}\r\n\r\n\t\tthis._clearGrain = false;\r\n\t}\r\n\r\n\tprotected _checkDirtyFill() {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _setRectData(col: number, row: number, size: number, width: number, data: Uint8ClampedArray, rc: number, gc: number, bc: number, ac: number) {\r\n\t\tfor (var c = col * size; c < col * size + size; c++) {\r\n\t\t\tfor (var r = row * size; r < row * size + size; r++) {\r\n\t\t\t\tvar i = (r * width + c) * 4;\r\n\r\n\t\t\t\tdata[i] = rc;\r\n\t\t\t\tdata[i + 1] = gc;\r\n\t\t\t\tdata[i + 2] = bc;\r\n\t\t\t\tdata[i + 3] = ac;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}